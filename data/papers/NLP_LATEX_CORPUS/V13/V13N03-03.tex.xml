<?xml version="1.0" ?>
<root>
  <title>選好依存文法とその圧縮共有データ構造「依存森」について</title>
  <author>平川秀樹</author>
  <jabstract>選好依存文法(PDG:PreferenceDependencyGrammar)は，自然言語の形態素，構文，意味解析を統合的に行う枠組みであり，各レベルの種々の曖昧性を統合的に効率良く保持し，各レベルの知識により優先度を設定し，全体解釈として最適な解を計算する．本稿では，PDGの基本モデルである多レベル圧縮共有データ結合モデルとPDGの概要について述べるとともに，選好依存文法で用いられるヘッド付き統語森，依存森といった言語解釈を統合保持するデータ構造とその構築手法について説明する．また，文の句構造を圧縮共有する統語森と依存構造を圧縮共有する依存森との対応関係において完全性と健全性が成立することを示す．</jabstract>
  <jkeywords>文解析，句構造,依存構造，圧縮共有データ構造</jkeywords>
  <jkeywords>文解析，句構造,依存構造，圧縮共有データ構造</jkeywords>
  <subsection title="">*付録１：構文グラフの問題次の文法規則を与えて``Tokyotaxidrivercallcenter''をスタートシンボルをnpとして解析する場合を考える．[GrammarRules]np/NP--&gt;npc/NP:[]npc/Nb--&gt;np1/NP1,n/Na,n/Nb:[arc(nj,NP1,Nb),arc(nc,Na,Nb)]npc/Na--&gt;np2/NP2,n/Na:[arc(nc,NP2,Na)]npc/Na--&gt;np3/NP3,n/Na:[arc(nc,NP3,Na)]np1/Nc--&gt;n/Na,n/Nb,n/Nc:[arc(nc,Na,Nb),arc(nc,Nb,Nc)]np2/Nd--&gt;n/Na,n/Nb,n/Nc,n/Nd:[arc(nj,Na,Nc),arc(nc,Nb,Nc),arc(nc,Nc,Nd)]np3/Nd--&gt;n/Na,n/Nb,n/Nc,n/Nd]:[arc(nc,Na,Nb),arc(nj,Nb,Nd),arc(nc,Nc,Nd)][Lexicon]word(n,[Tokyo]).word(n,[taxi]).word(n,[driver]).word(n,[call]).word(n,[center]).verbatimcommentこの例文では，図の(a),(b),(c)の３つの依存木が解として存在する．依存木のnp1,np2,np3の箱は，句構造と依存構造の対応を分かりやすく示すために補助的に入れている．(a)では，nc-1,nc-2，(b)では，nc-2,nc-3，(c)では，nc-3,nc-1の間で共起関係が成立するため，図の構文グラフ/排他マトリックスにおいて，それぞれ対応する排他マトリックスは``''となっている．このため，(d)の依存木も依存グラフ/排他マトリックスに存在するが，これに対応する構文木は存在せず，健全性が損なわれている．</subsection>
  <section title="はじめに">自然言語は，多様性・曖昧性，規則性と例外性，広範性・大規模性，語彙・文法の経時変化などの性質を持っている．自然言語解析システムは，これらの性質をアプリケーションが要求するレベルで旨く扱う必要がある．なかでも多様性・曖昧性への対応，すなわち，形態素，構文，意味，文脈などの各種レベルにおける組合せ的な数の曖昧性の中からいかにして正しい解釈を認識するかがシステム構築上，最も重要な課題である．一般に自然言語解析システム(以下システムと省略する)は，入力文に対して可能な解釈の仮説を生成し（仮説生成知識の適用），ありえない仮説を棄却したり(制約知識の適用)，仮説に対する順位付けを行ったり（選好知識の適用）することで，入力文に対する解析結果(文解釈となる構造)を求める．図がこのモデルを示している．文の解釈は，仮説記述体系により規定される仮説空間に存在し，それぞれが実世界において，正解解釈（◎:correct），可能解釈（○:plausible），不可能解釈（×:implausible）に分類できる．仮説生成知識が可能な仮説集合を生成する．制約知識は仮説空間内の仮説が可能か不可能かを弁別し，選好知識は仮説空間内の仮説の順位付けを行う．仮説生成・制約知識は，システムが受理可能な文の範囲，すなわち，システムの対象文カバレッジを規定する．仮説生成・制約・選好知識は，形態素，構文，意味といった各レベルにおいて存在し，システムの性能はこれらの総合として決定されると考えられる．例えば，各レベルの選好知識がそれぞれ異なった解釈を支持するという競合が生じるため，精度良く文解釈を行うにはこれらを総合的に判断する必要がある．このように，システム設計においては，「生成・制約・選好知識をどのように扱うか」（知識適用の課題），「多レベルの知識をどのように融合するか」（多レベル知識の課題）という２つの課題が存在する．生成・制約知識は，正文と非文とを弁別(あるいは，正文のみを生成)する，いわゆる，言語学の文法知識に相当する．従来，言語学からの知見を活用しながら計算機処理を前提とした各種の文法フレームワークが研究されてきている．文法フレームワークは，文の構造解釈を記述する解釈構造記述体系を基盤として構築されるが，これらには，句構造，依存構造，意味グラフ，論理式など様々ものが提案されている．一方，選好知識については意味プリファレンスの扱いを始めとして古くから多くの研究がなされているが，音声認識処理から自然言語処理への導入が始まった統計的手法が，単語系列から文脈自由文法，依存文法などへと適用範囲(解釈記述空間)を拡大・発展させ，広くシステムに利用されるようになってきている．例えば，句構造をベースの枠組みとして，文脈自由文法，LFG，HPSG,CCGなど，また依存構造をベースとした枠組みとして，確率依存文法,係り受け解析,制約依存文法(以降CDGと記述する)，LinkGrammarなど文法フレームワークと統計手法の融合が広範に行われている．このように，文法フレームワークの研究は，生成・制約知識を対象とした研究から統計ベースの選好知識の扱いへと進展し，統計的手法は語系列，句構造，依存構造へと適用範囲を拡大し融合され，生成・制約・選好知識全体の統合のベースが整ってきている．多レベルの知識の融合という観点では，基本的に単一の解釈記述空間に基づくアプローチと複数の解釈記述空間に基づくアプローチがある．単一の文脈自由文法，依存文法などは前者の典型である．DCGやBUPなどは文脈自由文法をベースにしているが，拡張条件が記述可能であり，例えば意味的な制約といった異レベルの知識を句構造という１つの解釈記述空間をベースとしながら融合することができる．CDGでは依存構造をベースにして構文的な制約を含む任意の制約条件を単項制約，２項制約という枠組みで記述できるようにしている．LFGは，c-structure(句構造)とf-structure(機能構造)の２種類のレイヤを有し機能スキーマにより機能構造に関する制約条件が記述可能である．また，統計ベースのアプローチにおいては，句構造情報だけではなく句のヘッドやその依存関係情報の利用が有効であることが判明し，句構造情報と依存構造情報を統合判断するモデルが利用されている．PDGは，複数の解釈記述空間に基づくアプローチを取っており，後に述べるように複数の解釈記述空間で対応付けられた圧縮共有データ構造をベースに多レベルの知識の融合を行っている．本稿では，PDGのモデル・概要について述べた後，PDGで採用している句構造と依存構造という２種類の中心的共有データ構造であるヘッド付き統語森(HPF:HeadedParseForest)，依存森(DF:DependencyForest)について構築法を示し，それらに完全性と健全性が成立することを示す．また，例文解析実験により，PDGの振る舞いや特徴についても考察を加える．</section>
  <section title="選好依存文法(PDG)の概要と圧縮共有データ構造"/>
  <subsection title="多レベル圧縮共有データ結合モデル">PDGは，自然言語の曖昧性・多義性の問題に焦点をあてて設計された形態素・構文・意味レベルの文解析を行うフレームワークである．ターゲットとしている課題は，[(a)]組み合わせ爆発の回避[(b)]生成・制約・選好知識の適切な扱い[(c)]多レベル知識のモジュラリティと統合である．この課題に対して，図に示す多レベルの圧縮共有データを結合した方式（多レベル圧縮共有データ結合モデル）に基づく解析方式を採用している．各レベルは，入力文に対するそれぞれの解釈記述空間における言語解釈の全てを圧縮共有データ構造の形式で保持する．入力文に近い側を下位，出力に近い側を上位レベルと呼ぶ．各レベルの各解釈は上位・下位のレベルの解釈との対応が取られており(図の「対応」でマークした点線)，本稿では，これを解釈リンケージと呼ぶ．多レベル圧縮共有データ結合モデルでは，下位レベルの解釈はより上位のレベルの解釈を内包しており，入力文は，全ての解釈を内包している．各レベルにおいて，それぞれ生成・制約・選好知識が存在する．生成知識は，１つ下位のレベルの解釈から現在のレベルの解釈を生成（外延化）する(図の矢印)．制約知識は，現在のレベルの解釈を制限し，選好知識は，現在のレベルの解釈の優先度を設定する．このモデルにより，PDGは次の実現を狙っている．[(a)]句構造，依存構造等の複数のデータ構造(言語知識の記述ベース)を利用して，形態素，構文，意味の多レベルの知識をモジュール独立性良く扱う．[(b)]各レベルで圧縮共有型のデータ構造を用意し各レベルでの全曖昧性を効率良く保持することで基本的に枝刈りをしないで組合せ爆発を抑制する．[(c)]入力文から最上位レベルまでの解釈リンケージによりマルチレベルの選好知識(選好スコア)を統合し，精度向上を図る．[(d)]文解釈となる依存木を圧縮共有した選好スコア付き圧縮共有データ構造から制約と選好を組み合わせた最適解探索手法により最適解を探索する．一般に各レベルの解釈の内で制約知識を満足する解釈を整合解釈(well-formedinterpretation)と呼ぶ．最適解釈の探索は各レベル毎に定義可能であり，各レベルの選好知識を利用して，そのレベルの最適解釈を取り出すことができる．先に述べたように文解析の深さ，出力をどうするかはアプリケーションが基本的に規定する事項である．例えば，同じ機械翻訳でも文の構造表現として同属言語の場合は句構造表現がよいが，語族が違うと依存構造表現が適切であったりする．また，解釈リンケージを利用することにより，上位レベルで最適な解釈を選択し，その解釈に対応する下位レベルの解釈を下位レベルの最適解釈として取り出す方法も考えられる．例えば，意味解析結果として最適な解釈に基づいたタガーなどが自然に実現できる．</subsection>
  <subsection title="選好依存文法(PDG)のモデル">PDGの全体モデルを図に示す．語品詞トレリス，ヘッド付き統語森，機能依存森，意味依存森の４つの圧縮共有データ構造により，それぞれ，語品詞系列，構文木(句構造)，機能依存木，意味依存木の解釈の集合を保持する．それぞれを計算する処理を形態素解析，構文解析，構造生成，意味構造化と呼ぶ．各レベルのデータ構造の概要を図に示す．PDGでは，単語に対する解釈のレベルとして単語，語品詞，語彙概念の３階層を採用し，各語に語彙情報として付与されていると想定している．語品詞トレリスは語品詞の隣接関係の解釈を表現する語品詞系列を保持する．ヘッド付き統語森は，後に述べるが，語や句のカテゴリの下位範疇化(あるいは系列関係)を表現する構文解析木を保持する．句構造頻度の選好知識，数の一致などの構文的制約など記述できる．機能依存森は語品詞間の機能依存関係を表現する機能依存木を保持し，意味依存森は語彙概念間の意味関係を表現する意味依存木を保持する．以下では簡略のため単に依存森と表記した場合は，機能依存森を示す．各レベルのデータ構造に対してそれぞれの選好知識により優先度を与え，これをデータ構造間の対応関係（解釈リンケージ）を通じて統合し，最終的には，最適解釈探索により最も確からしい解釈（意味依存木）が計算される．現在，依存森のレベルまでの処理システムが試作されており，最適解釈探索も依存森に対して行われ依存木を出力するモデルとなっている．意味依存森レベルは今後の課題とし，以下本稿では依存森までのモデルを対象とする．多レベル構成により他のレベルの知識を活用することが可能となる．例えば，依存関係をベースとした単一レベル圧縮共有構造モデルであるCDGは，基本的に全てのノード間に全ての依存関係(仮説)を生成してeliminativeparsingを行う．解釈の枝刈りを行わないという優れた利点があるが生成解釈数が多く効率面で問題があり，改善手法が提案されている．PDGでは依存構造に対して全可能性を有する依存森を生成するが，これは下位レベルの統語森中の解釈のみから派生する依存木であり，句構造レベルの知識の活用による効率化が行える．また，後述するが，句構造の記述体系を利用することにより，non-projectiveな依存構造を導入可能となり，依存構造としての記述能力の向上にもつながっている．以上のようにPDGでは，多レベルの圧縮共有データ構造が重要な役割を果たしている．以下では，PDGの共有データ構造であるヘッド付き統語森，依存森について説明してゆく．</subsection>
  <subsection title="圧縮共有データ構造の要件">多レベル圧縮共有データ結合モデルにおける圧縮共有データ構造には次の性質が必要である．各レベルで組合せ爆発が起こらない各種レベルの曖昧性を過不足なく表現できる各レベルでの知識記述のベースとして適切である各種レベル間の解釈リンケージが取れる(a)は，実システムを構築する際に特に重要な課題である．一般に解釈の組合せ展開を行うと直ぐに扱いが困難になり，また，計算時間的にも不十分となる．(b)は，多レベルの知識を扱う場合に，各レベルの曖昧性を全て過不足なく表現できること，すなわち共有構造そのものに由来する解釈の枝刈り(あるべき解釈の欠落)や解釈の過生成(あるべきでない解釈の生成)が起こらないという性質である．この性質を保持した上でシステム構築上有効な枝刈りを導入できることは重要な好ましい性質である．(c)は，それぞれのレベルでの知識の記述が行いやすいこと,選好知識と制約知識が適切に扱えることであり，(d)は各レベルの解釈の対応関係を取ることができるという性質である．</subsection>
  <subsection title="句構造と依存構造の併用">文解析を精度良く行なうためには様々な知識を利用する必要がある．従来，文の構造を記述する代表的枠組みとして句構造と依存構造がある．句構造は，品詞への抽象化により語や句の順序に関する知識の記述に優れており，依存構造は語の間の種々の依存関係に関する知識の記述に優れている．それぞれの表現レベルでの制約知識・選好知識の記述を自然な形で可能とするため，PDGでは，句構造形式の共有データ構造(ヘッド付き統語森)と依存構造形式の共有データ構造(依存森)をそれぞれ関連付けて組み込んでいる．これは句構造(C-構造)と機能構造(F-構造)という２つの構文レベルの表現を持つLFGにおいて，SUBJECT,OBJECTなど構文的機能に関する制約がF-構造で記述され，文法の記述性を高めているのと類似している．なお，Early法，Chart法といった文脈自由文法の解析アルゴリズムを用いて依存文法を直接解析して依存構造を求める手法も提案されているが，句構造を作らない点で本手法とは異なっている．comment</subsection>
  <subsection title="圧縮共有データ構造の従来技術と問題点"/>
  <subsubsection title="語品詞トレリスと圧縮共有統語森">語品詞トレリスは，全ての語品詞系列を圧縮共有するデータ構造であり，PDGでもそのまま利用する．構文レベルの解析手法としては文脈自由文法をベースにした解析が広く用いられておりPDGもこれを利用する．文脈自由文法で入力文を解析し文の可能な解釈全体を得る手法は広く知られており，例えば，富田により，グラフスタックを用いた構文解析手法と共に文の句構造解釈(構文木)全体を効率的に保持する圧縮共有統語森(PackedSharedParseForest)が提案されている．圧縮共有統語森中の構文木は，語品詞トレリス中の語品詞系列と対応関係が取れ多レベル圧縮共有データ結合モデルとして利用可能である．</subsubsection>
  <subsubsection title="意味係り受けグラフ">文献は，意味係り受けグラフを提案し，係り受けの多義（構文的多義）と係り受け意味関係の多義を効率良く保持する手法を提案した．意味係り受けグラフは，ATN文法を用いて句構造解析を行い係り受け関係を表す依存グラフを生成し，そこから意味係り受け関係を表す意味係り受けグラフを生成する．意味係り受けグラフは，修飾語が被修飾語の左に位置する，英語などに比べ品詞多義は殆どないという日本語の特徴を前提に設計されているため，多品詞を扱えないなど英語などに適用できないという汎用性に関する問題を有しており，PDGの圧縮共有データ構造としては採用しない．</subsubsection>
  <subsubsection title="構文グラフ/排他マトリックス">Seoは，文の句構造解釈全体と対応する依存構造全体を効率良く保持する方法として構文グラフ(SyntacticGraph)を提案した．構文グラフは，PDGの共有データ構造として有望であったが，大きな問題もありそのまま採用することはできないことが判明した．構文グラフは，単語間の依存関係をベースに文の可能な解釈を圧縮共有する枠組みである．構文グラフは，語品詞に対応するノードとノード間の依存関係を表現する名前付きアークで構成される有向グラフであり，排他マトリックス(EM:ExclusionMatrix)と呼ばれるデータと組になって，入力文に含まれる依存構造の集合（文の解釈の集合）を表現する．構文グラフは，３次組(Triple)と呼ばれる，アーク名とその両端のノード(語品詞，表層位置などを持つ)の組からなる集合で表現される．図は，``Timeflieslikeanarrow''に対する構文グラフ/排他マトリックスである．アークの括弧中の番号はそのIDである．１つのノードに入る複数のアークは修飾の曖昧性を表現している．Sは，開始記号に相当する．排他マトリックスは，構文グラフを構成するアークを行・列とし，アーク間の共起制約を記述するために導入されている．排他マトリックスのi行j列が1である場合には，i番目とj番目のアークは，いかなる解釈(依存木)においても共起しない．構文グラフ/排他マトリックスは，統語森に基づいたデータ構造から生成される．PDGでも同じデータ構造を用いており，これをヘッド付き統語森と呼ぶ．ヘッド付き統語森の詳細は，章で述べる．なお，以下では，単に統語森と言った場合はヘッド付き統語森を意味し，従来の統語森はヘッド無し統語森と記述することとする．文献では，統語森と構文グラフ/排他マトリックス間の完全性(completeness),健全性(soundness)について言及している．完全性は，「統語森中の１つの構文木が存在した時に，構文グラフ/排他マトリックス中にそれに対応する依存木が存在する」という性質であり，健全性は，「構文グラフ/排他マトリックス中の１つの依存木が存在した時に，統語森中にそれに対応する構文木が存在する」という性質である．構文グラフ/排他マトリックスの完全性が成立することは示されているが，健全性については保証されていない．排他マトリックスは，３次組の間の共起関係を規定しているが，ある１つの構文木に対応する依存木が存在した場合，その依存木に含まれる３次組の間の共起排他制約を排他マトリックスから除外するという方法で構成される．排他マトリックスは，全ての依存構造の解釈を規定するため，この除外された共起排他制約が他の全ての解釈(依存木)において制約として必要でない場合にのみ健全性が保証されることになる．付録１に構文グラフで健全性が破綻する例を示す．</subsubsection>
  <section title="PDGにおける共有データ構造">PDGでは，前節で述べた従来手法の問題を解決するデータ保持方式として，文脈自由文法の構文構造の保存方式としてヘッド付き統語森を採用し，依存構造の保存方式として依存森を提案する．</section>
  <subsection title="ヘッド付き統語森">ヘッド付き統語森は統語森の一種であり，適用された書き換え規則に対応する弧(edge)から構成され，次の条件を満足する構文木を圧縮共有する．句の非終端記号(カテゴリ)が同じ句の被覆する単語範囲が同じ句ヘッドとなる主構成素(語品詞)が同じ(a),(b)の２つがヘッド無し統語森の共有条件である．ヘッド付き統語森中の構文木は，統語森中の構文木と対応が取れる．PDGにおける弧とヘッド付き統語森の具体例は構築アルゴリズムと共に章で述べる．</subsection>
  <subsection title="依存森">依存森は，依存グラフ(DG:DependencyGraph)と共起マトリックス(CM:Co-occurrenceMatrix）より成る．以下，依存森の構造と依存木について説明する．</subsection>
  <subsubsection title="依存グラフと共起マトリックス">図は，``Timeflieslikeanarrow''に対する依存森の例である.依存グラフは，語品詞に対応するノードと１つのルートノードrootならびに，ノード間の依存関係を表現する名前付きアークより構成される．依存グラフは，rootをルートノードとする有向グラフであり，実際には，アークとその両端のノードの組からなる依存片(dependencypiece)の集合として表現する.アークは，アーク名とIDを有す．アークの元側を依存ノード(dependentあるいはmodifier)，先側を支配ノード(governorあるいはmodificand)と呼ぶ．また，ノードには，表層位置などの情報も含まれている．アークの数を依存森のサイズと呼ぶ．また，依存グラフの部分集合で木構造を成すアーク集合が依存木であり，文や句の解釈を表現する．依存グラフは複数の依存木を含む圧縮共有データ構造となっている．共起マトリックスは，アークIDで示されたアーク集合を行と列に取り，アーク間の共起関係を規定する．共起マトリックスCM(i,j)が○の場合に限り，アークiとjは１つの依存木（解釈）において共起可能であるという制約を表現する．共起関係は双方向関係であり，CMは対称行列となる．</subsubsection>
  <subsubsection title="整依存木">依存森中の依存木のうち次の整依存木条件を満たす依存木を整依存木(Well-formedDependencyTree)と呼ぶ．整依存木条件とは，次の３つの条件(a)〜(c)全体をいう．表層位置が同じノードは存在しない(語品詞単一解釈条件）入力文の単語と，入力文に対応する依存木のノードの間に1対1対応が取れる(被覆条件）共起マトリックスにおいて共起関係が成立する(整共起条件)definition(a)(b)の２つを纏めて整被覆条件と呼び，これを満たす木を整被覆木(Well-coveredDependencyTree)と呼ぶ.また，(c)を満たす依存木を整共起依存木(Well-cooccurredDependencyTree)と呼ぶ．整依存木の集合が入力文に対する解釈の集合となる．図の依存森では，「時は矢のように過ぎる」，「時ハエは矢を好む」，「矢のようにハエを計れ」，「矢のようなハエを計れ」に対応する4つの整依存木が存在する．なお，ノード１つからなる依存木(アークが存在しない)も，整依存木として扱う．この場合のみ依存木はノード１つからなる集合となる．</subsubsection>
  <subsubsection title="初期依存森と縮退依存森">複数の解釈に対するアークの共有の度合いによって，同じ依存木の集合を表すサイズの異なった複数の依存森を構成可能である．詳細は後述するが，PDGでは，初期依存森(InitialDependencyForest)と，それから変換して得られる縮退依存森(ReducedDependencyForest)の2種を扱う．それぞれ，初期依存グラフと初期共起マトリックス，ならびに，縮退依存グラフと縮退共起マトリックスよりなる．単に依存森と呼んだ場合は，通常後者を示す．図の初期依存グラフは，図の構文グラフと比較すると，``fly/n''と``time/v''の間のアーク数が異なっている．対応する縮退依存森については後述する．</subsubsection>
  <section title="統語森と依存森の生成">PDGでは，形態素解析，構文解析，統語森・初期依存グラフの生成，縮退依存森導出の順で解析が進む．本稿では，形態素解析処理については省略し，構文解析以降について述べる．</section>
  <subsection title="文法規則">PDGにおいて文法規則は，可能な句構造の定義と，句構造から依存構造へのマッピングとを規定する拡張文脈自由文法(extendedCFG)で記述される．文法規則は，次の形式をしている．y/Yx_1/X_1,,x_n/X_n:[arc(arcname_1,X_i,X_j),,arc(arcname_n-1,X_k,X_l)](0&lt;i,j,k,ln)［例］vp/Vv/V,np/NP,pp/PP:[arc(obj,NP,V),arc(vpp,PP,V)]規則は，``:''で区切られた書き換え規則部と構造構築部よりなる．書き換え規則の左辺の``y/Y''及び構成素(constituent)``x_i/X_i''は，``構文カテゴリ/構造変数''を表す．Yは句ヘッド(phrasehead)と呼ばれ，主構成素(headconstituent)に相当し，規則ボディ(rulebody)である``X_1X_n''のいずれかと同一となる．構造構築部は，``arc(アーク名,構造変数1,構造変数2)''という形式のアークの集合であり，構造変数には，書き換え規則部の構成要素の句ヘッドとなる語品詞が束縛される．例は，Vをヘッドとし，objアークでNPが，vppアークでPPが接続する依存構造を示している．規則中の部分依存構造は，次の部分依存構造条件を満足する整部分依存構造である．部分依存構造条件とは次の２つの条件(a),(b)全体をいう．主構成素に対応する句ヘッドYをルートとする木構造である．(非主構成素は，他の構成素と依存関係（アーク）を持つ)規則ボディの構成素の句ヘッドは，部分依存構造をなす木構造の構造変数と１対１対応が取れるdefinition例文``Timeflieslikeanarrow''を解析するための文法規則と辞書を図に示す．規則(R0)は，規則ヘッドをroot，規則ボディをスタートシンボル(s)とし，トップノード[root]-xを導入する特殊な規則であり，ルート規則と呼ぶ．ルート規則は，統語森のルートとなる弧と依存森のトップノードをそれぞれ１つにするために導入している．</subsection>
  <subsection title="構文解析">PDGの構文解析は，本稿では，Bottom-upChartParsingのアルゴリズムをベースに，依存構造の生成が可能となるよう，弧の構成やアルゴリズムを拡張することにより実現している．</subsection>
  <subsubsection title="弧の構成と例">ChartParsingにおいて，弧は，始点(FP)，終点(TP)，規則ヘッド頂点(C)，既存構成素列(FCS)，残り構成素列(RCS)の５次組&lt;FP,TP,C,FCS,RCS&gt;から構成される．文法規則のヘッドは，規則ヘッド頂点に，規則ボディは，既存構成素列と残り構成素列に対応し，ドット（・）で規則ボディ内の区切りを表現し，次の例のような形式で図式的に表現される．&lt;0,1,snp・vppp&gt;この弧は，文法規則``snpvppp''から生成される例であり，FP=0,TP=1,C=s,FCS=[np],RCS=[vp,pp]である．また，入力単語に対する辞書の検索結果は，次の例のように，品詞をヘッドとし、単語をボディとする不活性弧として表現される．&lt;0,1,n[time]・&gt;PDGの構文解析では，文法規則の部分依存構造に対する処理と複数の弧の圧縮共有処理の２点で拡張を行っている．依存構造構築のため，通常のChartParsingの弧に句ヘッド(PH)と部分依存構造(DS)を追加しており，模式的に示すと次のようになる．通常の弧：&lt;0,1,snp・vppp&gt;PDGの弧：&lt;0,1,s/PHnp/NP・vp/PHpp/PP:DS&gt;節で述べたように，PHが句ヘッド(ノード)，DSが部分依存構造(アーク集合)を示す．また，詳細は後述するが，不活性弧については圧縮共有を行うため，複数の弧を１つに纏めた圧縮弧というデータ構造を利用する．圧縮弧は，既存構成素列(FCS)と部分依存構造(DS)の部分を，それぞれのリストに拡張したものである．圧縮弧に対して，１つの構成素列と部分依存構造を持つ弧を単一弧と呼ぶ．圧縮弧は，共有可能な単一弧の集合と等価である．次にこれらの対応関係を模式的表現で例示する．単一弧：&lt;0,5,s/PHnp/NPvp/PHpp/PP・:DS1&gt;&lt;0,5,s/PHnp/NPvp/PH・:DS2&gt;圧縮弧：&lt;0,5,s/PH[[np/NPvp/PHpp/PP],[np/NPvp/PH]]・:[DS1,DS2]&gt;この例で，PHは句ヘッド，[np/NPvp/PHpp/PP],[np/NPvp/PH]は構成素列，DS1,DS2は部分依存構造を示している．以下では簡便のため，圧縮弧は``E''，``&lt;E&gt;''，「弧E」などで，単一弧は``e''，``&lt;e&gt;''，「弧e」などで示す．曖昧でない場合や区別が必要でない場合などは単に「弧」とも記述する．また，不活性弧は，記号の前に*をつけて表現する．弧*Eは不活性圧縮弧，弧*eは不活性単一弧を示す．以下で示すPDGの構文解析は，圧縮弧のデータ形式で行われる．図に圧縮弧の構成を示す．圧縮弧は8次組で構成されている．FCSLとDSLは同じ長さのリストであり，i番目の要素を取り出した(FCS_i,DS_i)をCSDSペアと呼ぶ．CSDSペアは，上記の単一弧に対応している．図の弧E1〜*E3は，名詞句規則に対応する弧が解析が進むにつれて生成されてゆく例である．弧*E3は，``anarrow''をnpとして解釈し，部分依存構造としてarc(det-14,[an]-det-3,[arrow]-n-4)を持つ不活性弧(RCSが[])である．[arrow]-n-4は，単語[arrow],品詞n,位置4のノードである．弧*E4は，複数の解釈を持つ弧の例である．FCSLの２要素とDSLの２要素がそれぞれ対応し，([103,169]obj-25])と([103,119,165]obj-4,vpp-20)の２つのCSDSペアが存在している．弧@E5のような，辞書引きにより生成される不活性弧は語彙弧(lexicaledge)と呼ぶ．語彙弧の部分依存構造は，ノード１つからなる集合である．語彙弧は@をつけて@E,@eの様に表現する．</subsubsection>
  <subsubsection title="構文解析アルゴリズム">[b]figure*図にPDGの構文解析アルゴリズムを示す．基本構成は，Agendaを用いた一般的なChartParsingアルゴリズムであり，先頭から順次入力単語を語彙弧化してAgendaに追加処理する処理((a),(b)）とAgendaが空になるまでAgenda中の不活性弧に対して文法規則ならびにChart中の活性弧から可能な弧を生成・展開する弧の結合の処理((e),(f))より成る．Agenda中の弧は，Chart中の弧と共有可能かどうかが判定され((c),(j))，共有可能な場合はマージされる((d))ことにより，圧縮共有が行なわれる．基本的に一般的なアルゴリズムであり，詳細な説明は省略するが，次にPDG特有の依存構造の構築の部分について説明する．本アルゴリズムは，弧を生成しながら弧の部分依存構造を構築する．これは句ヘッド(ノード)と依存構造中の構造変数を束縛することで実現される．この変数束縛は，不活性弧と文法規則から新しい弧が生成される時点((g))，ならびに，不活性弧とChart中の活性弧により新しい弧が生成される時点((h))，すなわち弧の結合が生じる時点で，bind_varにより不活性弧の句ヘッドが他方の弧の残り構成素列の先頭の構造変数に束縛されることで行なわれる．さらに，この変数束縛により依存ノードと支配ノードの両方が束縛されたアーク(確定アークと呼ぶ)に対して，add_arcidによりユニークなアークIDが付与される((i))．図の弧E2の変数2にノード[arrow]-n-4が束縛されると弧*E3になる．それぞれの弧は弧IDで関連付けられており，弧からその下位の弧(構成要素に対応）を順次辿れる．図の弧*E3では，弧#160(弧IDが160の弧)は，``npdet,n''の規則から生成された弧であり，既存構成素列[153,156]は，弧#153が文法規則中の構成素detに，弧#156が構成素nに対応することを示している．また，弧*E4のように複数の既存構成素列を持つ弧は，merge_csds((d))により生成される．構文解析に成功した場合には，Chartには句ヘッドが[root]-xで文全体を被覆する不活性弧が１つ存在する．これをルート弧(rootedge)と呼ぶ．</subsubsection>
  <subsection title="統語森・初期依存森の生成">構文解析後のChartは，活性弧，不活性弧より成る．この集合に対して，不活性弧*Eから辿れる弧の集合をhpf(*E)と記述する．ルート弧を*E_rootとした時，統語森はhpf(*E_root)となる．ルート弧から到達できない不活性弧も存在するため，hpf(*E_root)はChart中の不活性弧全体の部分集合となる．初期依存グラフは，統語森中のアークの集合であり，hpf(*E_root)と同時に求められる．また，初期共起マトリックスも同時に求められる．図に統語森・初期依存森を求めるアルゴリズム,また，図に，図の文法を用いて例文を構文解析した結果得られる統語森を示す．統語森を構成する全ての弧は不活性弧であるため，残り構成素列([])は省略している．なお，統語森の圧縮弧の数を統語森のサイズと呼ぶ．弧の同一性において句ヘッドを考慮しているため(図(j))ヘッド付き統語森のサイズは，ヘッド無し統語森のサイズ以上となる．図のアルゴリズムは，try_edge,try_FCSL,try_CSの３つの関数を再帰的に呼びながら，それぞれの引数(圧縮弧，構成素列リスト，構成素列)の下位の要素(構成素列リスト，構成素列，圧縮弧）を深さ優先で重複を避けてトラバースする構成となっている((d),(h),(j))．それぞれの関数の実行後は,その引数に対する統語森HPF，依存グラフDG，共起マトリックスCMの要素や値が追加設定されている．try_edge(E),try_FCSL(FCSL),try_CS(CS)が返すアーク集合中のアークをそれぞれ弧E,構成素列リストFCSL,構成素列CSが支配するアークと呼ぶ．全体に対する処理は,図の(a)の``try_edge(ルート弧)''である.try_edgeでは，(b)で既に実行済みか否かを判定し，実行済みの場合は，TERに記録済みのアーク集合を取り出して返す．TERへの登録を行なうのは(g)である．HPFに弧が追加されるのは，(c)と(e)においてである．(f)にあるように，弧Eが支配するアークは，弧EのDSL中のアークとFCSLの支配するアークの和集合である．try_FCSLは，複数のCSDSペアを処理し，try_CSは，その中の１つのCSを処理する．(i)にあるように，FCSLの支配するアーク集合は，その要素であるCSが支配するアークの和集合である．また，(k)にあるように，CSの支配するアーク集合は，その要素である圧縮弧が支配するアークの和集合である．図の弧#170を例に処理の具体例を図に示す．(c#)は関数の呼び出し，(r#)はその結果(支配するアーク集合)を示す．(c1)〜(c4)は，図(j),(d),(h)の再帰呼び出しである．弧#103は語彙弧であるため，(c4)は(r4)のを返す．(c3)の処理が終了し(r3)を得ると，(c2)の２番目のCSDSペア([103,119,165],obj-4,vpp-20)に対する処理(c5)が行なわれる．(c6)で再度``try_edge(弧#103)''が実行されるが，この時は，図(b)でTERに保存された計算結果を検索して返す．最終的に(r1)が得られる．ここで，共起マトリックスの生成処理について説明する．共起マトリックスは，１つの構文木に同時に含まれるアークの間に共起可能性を設定するよう，次の共起設定条件により設定される．共起設定条件とは次の3つの条件(CM1),(CM2),(CM3)のいずれかをいう．１つの部分依存構造DS中のアークは共起するCSDSペア(CS,DS)において，CSが支配するアークは，DS中のアークと共起する１つの構成素列CSが支配するアーク間には共起関係があるdefinitionこれはそれぞれ図のCM処理(1)〜(3)に対応している．弧#170の例では，try_FCSLの処理で2番目のCSDSペア([103,119,165],obj-4,vpp-20)に対してCM処理(1)で(CM1)すなわちset_CM(obj-4,vpp-20,obj-4,vpp-20)が実施される．また，CM処理(2)では，A_CSは図(r5)となり，(CM2)すなわちset_CM(obj-4,vpp-20,pre-15,det-14)が実施される．また，try_CS([103,119,165])の処理において，CM処理(3)により(CM3)すなわち弧#103,#119,#165が支配するアーク間の共起関係のCMへのセットが行われる．例題に対するアルゴリズムの出力は，図の統語森ならびに図の初期依存森となる．弧#181,#176,#174は，同じ非終端記号sと句の範囲(0から5)を持つが，句ヘッドとなるノードが異なるため共有されておらず，ヘッド無し統語森とは異なっている．</subsection>
  <subsection title="縮退依存森の生成">初期依存森には，図におけるobj4とobj25のようにアークID以外は同一のアークが存在することがあり，これを同値アークと呼ぶ．同値アークは，１つの文法規則から生成されたり，複数の文法規則から生成されたりする．例えば，obj4とobj25は，図の(R9),(R10)の構成素列``vpnp''の部分から生成されている．(R9),(R10)は，前置詞句の有無という差はあるが，``vpnp''の関係は２つの規則で同一であり，依存構造の解釈という観点から同値アークは等価であると言えるを導入すれば(R9),(R10)をvp/Vv/V,np/NP,pp/PP:[arc(obj,NP,V),arc(vpp,PP,V)]のように１つの規則に統合できる．この規則からは同値アークは生成されない．．同値性を扱うために，いくつかの定義を行う．ID付きアークのアークIDを``?''と置換したアークを汎化アークと呼ぶ．アークを全て汎化した依存木を汎化依存木と呼ぶ．通常のID付きのアークからなる依存木を明示する時はID付き依存木と記述する．また，アークXの汎化アークを?X，依存木DTの汎化依存木を?DTのように記述する．汎化依存木が等しい２つのID付き依存木は同値であると言う．縮退依存森は，初期依存森を縮退することで得られる．依存森の縮退とは，依存森の健全性を保持しながら複数の同値アークを１つにマージする操作であり，結果として依存森のサイズは小さくなる．</subsection>
  <subsubsection title="同値アークのマージ操作">依存グラフDG中の同値アークX,Y(equiv(X,Y)と記述する)に対するマージ操作を次のように定義する．マージ操作依存グラフDGより，Yを削除して新たな依存グラフDG'を得る．(DG'=DG-Y)アークI(IDG,IX,IY,CM(Y,I)=○)に対して，set_CM(X,I)を行なうことにより共起マトリックスCMより新たな共起マトリックスCM'を得る．definitionマージ操作によりDG',CM'からなる新たな縮退依存森が得られる．図にマージの例を共起マトリックスの形式で模式的に示す．以下の議論で依存木の集合やアークの集合などを定義するが，マージ操作の前後の区別を示す場合には，``wrtDG,CM''あるいは``wrtDF''(wrt:withrespectto)の表現を付けて示す．例えば，以下で定義するアークXを含む整依存木の集合dts(X)に対して，``dts(X)wrtDG,CM''，``dts(X)wrtDG',CM'''はそれぞれマージ前と後の依存森に対する集合を示し，``dts(X)wrtDG,CM=dts(X)wrtDG',CM'''は，マージの前後でdts(X)の値が同じことを示す．簡便のため，以下では``wrtDG,CM''の部分は基本的に省略している．初期依存グラフの全同値アークをマージすると構文グラフと同じ構造になり，健全性を保てなくなる．</subsubsection>
  <subsubsection title="同値アークのマージ条件">依存森の縮退の定義より，依存森の健全性を保持すること，すなわち，同値アークのマージの前後で新規の汎化依存木(新規の解釈)が生成されないことが縮退の条件である．同値アークのマージ条件]「同値アークX,Yのマージ前後の依存森をそれぞれDF,DF'とした時，縮退条件は，``DF中の汎化整依存木集合=DF'中の汎化整依存木集合''である．」この条件は，依存森DF'に新規の汎化依存木が存在しないことを検証することで検証できる．今，DFに対してDF'に新規の汎化依存木が存在するための条件を汎化依存木の増加条件とすると，同値アークのマージ条件は，「汎化依存木の増加条件が満足されないこと」と等しい．依存森はID付きアークより構成されているため，ID付き依存木の集合と(それから得られる)汎化依存木の集合の２つを規定している．今，DFに対してDF'に新規のID付き依存木が存在する条件をID付き依存木の増加条件(``DF中のID付き整依存木集合DF'中のID付き整依存木集合'')とする．ID付き依存木が増加しなければ汎化依存木の増加はなく，また，ID付き依存木が増加してもそれがDF中のID付き依存木と同値であれば汎化依存木の増加は起こらない．すなわち，ID付き依存木の増加条件は汎化依存木の増加条件の必要条件である．以下では，まず，ID付き依存木の増加条件を検証し，次に汎化依存木の増加条件を検証するという考え方で同値アークのX,Yのマージ条件を詳細化する．</subsubsection>
  <subsubsection title="ID付き依存木の増加条件">新たな(ID付き)整依存木の増加は，同値アークのマージにより新たにアーク間に共起関係が許されることに起因する．アークU,Vに対してCM(U,V)○がCM(U,V)=○に変化することをアークペア(U,V)の許諾と呼び，次が成立する．[アークペアの許諾と整依存木の増加]アークペア(U,V)の許諾により新たな整依存木が増加する場合，その依存木はU,Vを要素として含んでいる．lemma補題は，もしU,Vの許諾によりUとVの両方を同時に含まない新しい依存木が生成されると仮定するとその依存木は許諾の前でも存在してしまうことになることから明らかである．ここで，同値アークX,Yに対してuniq,diffを次のように定義する．uniq(X,Y)=ICM(X,I)=○,CM(Y,I)○,IDGdiff(X,Y)=(I,J)Iuniq(X,Y),Juniq(Y,X)図の例では，uniq(X,Y)=j,n,uniq(Y,X)=k,diff(X,Y)=(j,k),(n,k)となる．一般に次が成立する．[新規の整依存木の含むアーク]同値アークX,Yのマージにより新たに整依存木が生成される場合には，その依存木は少なくとも１つの(A,B)diff(X,Y)であるA,Bを含む．X,Yのマージ前後の依存森をそれぞれDF,DF'とする．X,Yのマージで生じるアークペア(X,B_i)の許諾により新たな依存木DT_xが得られたとすると，補題より，X,B_iは，DT_xの要素である．ここで，R=DT_x-X,B_iとする．URを考えると，DT_xは整依存木であるからCM(X,U)=○wrtDF',CM(B_i,U)=○wrtDF'である．今，CM(Y,U)○wrtDFであるアークUが存在しない,すなわちCM(Y,U)=○wrtDF,URを仮定すると，DT_y=Y,B_i+Rは，共起条件を満足する整依存木となる．DT_xとDT_yは，同値アークX,Yが異なるだけなので，DT_xは新たな依存木ではない．よって，新たな依存木DT_xには少なくとも１つCM(Y,U_i)○wrtDFなるU_iが存在する必要がある．(B_i,U_i)diff(X,Y)であるので補題が成立する．lemma補題より，次のID付き依存木の増加条件が成立する．[ID付き依存木の増加条件]DG,CMにおいて同値アークX,Yに対するアークペア(A,B)diff(X,Y)とした時，YをXにマージして得られるDG',CM'において,X,A,Bを含むID付き整依存木NDTが存在する時，またこの時に限り，ID付き依存木は増加する．新規に生成される整依存木は必ずX,A,Bを含むこと，X,A,Bを含む整依存木は必ず新規解であることを示せばよい．今，DG',CM'中の新たなID付き依存木をNDTとすると，補題より，少なくとも１つのアークペア(A_i,B_i)diff(X,Y),A_iNDT,B_iNDTが存在する．また，補題より，XNDTである．よって，新規に生成される整依存木は必ずX,A,Bを含む．また，(A,B)diff(X,Y)よりX,A,Bを含むID付き整依存木はDG,CMに存在しない．よって，X,A,Bを含むID付き整依存木は必ず新規に生成される整依存木である．theorem以下で解の増加条件を詳細化するため，ここでいくつかの関数や記法を導入する．13.7cm：アークU,Vの依存ノードの位置が等しい：CMの共起制約を満たしながら，アーク集合SDGから得られるID付き整依存木の集合：アークUあるいはUと共起するアーク集合，XX=UまたはCM(X,U)=○,XDGである．:DG,CM中の整依存木でアークA_1,A_2,,A_nを含む整依存木の集合，すなわち，dts(co(A_1)co(A_n))wrtDG,CMである．minipage同値アークX,Yに対するdiff(X,Y)中のアークペア(A,B)に関するID付き依存木の増加条件の判定は，定理よりX,A,Bを含む整依存木がDG',CM'に存在するか探索することにより基本的に実現できる．これをできるだけ効率的に行うため，X,A,Bに関して次の３つの場合に分けて考える．same_position(A,B)またはsame_position(X,A)またはsame_position(X,B)が成立．CM(A,B)○である．(RC1)(RC2)以外の場合．(RC1)が成立する場合は，整依存木の整被覆条件によりアークが排他関係となりX,A,B全てを含む整依存木は存在しないと判定できる．(RC2)の場合は，マージ後でもCM'(A,B)○であるためDG',CM'においてX,A,Bを含む整依存木は存在しないと判定できる．(RC3)の場合はX,A,Bを含む整依存木が存在しない，すなわち，dts_with_arcs(X,A,B)wrtDG',CM'=の判定を行えば良い．</subsubsection>
  <subsubsection title="汎化依存木の増加条件">既に述べたようにID付き依存木の増加条件は汎化依存木の増加条件の必要条件である．このため，ID付き依存木の増加条件を満たす場合，すなわち，dts_with_arcs(X,A,B)wrtDF'(=New_DTsとする)の場合に，NDTNew_DTsに対して，NDTが汎化依存木の増加となっている場合にのみ汎化依存木の増加が生じる．逆に言えば，NDTがDF'に存在した場合でも，汎化依存木?NDTがDFに存在していれば，汎化依存木の増加は起こらない．これより，ID付き依存木が増加する場合における同値アークのマージ条件は次のようになる．「同値アークX,Yのマージ前後の依存森DF,DF'に対して，新規に増加するDF'中のID付き依存木DT_newに対して，?DT_new=?DTなるID付き整依存木DTがDFに存在する」</subsubsection>
  <subsubsection title="依存森の縮退アルゴリズム">前節の依存森の縮退条件,すなわち同値アークのマージ条件に基づき依存森の縮退を行うアルゴリズムを図に示す．アルゴリズムでは，共起マトリックスを集合として表現している．アークX,Yに対して，&lt;X,Y&gt;CMであれば共起関係が成立している．以下，アルゴリズムの動作を縮退条件に照らし合わせて図を参照しながら説明する．図(a)で依存グラフ中にある同値アークペアX,Yを順次取り出し，diff(X,Y)中のアークペア(A,B)について，許諾を行った場合に解(汎化依存木)の増加が起こるかを(b)-(h)でチェックする．全アークペアに対して汎化依存木の増加が起こらない場合に(i)で依存森の縮退が行なわれる．(A,B)の許諾の可否は，ID付き依存木の増加条件の確認の後に汎化依存木の増加条件の確認を行うことで判定される．(b)では，節の(RC1),(RC2)の条件がチェックされ，いずれかを満たす場合は解の増加がないため，次のアークペアの確認に進む．そうでない場合は，ID付き依存木の増加条件の確認に進む．(c)では，YをXにマージしたDG',CM'を生成する．新規依存木の存在チェックは，基本的に依存森に対する解の探索により行うため，できるだけ探索空間を少なくすることで効率化が図れる．定理より新規のID付き依存木はX,A,Bを含むので，(d)ではco(X)co(A)co(B)によりX,A,B全てと共起するアーク以外を除いたアーク集合DG_XABを計算し，(e)でsearch_dtによりDG_XABに対して依存木を探索する．依存木が得られなければ，このアークペアは同値アークのマージ条件を満たすので，次のアークペアの処理に進む．依存木DTが得られた場合，DTはX,A,Bを含む新規のID付き依存木である．(f)のnew_generalized_dt(DT,CM,DG)は，CM,DG中にDTの同値依存木が存在するかを探索することで，DTが汎化依存木として新規かをチェックする．詳細な説明は省略するが，(q)においてDTの同値アークのみにアーク集合を限定することで汎化依存木の探索を実現している．DTが汎化依存木として新規の場合は，X,Yのマージはできないため(g),(h)で同値アークX,Yに対する処理を終了し次の同値アークペアのマージにトライする．汎化依存木として解が存在しない場合には，(i)においてX,Yのマージ，すなわち，依存森の縮退が行われる．なお，(f)においてDTが汎化依存木として新規でない場合は，(e)においてDG_XABに対して別の解の探索が行われる．search_dtは，入力位置Pに関して深さ優先に共起条件を満足する解を探索するアルゴリズムである．(k)においてDG中の位置Pのノードを依存ノードとして持つアーク集合arcs_at(DG,P)から１つアークを選択するが，(m)において，P+1以降で解が見つからなければ(k)で別のアークを選択することで，全解を探索する．</subsubsection>
  <subsubsection title="依存森縮退アルゴリズムの動作例">最終的に縮退依存森に同値アークが残る例として付録１の``Tokyotaxidrivercallcenter''に対するアルゴリズムの動作を示す．例文に対する初期依存森を図(a)に示す．初期依存森には(1,2),(5,7),(13,15),(25,26,27)の４種の同値アークが存在し，図のマトリックスでは2重線で括られたまとまりとして示されている．図のアルゴリズムに従って縮退処理が行なわれる．最初の同値アークequiv(1,2)に対しX=1,Y=2となり，diff(X,Y)は，uniq(X,Y)=5,24,25,uniq(Y,X)=14,15,27の組合せ(5,14),(5,15),(5,27),となる．最初のアークペア(5,14)は，same_position(5,14)であるため図(b)において(RC1)の条件判定でスキップされ，次のアークペア(5,15)が選択される．(5,15)の場合は，(b)の条件に確定しないため，(c)においてCM',DG'が生成される．CM'=CM+&lt;1,14&gt;,&lt;1,15&gt;,&lt;1,27&gt;であり，図(b)に示す．次に図(d)においてDG_XABが計算される．X=1,A=5,B=15であり，DG_XAB=co(1)co(5)co(15)wrtDG',CM'=1,28となる．(e)のsearch_dtによるDG_XABに対する解探索は失敗するため，(5,15)の許諾は新規の依存木を生成しない．さらにアークペア(5,27)のチェックへと処理が進む．以上のようにしてdiff(1,2)の全てのアークペアに関してチェックが行われるが，いずれもが新規解を生成することなく終了し，(i)において依存森の縮退が行われ，CM'DG'が新規のCM,DGに設定される．図(c)は，最終的に得られる縮退依存森であり，同値アーク25,26,27を持つ．この依存森に対する縮退アルゴリズムの動作を示す．今,X=25,Y=26の時，uniq(X,Y)=1,24,uniq(Y,X)=6,13,diff(X,Y)=(1,6),(1,13),(24,6),(24,23)である．アークペア(1,6)は(RC1)の条件を満たす．アークペア(1,13)は，(RC1),(RC2)を満足せず，図(d)においてDG_XABが計算される．X=25,A=1,B=13であり，DG_XAB=co(25)co(1)co(13)wrtDG',CM'=25,1,13,5,28となる．DG_XABに対して(e)のsearch_dtを実行すると25,1,13,5,28が新規のID付き依存木として検索される．次に(f)においてnew_generalized_dtが実行され，(q)でadd_equiv_arcsによりDT中の各アークに対する同値アークが追加されたアーク集合DG_Xが計算される．図(c)では，25が同値アーク26,27を持つので，これらが追加され，DG_X=25,26,27,1,13,5,28となる．図(r)のsearch_dtでは，解が計算されるが，同値アーク25,26,27のそれぞれに対して&lt;25,13&gt;,&lt;26,1&gt;,&lt;27,5&gt;がCMにおいて共起条件を満足しないためsearch_dtはfalseとなる．この結果，(f)のnew_generalized_dtがtrue,すなわち汎化依存木として解の増加となるため，X=25,Y=26のマージは行われない．図(c)の依存森は，付録１の図の(a)〜(c)の３つの依存構造のみを保持しており，健全性が保たれている．縮退処理により生成される依存森は一意に決まるという訳ではなく，マージを試みる同値アークの順番により異なった結果が得られたりする．例えば，上記の例でも，同じ３つの汎化依存木を含む複数の縮退依存森が存在する．図のアルゴリズムは最小の縮退依存森を得るという保証はなく，実際図(c)よりサイズの小さい依存森も存在する．また，縮退アルゴリズムの計算量に関しても改善の余地がある．最小の依存森の構成法やアルゴリズム効率化などについては今後の課題とする．</subsubsection>
  <subsection title="統語森と依存森の対応関係">依存森は，統語森との間で完全性と健全性が成立する．付録２に初期依存森の完全性と健全性の証明を示す．縮退依存森は初期依存森と同じ(汎化)依存木の集合を保持しているため，統語森と(縮退)依存森に完全性と健全性が成立すると言える．統語森中の構文木（句構造）と依存森中の依存木（依存構造）の対応関係は単純な1対1対応ではなく，1つの構文木が複数の依存木に対応したり，複数の構文木が１つの依存木に対応したりする．言語表現の多様性（１つの意味を複数の表現で表現可能）と曖昧性（１つの表現で複数の意味を表現可能）を考えれば，こうした対応関係は自然な関係であると考えられる．構文木と依存木の対応関係については，次章の評価実験において例文の解析結果とともに述べる．</subsection>
  <section title="例文解析評価実験">PDGは依存森により整依存木集合を圧縮共有して表現することにより，各種の曖昧性により生じる組合せ爆発を抑制することを狙いの１つとしており，本稿では，PDGの構文解析から圧縮依存構造の構築までの方式を中心に述べている．本章では，自然言語の各種の曖昧性を記述したPDG文法を用いて，典型的な曖昧性例文の構文解析・依存森生成実験を行い，各種の曖昧性がどの様に処理されるかについて述べると共に，統語森と依存森との対応関係やNon-projectiveな依存木の生成についても実例も用いながら述べる．なお，アルゴリズムの効率も実用上重要なファクタであるが，本稿で示した構文解析アルゴリズム，統語森・依存森構成アルゴリズム，依存森縮退アルゴリズムは，PDGの解析方式の検証を行うことを主眼に実装をしており，実システムとしての実装では種々の改善が考えられる．PDGの実装上の検討，テストコーパスなどを使った性能評価などについては，今後の課題とする．なお，以下の実験では，Prolog上に実装されたPDGの試作システムを利用している．</section>
  <subsection title="例文解析用文法">図は，例文解析に使用した文法規則であり，代表的な各種曖昧性構文を含んでいる．文法中の品詞det,n,be,ving,v,adv,pre,relcは，それぞれ，冠詞，名詞，BE動詞，動詞の現在分詞，動詞，副詞，前置詞，関係節を表している．また，図にはトップノードを導入するルート規則は明示されていないが，文全体(s)と名詞句(np)を解析結果として受理するルート規則を想定している．この文法は例題分析実験用のため，言語学的妥当性や厳密性は二義的である．文法には次のような構文的曖昧性が記述されている．：R6(名詞修飾)とR10,R17(動詞修飾)の2種類がある：R11(〜and〜),R12(〜or〜)の名詞句並列を表す規則が存在する：be動詞に対してR15(現在進行形の構文)とR16(copulaの構文)の構文解釈曖昧性規則が存在する：動詞の現在分詞形に関しては様々な解釈が可能であり，次のような用法が記述されている名詞が現在分詞の主格を占める形容詞的用法(R7)名詞が現在分詞の目的格を占める形容詞的用法(R8)名詞句が動詞の目的格となる動名詞句(R9,R10)R8とR9は動詞と名詞の修飾関係としては類似しているが，どちらが主辞(句ヘッド)であるかという依存構造の観点からは異なった構造である．また，平叙文(R1)と命令文(R2)のパタンもあり，``Timeflieslikeanarrow''のような多品詞の曖昧性と組み合わさって種々の構文解釈を生成する．また，(R19)は，non-projectiveな依存木，すなわち，交差する依存関係を含む依存木を生成する規則である．以下では，上記文法を用いて代表的な曖昧性例文等を解析した結果について述べる．</subsection>
  <subsection title="典型的曖昧性例文の解析">多品詞に起因する曖昧性の解析例については，既に例題として述べている．以下では，自然言語の統語的な曖昧性の代表例として前置詞付加曖昧性，接続詞スコープ曖昧性，構造解釈曖昧性の３つについて前記PDG文法での解析例を示す．</subsection>
  <subsubsection title="前置詞付加曖昧性(PP-attachment)">図は，前置詞の付加(PP-attachment)曖昧性の例文``Isawagirlwithatelescopeintheforest''に対する依存森である．依存グラフのアークには，アーク名/アークIDと選好スコアが付与されている．各ノードの品詞や表層位置情報は依存グラフの下の対応表に示している．この例では多品詞曖昧性を持つ語はないが，前置詞``with''に2つ(npp13,vpp14)，``in''に3つ(npp23,npp25,vpp26)の依存先の曖昧性が存在する．図に示すように，これらのアーク間には，共起マトリックスで○が存在しない組合せ，すなわち共起制約がかかっているアークの組がいくつか存在している．npp13とvpp14，npp23とnpp25とvpp26は，それぞれ位置を同じくするアークであるため被覆制約の1種である単一役割制約がかかっている．また，vpp14とnpp25の間には非交差制約がかかっている．この共起制約がなければ，前置詞句付加曖昧性の組合せにより2*3=6個の解が存在するが，CM(14,25)○によりNon-projectiveな依存木が排除され，この依存森は5つの整依存木（解釈）を含んでおり，例文に対して可能な前置詞句付加曖昧性を適切に表現している．例文に対して，統語森のサイズは25，初期依存森のサイズは18，縮退依存森のサイズは13である．統語森は5つの解釈に対応する5つの構文木からなる集合ここでいう構文木の数は，始点，終点，規則ヘッド頂点，句ヘッド，既存構成素列に関して弧の同一性を判定することで構文木の同一性を判定した場合の数であり，部分依存構造(アーク集合)は同一性判定に含まれていない．，初期依存森と縮退依存森は，5つのID付き依存木(5つの汎化依存木に対応)の集合に対応している．初期依存森は，obj5,npp13,vpp14,pre11に関してそれぞれ2本,1本,1本,1本の同値アークを有している．例えば，obj5とその同値アークは，次に模式的に示す単一弧から生成されるが，これらは全て文法規則(R14)から生まれた弧である．&lt;1,4,vp/([saw]-v-1)v(ID:109)np(ID:126)・,arc(obj-5,[girl]-n-3,[saw]-v-1)&gt;&lt;1,7,vp/([saw]-v-1)v(ID:109)np(ID:163)・,arc(obj-15,[girl]-n-3,[saw]-v-1)&gt;&lt;1,10,vp/([saw]-v-1)v(ID:109)np(ID:203)・,arc(obj-28,[girl]-n-3,[saw]-v-1)&gt;最初の弧は，被覆範囲が1〜4(``sawagirl''に対応)で，句ヘッドが[saw]-v-1，圧縮弧v(ID:109)とnp(ID:126)を構成素としてもち，アークIDが5で関係名がobjのアークを有する．これら同値アークは弧の範囲がそれぞれ異なった名詞句との結合により生成されている．これらは全て1つのアークにマージされ，縮退依存森では同値アークは存在していない．同値アーク[[(5),15,28],[(13),32],[(14),33],[(11),27]]最終アーク30,4,5,13,14,10,11,25,23,26,20,21,35(obj-5)：スコープが異なる：ノードの範囲とは無関係にマージ可能としている（できる場合とできない場合の弁別を入れることが考えられる）**newarcid:arc_share(obj-15,[girl]-n-3,[saw]-v-1)173:[1,7]vp/([saw]-v-1)--&gt;[109163]*:[[arc(obj-15,[girl]-n-3,[saw]-v-1)]]**newarcid:arc_share(obj-5,[girl]-n-3,[saw]-v-1)135:[1,4]vp/([saw]-v-1)--&gt;[109126]*:[[arc(obj-5,[girl]-n-3,[saw]-v-1)]]**newarcid:arc_share(obj-28,[girl]-n-3,[saw]-v-1)222:[1,10]vp/([saw]-v-1)--&gt;[109203]*:[[arc(obj-28,[girl]-n-3,[saw]-v-1)]]163:[2,7]np/([girl]-n-3)--&gt;[126161]*:[[arc(npp-13,[with]-pre-4,[girl]-n-3)]]126:[2,4]np/([girl]-n-3)--&gt;[119122]*:[[arc(det-4,[a]-det-2,[girl]-n-3)]]203:[2,10]np/([girl]-n-3)--&gt;[163199]*:[[arc(npp-25,[in]-pre-7,[girl]-n-3)]]--npp-13の同値アーク：163:[2,7]np/([girl]-n-3)--&gt;[126161]*:[[arc(npp-13,[with]-pre-4,[girl]-n-3)]]228:[2,10]np/([girl]-n-3)--&gt;[126213]*:[[arc(npp-32,[with]-pre-4,[girl]-n-3)]]======Numberofvarioustrees========[ParseForest](a)ParseForestSize:25(b)Numberofcollectionofparsetrees:5(c)Numberofsetofparsetrees:5[DependencyForest](I-1)InitialDFsize:18(I-2)InitialDFID-treecollectionnumber:5(I-3)InitialDFID-treesetnumber:5(I-4)InitialDFGeneralized-treenumber:5(R-1)ReducedDFsize:13(R-2)ReducedDFID-treecollectionnumber:5(R-3)ReducedDFID-treesetnumber:5(R-4)ReducedDFGeneralized-treenumber:5commentcomment</subsubsection>
  <subsubsection title="接続詞スコープの曖昧性">図は，接続詞のスコープ曖昧性を含む名詞句``EarthandMoonorJupitorandGanymede''に対する依存森である．3つの接続詞のスコープの組合せに対応して``Earth''に3つ，``Moon''に2つのアークの依存先の曖昧性が存在する．前節の例と同様，被覆制約だけ満足する場合には，前置詞句スコープ曖昧性の組み合わせで6つの解釈が存在するが，or22とand12が非交差制約に対応する共起マトリックスの制約を持っているため，1つの依存木が排除され，この依存森は合計5つの整依存木を持っている．例文に対して，統語森のサイズは18，初期依存森のサイズは17，縮退依存森のサイズは10である．統語森は5つの解釈に対応する5つの構文木からなる集合，初期依存森と縮退依存森は，5つのID付き依存木(5つの汎化依存木に対応)からなる集合に対応している．初期依存森は，or22,or9,cnj6,and18,cnj14は各々1本,1本,1本,2本,2本の同値アークを有している．これらは全て1つのアークにマージされ，縮退依存森では同値アークは存在していない．接続詞スコープ曖昧性は，前置詞付加曖昧性と類似しているが，後に述べる修飾スコープの問題を持つという点で言語現象的には異なっている．同値アーク[[(22),23],[(9),10],[(6),7],[(18),19,20],[(14),15,16]]最終アーク25,12,4,2,22,9,6,18,14,26-----dgarc(and-25,[earth]-n-0,[ganymede]-n-6)dgarc(and-12,[earth]-n-0,[jupitor]-n-4)dgarc(and-4,[earth]-n-0,[moon]-n-2)dgarc(cnj-2,[and]-and-1,[earth]-n-0)dgarc(or-22,[moon]-n-2,[ganymede]-n-6)dgarc(or-9,[moon]-n-2,[jupitor]-n-4)dgarc(cnj-6,[or]-or-3,[moon]-n-2)dgarc(and-18,[jupitor]-n-4,[ganymede]-n-6)dgarc(cnj-14,[and]-and-5,[jupitor]-n-4)dgarc(root-26,[ganymede]-n-6,[root]-x-root)×dgarc(or-23,[moon]-n-2,[ganymede]-n-6)×dgarc(or-10,[moon]-n-2,[jupitor]-n-4)×dgarc(cnj-7,[or]-or-3,[moon]-n-2)×dgarc(and-19,[jupitor]-n-4,[ganymede]-n-6)×dgarc(and-20,[jupitor]-n-4,[ganymede]-n-6)×dgarc(cnj-15,[and]-and-5,[jupitor]-n-4)×dgarc(cnj-16,[and]-and-5,[jupitor]-n-4)======Numberofvarioustrees========[ParseForest](a)ParseForestSize:18(b)Numberofcollectionofparsetrees:5(c)Numberofsetofparsetrees:5[DependencyForest](I-1)InitialDFsize:17(I-2)InitialDFID-treecollectionnumber:5(I-3)InitialDFID-treesetnumber:5(I-4)InitialDFGeneralized-treenumber:5(R-1)ReducedDFsize:10(R-2)ReducedDFID-treecollectionnumber:5(R-3)ReducedDFID-treesetnumber:5(R-4)ReducedDFGeneralized-treenumber:5comment</subsubsection>
  <subsubsection title="構造解釈の曖昧性">図は，構造解釈上の曖昧性を含む例文``Myhobbyiswatchingbirdswithtelescope''に対する依存森である．この例も，多品詞曖昧性を持たないが，``be''動詞の解釈(コピュラか進行形か)，``watchingbirds''の解釈(adjs3,adjo4,obj5)，前置詞の付加曖昧性(npp21,vpp22,npp24,vpp25)等を持っており，「私の趣味は双眼鏡で鳥を見ることです」，「私の趣味は，双眼鏡で鳥を見ています」，「私の趣味は双眼鏡を持った見る鳥です」など10の解釈に対応する整依存木を含んでいる．例文に対して，統語森のサイズは23，初期依存森のサイズは24，縮退依存森のサイズは16である．統語森は10の解釈に対応する8つの構文木集合，初期依存森と縮退依存森は，10のID付き依存木(10個の汎化依存木に対応)の集合に対応している．初期依存森は，dsc9,dsc8,obj5,npp21,vpp22に関してそれぞれ2本,2本,5本,2本,2本の同値アークを有している．この例では，節の例とは異なり，複数の規則から同値アークが生成されている．例えば，obj5の同値アークは，(R9),(R10),(R15)などの文法規則から得られる次に示すような弧に含まれている．(R9)⇒&lt;3,5,np/([watching]-ving-3)ving(ID:121)np(ID:130)・,arc(obj-5,[birds]-n-4,[watching]-ving-3)&gt;(R10)⇒&lt;3,7,np/([watching]-ving-3)ving(ID:121)np(ID:130)pp(ID:176)・,arc(obj-6,[birds]-n-4,[watching]-ving-3),arc(vpp-22,[with]-pre-5,[watching]-ving-3)&gt;(R15)⇒&lt;2,5,vp/([watching]-ving-3)be(ID:117)ving(ID:121)np(ID:130)・,arc(prg-2,[is]-be-2,[watching]-ving-3),arc(obj-7,[birds]-n-4,[watching]-ving-3)&gt;これら同値アークは全て1つのアークにマージされ，結果として得られる縮退依存森では同値アークは存在していない．この例では，統語森が8つの構文木を持つのに対して解釈(汎化依存木)の数は10となっており，1つの構文木が複数の依存木に対応する例となっている．以下，構文木と依存木の対応関係について述べる．##同じ依存片の組[[(9),30],[(8),31],[(5),6,7,27,29],[(21),23],[(22),25]]&gt;CurrentSameArcIDList:[[9],[8],[5],[21],[22]]XM,1,35,33,2,4,3,9,8,5,21,24,26,22,20,41,38同値アークで違う規則からの期待(R9)np/V→ving/V,np/NP:[arc(obj,NP,V)]	(R10)np/V→ving/V,np/NP,pp/PP:[arc(obj,NP,V),arc(vpp,PP,V)]--&gt;objアークdgarc(obj-5,[birds]-n-4,[watching]-ving-3)×dgarc(obj-6,[birds]-n-4,[watching]-ving-3)×dgarc(obj-7,[birds]-n-4,[watching]-ving-3)×dgarc(obj-27,[birds]-n-4,[watching]-ving-3)×dgarc(obj-29,[birds]-n-4,[watching]-ving-3)138:[3,5]np/([watching]-ving-3)--&gt;[ving(121)np(130)]*:[[arc(obj-5,[birds]-n-4,[watching]-ving-3)]]139:&lt;3,5&gt;np/([watching]-ving-3)--&gt;[ving(121)np(130)]*pp/C/true:[[arc(obj-6,[birds]-n-4,[watching]-ving-3),arc(vpp-_89026,C,[watching]-ving-3)]]140:[2,5]vp/([watching]-ving-3)--&gt;[be(117)ving(121)np(130)]*:[[arc(prg-2,[is]-be-2,[watching]-ving-3),arc(obj-7,[birds]-n-4,[watching]-ving-3)]]187:[3,7]np/([watching]-ving-3)--&gt;[121177]*:[[arc(obj-27,[birds]-n-4,[watching]-ving-3)]]188:&lt;3,7&gt;np/([watching]-ving-3)--&gt;[121177]*pp/C/true:[[arc(obj-28,[birds]-n-4,[watching]-ving-3),arc(vpp-_106115,C,[watching]-ving-3)]]--117:[2,3]be/([is]-be-2)--&gt;[lex([is]-be)]*:[[]]121:[3,4]ving/([watching]-ving-3)--&gt;[lex([watching]-ving)]*:[[]]130:[4,5]np/([birds]-n-4)--&gt;[n(128:birds)]*:[[]]177:[4,7]np/([birds]-n-4)--&gt;[np(130)pp(176)]*:[[arc(npp-21,[with]-pre-5,[birds]-n-4)]]======Numberofvarioustrees========[ParseForest](a)ParseForestSize:23(b)Numberofcollectionofparsetrees:10(c)Numberofsetofparsetrees:8[DependencyForest](I-1)InitialDFsize:24(I-2)InitialDFID-treecollectionnumber:10(I-3)InitialDFID-treesetnumber:10(I-4)InitialDFGeneralized-treenumber:10(R-1)ReducedDFsize:16(R-2)ReducedDFID-treecollectionnumber:10(R-3)ReducedDFID-treesetnumber:10(R-4)ReducedDFGeneralized-treenumber:10==========================dgarc(det-1,[my]-det-0,[hobby]-n-1)dgarc(sub-35,[hobby]-n-1,[is]-be-2)dgarc(sub-33,[hobby]-n-1,[watching]-ving-3)dgarc(prg-2,[is]-be-2,[watching]-ving-3)dgarc(adjo-4,[watching]-ving-3,[birds]-n-4)dgarc(adjs-3,[watching]-ving-3,[birds]-n-4)dgarc(dsc-9,[watching]-ving-3,[is]-be-2)dgarc(dsc-8,[birds]-n-4,[is]-be-2)dgarc(obj-5,[birds]-n-4,[watching]-ving-3)dgarc(npp-21,[with]-pre-5,[birds]-n-4)dgarc(npp-24,[with]-pre-5,[watching]-ving-3)dgarc(vpp-26,[with]-pre-5,[is]-be-2)dgarc(vpp-22,[with]-pre-5,[watching]-ving-3)dgarc(pre-20,[telescope]-n-6,[with]-pre-5)dgarc(root-41,[is]-be-2,[root]-x-root)dgarc(root-38,[watching]-ving-3,[root]-x-root)======Numberofvarioustrees========[ParseForest](a)ParseForestSize:23(b)Numberofcollectionofparsetrees:10(c)Numberofsetofparsetrees:8[DependencyForest](I-1)InitialDFsize:24(I-2)InitialDFID-treecollectionnumber:10(I-3)InitialDFID-treesetnumber:10(I-4)InitialDFGeneralized-treenumber:10(R-1)ReducedDFsize:16(R-2)ReducedDFID-treecollectionnumber:10(R-3)ReducedDFID-treesetnumber:10(R-4)ReducedDFGeneralized-treenumber:10comment</subsubsection>
  <subsection title="構文木と依存木の１対多/多対１対応関係">統語森中の構文木と依存森中の依存木の対応関係は保証されているが，1つの構文木が複数の依存木に対応したり，複数の構文木が１つの依存木に対応したりする．以下では実験文法を用いて具体例を示しながら，同一意味解釈に対する構文構造と依存構造の表現力についても考察を加える．</subsection>
  <subsubsection title="１構文木の複数依存木への対応">1つの構文木が複数の依存木に対応するのは，１つの構文構造に対する解釈が複数存在するような場合であり，例えば，``watchingbird''という文に対して動詞の現在分詞形が名詞を修飾しているという１つの構文構造をアサインした時，依存構造としてwatching[]subjbirdとwatching[]objbirdの２つを対応させるような場合である．すなわち，同一の書き換え規則部を持つが異なった構造構築部を持つような規則が存在する場合である．図の文法では，(R7),(R8)がこれに対応する．(R7),(R8)は依存森の検証のため導入した恣意的な規則である．同一の書き換え規則に対して複数の部分依存構造を与えるのは，構文構造としては同一であるが依存関係としては異なっているような場合である．想定されるケースとしては，機能的関係の多義と意味的関係の多義が存在する．機能的多義は，文法機能関係(subject,objectなど)への曖昧性である．機能的関係は構文構造と密接な関係にあること，また，機能的関係の違いがある場合には構文構造自体にそれを反映するなどにより異なった構文構造とするなどの文法上の対応も可能であることから，全く同一の書き換え規則に複数の機能的多義構造をアサインすることは必ずしも一般的であるとは考えにくい．これに対して，意味的関係の多義はきわめて一般的な現象であると言える．意味的な関係を構文規則に融合することは，組合せ爆発の問題やメンテナンス性の低下を招く恐れがある．このため，構文解析と意味解析に独立性を持たせたアプローチが広く提唱・利用されている．PDGでも意味的な曖昧性は語彙概念，概念間意味関係を表現する意味依存グラフとして扱うことを想定している．但し，統語森と依存森のマッピングの枠組み自体は，機能的・意味的多義という言語的分類の議論とは独立であり，文法設計に応じて適宜利用すればよい．節の例(図)は，(R7),(R8)により2つの依存構造を生成する構文木を含んでいる．このため，統語森数の構文木の数(8)は，依存森の汎化依存木数(10)より少なくなっている．図に実際の構文木と依存木を示す．#ParseTree[1]s[0,7,is/be]:207+--np[0,2,hobby/n]:108|+--det[0,1,my/det]:101|+--n[1,2,hobby/n]:104+--vp[2,7,is/be]:182+--be[2,3,is/be]:117+--np[3,7,birds/n]:179+--np[3,5,birds/n]:132|+----ving[3,4,watching/ving]:121|+----n[4,5,birds/n]:128+--pp[5,7,with/pre]:176+----pre[5,6,with/pre]:165+----np[6,7,telescope/n]:170+----n[6,7,telescope/n]:168####DependencyStructure[1][is/be,2]+&lt;-(dsc-31)-[birds/n,4]|+&lt;-(adjs-3)-[watching/ving,3]|+&lt;-(npp-23)-[with/pre,5]|+&lt;-(pre-20)-[telescope/n,6]+&lt;-(sub-35)-[hobby/n,1]+&lt;-(det-1)-[my/det,0]####DependencyStructure[2][is/be,2]+&lt;-(dsc-31)-[birds/n,4]|+&lt;-(adjo-4)-[watching/ving,3]|+&lt;-(npp-23)-[with/pre,5]|+&lt;-(pre-20)-[telescope/n,6]+&lt;-(sub-35)-[hobby/n,1]+&lt;-(det-1)-[my/det,0]comment</subsubsection>
  <subsubsection title="複数構文木の１依存木への対応">複数の構文構造が１つの依存構造に対応するような現象の例としては，例えば見せかけの曖昧性が挙げられる．構文構造とそれの表す意味との関係において，構文構造の違いが意味的な違いに対応する真の曖昧性と，構文構造は異なるが意味に違いがない構造，または，文法が不十分なために言語学的に誤った構造などの見せかけの曖昧性が存在し，特にコーパスからの文法学習での対応が重要となっている．また，文脈自由文法ではないが，CCG(ConbinatoryCategorialGrammar)においては，多数のspuriousambiguityが存在するという類似の問題があり，標準形の木のみをただ１つ解析結果として出力する手法が提案されている．この手法では，解析木の末端のカテゴリ(CCGのカテゴリ)が同一である木は同じ意味構造を有するという定義の基で，同じ意味を表す木（同じ意味クラスの木）はただ1つだけ取り出すことができる．PDGの枠組みでは，文の解釈は(汎化)依存木で表現するため，同一の(汎化)依存木を持つ構文木を同じクラスの木とするという関係になっていると見ることができる．図は，``Shecuriouslysawacatintheforest''を例文文法で解析して得られる依存森であり，見せかけの曖昧性を含んでいる．共起制約が掛かっているのは依存先曖昧性に対応するnpp17,vpp18に対する単一役割制約のみであり，``intheforest''の依存先が異なる2つの依存木(解釈)が存在している．統語森は3つの構文木，初期依存森は3つのID付き依存木(2つの汎化依存木)，縮退依存森は2つのID付き依存木(2つの汎化依存木)を含んでいる．見せかけの曖昧性は，動詞句に対する２つの修飾句に関する規則(R17),(R18)の適用順序の違いにより生じている．図に構文木と依存木を示す．======Numberofvarioustrees========[ParseForest](a)ParseForestSize:19(b)Numberofcollectionofparsetrees:3(c)Numberofsetofparsetrees:3[DependencyForest](I-1)InitialDFsize:12(I-2)InitialDFID-treecollectionnumber:3(I-3)InitialDFID-treesetnumber:3(I-4)InitialDFGeneralized-treenumber:2(R-1)ReducedDFsize:9(R-2)ReducedDFID-treecollectionnumber:2(R-3)ReducedDFID-treesetnumber:2(R-4)ReducedDFGeneralized-treenumber:2comment言語解釈の意味的な違いについては，微妙な意味の違いや限量詞や数の解釈に関わる曖昧性なども考慮する必要があり，依存構造の同一性で意味の同一性を判定することはあくまで１つの側面に関する同一性の判定に過ぎない．は，依存構造での自然な構造表現が困難なケースを挙げ，それらには句構造では自然に表現できるもの，句構造でも自然に表現できないもの(句構造，依存構造の両方とも能力不足)があることを示している．PDGは，句構造と依存構造を扱うため，少なくとも前者については枠組みとしての検証が必要と考える．前者は，依存構造において句のヘッドワードに修飾語が存在する場合にそれがヘッドワードのみを修飾するのか，それともヘッドワード以下の全体を修飾するのかというスコープの曖昧性を表現できないという，標準的な依存構造一般に存在する問題（ここでは修飾スコープ問題と呼ぶ）である．図に``EarthandJupiterinSolarSystem''に対する依存森を示す．この文には，前置詞句が並列句のヘッド``Jupitor''のみを修飾する解釈と``EarthandJupitor''全体を修飾する解釈の2つが存在する．統語森には2つの解釈に対応する2つの構文木が存在し，初期依存森には2つのID付き依存木(1つの汎化依存木)が存在し，縮退依存森には1つのID付き依存木(1つの汎化依存木)が存在する．2つの構文木と1つの依存木の対応を図に示す．修飾スコープ問題への対応方法としては，Groupingという概念を導入している．Groupingは論理的にフレーズと同じでカバーする単語の範囲を示すものである．ただし，Groupingは，全てに記述されるものではなく，対象は曖昧性が生じる並列構造(conjoinedstructure)，``not'',``only''と言ったオペレータ語(operatorword)などに限定されている．依存構造をベースにした大規模文法を有する機械翻訳システムでは，Groupingに相当する仕組みを導入している．工学的観点から言うと，一般にどの程度詳細に深いレベルの解釈構造を作るかという設定は，目的とするアプリケーションにより異なる．機械翻訳アプリケーションにおいては，修飾スコープ問題については並列構造に対する対応だけで実システムが構築されており，前記Grouping対象の限定は経験的に妥当であると考えている．また，修飾スコープ問題は，言語によって様相が異なってくる．例えば，ロシア語では形容詞の数，名詞の文法的格が一致(agreement)や支配(government)により統語的に導入され，解釈が決定されるために修飾スコープ問題が起こらないことがある．また，日本語では，係り受け文法(依存構造文法)に被修飾語は修飾語の左に位置するという制約が存在するため，そもそも修飾スコープ問題が発生せず，依存構造(係り受け構造)の表現力の問題として意識されることがほとんどない．PDGでは同値アークがノードのスコープの違いを表現しているので，依存構造の修飾スコープ問題は，Groupingの概念を同値アークに導入するという拡張により対応できる可能性があり，今後の検討課題である．======Numberofvarioustrees========[ParseForest](a)Numberofcollectionofparsetrees:2(b)Numberofsetofparsetrees:2[DependencyForest](I-1)InitialDFsize:7(I-2)InitialDFID-treecollectionnumber:2(I-3)InitialDFID-treesetnumber:2(I-4)InitialDFGeneralized-treenumber:1(R-1)ReducedDFsize:5(R-2)ReducedDFID-treecollectionnumber:1(R-3)ReducedDFID-treesetnumber:1(R-4)ReducedDFGeneralized-treenumber:1------comment依存構造での表現力の問題D-language単独で表現が困難な構造がある．節のヘッドワードを修飾している要素Ｘがある構造と，Ｘが句全体を修飾している構造との意味的な対比．hischeerfulnessandhisaccentastonishing(1a)hischeerfulnessandhisaccentastonishing(1b)hischeerfulnessandhisaccentastonishingこの例は単純にスコープの問題で句構造では，表現されている．(平川)BobandDick'snovels(2a)novelswrittenbytheteam``Bob+Dick''BobandDick'snovels(2b)novelswrittenbyBobandnovelswrittenbyDickBobandDick'snovels→スコープの問題としてこの例は表現されていない要素の問題で単純にスコープの問題として扱うことは困難で，句構造なら表現できるというものでもない．3つの方法(a)ラベルに情報をつける→良くないmodif(ヘッドのみ)v.s.phrase-modif(句全体)(b)(1b)(2b)を省略の問題であるとしてとらえ全体構造で表現(1b')hischeerfulnessastonishingandhisaccentastonishing(2b')Bob'snovelsandDick'snovels(c)ノード属性の属性マーカを付けて弁別(注：次は正確でない．本と違う)ロシア語では，語のinflectionで数の情報が表現され，次の２文の構造が弁別される．NewYork(MASC.SG,NOM)andChicago(MASC.SG.NOM)University[masc](PK.NOM)(ニューヨークとシカゴの各１つの大学）NewYork(PL.NOM)andChicago(PL.NOM)University[masc](PK.NOM)(ニューヨークとシカゴの各いくつかの大学）-----・句構造でも自然に表現できないもの(両方とも能力不足)とできるものがある・表現できるものスコープの曖昧性・MelukではGroupingという概念を導入している(Groupingは論理的にフレーズと等しい)（=スコープノードと同じ)Groupingは，全てに入れているのではなく，限定されている-conjoinedstructure(曖昧性の出る場合)-``operator''word(not,onlyなど)・アプリケーションにも依存する(弁別の必要がないアプリケーションもある)大規模な英語文法では，conjoinedstructureのみにスコープノードで対応するだけで実用上ほぼ問題なく実現できている．・このヘッドワード修飾か全体修飾かというスコープの問題は対象言語によって異なる．ロシア語では形容詞の数，名詞の文法的格がsyntacticallyに導入されている(byagreementandgovernment)日本語では発生しない(係り受け文法の制約の存在）今後の課題．comment</subsubsection>
  <subsection title="Non-projective依存木の生成">非交差制約(Projectivityconstraint)は，多くの依存構造解析システムにより受け入れられている制約であり，これらシステムはProjectiveparserと呼ばれる．Projectiveparserはnon-projectiveな構造を持つ文の解析に失敗する．種々の言語の大半の文はprojectiveであるが，いくつかのタイプのnon-projectiveな文が多くの言語に存在する．英語では，``ShesawthecatcuriouslywhichwasPercian''，日本語では「私は本を東京に買いに昨日行きました」などがnon-projectiveな構造を持つ文である．英語に比べて自由度の高い語順を持つチェコ語の解析において，Non-projectiveparserがprojectiveparserに対して総合的な精度で上回るという報告もある．しかしながら，単純にNon-projectiveな解釈を許すだけでは，全体として性能の劣化に繋がる恐れもあり多くのシステムでは対象をprojectiveな依存木に限定していると思われる．PDGでは，節で述べたように，構成素列(規則ボディ)とアーク集合(部分依存構造)のマッピングが拡張CFG規則で定義される．この記述の枠組みにより，Allornothingではなく，規則により定義されたnon-projectiveな構造のみをWell-formedな構造として共起マトリックスの共起制約として表現することが可能である．これをコントロールされたnon-projectivityと呼ぶこととする．図の(R19)はNon-projectiveな構文に対する文法規則であり，関係節の前に副詞が挿入された構文に対応している．図に``ShesawthecatcuriouslywhichwasPercian''に対して例文文法が生成する依存森を示す．依存森には，non-projectiveな整依存木が１つ存在している．</subsection>
  <section title="おわりに">本稿では，PDGの基本モデルである多レベル圧縮共有データ結合モデルとPDGの概要について述べるとともに，特にPDGにおける圧縮共有データ構造である統語森と依存森について述べた．また，統語森と依存森の間には，完全性と健全性が成立することを示した．圧縮共有された句構造解釈（統語森）を圧縮共有された依存構造（依存森）に対応関係を持って変換でき，それぞれのレベルでの言語知識の適応が可能である点が最大の特徴である．また，自然言語の曖昧性例文に対してPDGの文法と試作システムを用いて解析実験を行い，各種曖昧性が依存森により圧縮共有表現できることを示し，さらに，PDGではNon-projectiveな構造を必要に応じて規則導入できることを示した．現状のPDGの実装は，方式のフィージビリティスタディを想定したものであり，文法記述の拡張(属性条件記述，任意構成素指定の導入など），解析アルゴリズム縮退アルゴリズムの効率化(文法解析による事前最適化，実装上の効率化）などを進める予定である．また，PDGの最適解探索の方式(グラフ分枝アルゴリズム)や評価方式については一部報告しているが，各種選好知識と組み合わせたPDG全体としての評価などについて報告してゆく予定である．</section>
</root>
