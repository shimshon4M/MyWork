<?xml version="1.0" ?>
<root>
  <jtitle>品詞間接続制約のLR構文解析表への組み込みの局所性の解消</jtitle>
  <jauthor>野呂智哉田中穂積橋本泰一白井清昭</jauthor>
  <jabstract>LR構文解析表（LR表）を作成する際，CFG規則による制約だけでなく品詞（終端記号）間の接続制約も同時に組み込むことによって，LR表中の不要な動作（アクション）を削除することができる．それにより，接続制約に違反する解析結果を受理しないLR表を作成できるだけでなく，LR表のサイズを縮小することも可能であり，構文解析の効率の向上が期待できる．これまでにも接続制約の組み込み手法はいくつか提案されているが，従来手法では，注目する動作の前後に実行され得る動作を局所的に考慮するため，削除しきれない動作が存在する．そこで，本論文では新しい組み込み手法を提案する．提案手法では，初期状態から最終状態までの全体の実行すべき動作列（アクションチェイン）を考慮し，接続制約を組み込む．評価実験の結果，従来手法と比較して，不要な動作をさらに約1.2%削減でき，構文解析所要時間は約2.4%短縮できることが分かった．最後に，提案手法の完全性について考察する．</jabstract>
  <jkeywords>一般化LR構文解析，品詞間接続制約，文脈自由文法，局所性解消，アクションチェイン</jkeywords>
  <section title="はじめに">インターネットの普及にともない，多種多様な電子情報が至るところに蓄積され，溢れている．我々は，インターネットを介して，時と場所を選ばず，即座にそれらの情報にアクセスすることができるが，その量は非常に膨大である．「情報爆発」というキーワードのもと，わが国でも文部科学省，経済産業省が新しいプロジェクトを立ち上げ，新技術の開発に取り組み始めている．この膨大な量の情報を人手で処理することは，不可能に近い．情報には文書，画像，音声，動画など様々なものがあるが，自然言語で書かれた文書情報は，その中で最も重要な情報の1つである．文書情報を機械的に処理する技術の研究，言い換えると自然言語処理技術の研究が極めて重要になっているのはそのためである．自然言語処理技術は，2つに大別される．コーパス（統計）ベースの手法とルール（文法規則）ベースの手法である．自然言語処理技術の1つである音声認識の精度のブレイクスルーがあったことにより，最近では，コーパスベースの手法が自然言語処理技術の世界を席巻している．これは網羅性のある文法規則を開発することが困難であったことが主な要因としてあげられる．これに対し，コーパスベースの手法は，そこから得られた統計データに文法規則性が反映されており，コーパスの量を増やすことで，文法規則性をより精密に反映させることができるという考えに基いている．ところが統計データからは陽に文法規則が取り出されるわけではなく，文法規則を取り出し，それをどう改良すべきかは分からない．文法規則は機械（コンピュータ）で扱うことができる規則でなければならない．多種多様な分野の日本語の文書処理を行う文法規則の数は，およそ数千の規模になると言われている．ところがこのような日本語の文法規則を言語学者ですら作成したという話をまだ聞かない．これに対し，コーパスベースの手法による日本語文の文節係り受け解析の精度は90%に達する．これがルールベースの方法が自然言語処理技術の中心ではなくなってきた大きな理由である．ところが，最近，コーパスベースの自然言語処理法も解析精度に飽和現象が見られる．精度をさらに向上させようとすれば，現存するコーパスの量を1桁以上増やさなくてはならないといわれている．これは，音声認識精度の向上でも問題になりはじめているが，コーパスの量を1桁以上増やすことは容易なことではない．この限界を越える技術として，闇雲にコーパスの量を増やすのではなく，ルールベースの方法を再考すべき時期に来ていると考えている．本論文では，一般化LR(GeneralizedLR;GLR)構文解析に注目する．一般化LR構文解析は，文法(CFG)規則をLR構文解析表（LR表）と呼ばれるオートマトンに変換し，効率的に解析を行う．このLR表には，CFG規則のほかに品詞（終端記号）間の接続制約(adjacentsymbolconnectionconstraints;ASCCs)を反映させることもできる．品詞間の接続制約を反映させることにより，接続制約に違反する解析結果を受理しないLR表を作成できるだけでなく，LR表のサイズ（状態数や動作（アクション）数）を縮小することもでき，その結果，構文解析の使用メモリ量や解析所要時間の削減，統計データを取り入れた場合の解析精度向上の効果の増大が期待できる．品詞間接続制約をCFG規則に直接反映させることも可能であるが，非終端記号の細分化によって規則数が組み合わせ的に増大し，CFG作成者への負担やLR表のサイズの増大を招く．品詞間接続制約のLR表への組み込み手法は，これまでにも提案されているが，従来の手法では，LR表中の不要な動作を十分に削除できない問題があった．本論文では新しい組み込み手法を提案し，従来の手法では削除できなかった不要な動作も削除できることを実験により示す．本論文の構成は以下のとおりである．第節では，まず，一般化LR構文解析アルゴリズムを採用しているMSLRパーザについて説明し，従来の品詞間接続制約のLR表への組み込み手法の問題点を述べる．その問題点を踏まえ，第節で新しい組み込み手法を提案し，第節で評価実験を行う．第節では，提案アルゴリズムの完全性について考察を行う．最後に，第節で結論と今後の課題について説明する．</section>
  <section title="MSLRパーザと従来の組み込み手法">本節では，従来のLR表への接続制約の組み込み手法とその問題点を述べるが，その前に，第節の評価実験で使用するMSLRパーザの原理について概略を説明する．</section>
  <subsection title="MSLRパーザの原理">MSLR(Morpho-SyntacticLR)パーザは，GLR構文解析アルゴリズムを拡張し，日本語などの分かち書きされていない文の形態素解析と構文解析を同時に行うことのできるパーザである．図に示すように，MSLRパーザは，文法(CFG)からLR表を生成し，それを参照しながら入力文の解析を行う．LR表を生成する段階では，文法のほかに品詞間接続制約を組み込むことも可能である．品詞間接続制約を組み込むことにより，LR表のサイズを小さくし，解析効率を向上させることができる．また，MSLRパーザは，平文を入力とすることで形態素解析と構文解析を同時に行うことができるが，形態素区切りや品詞，係り受けなどの部分的な制約を入力に加えて解析を行うこともできる．さらに，確率一般化LR(ProbabilisticGeneralizedLR;PGLR)モデルにより，GLRアルゴリズムの枠組みにおいて構文木の生成確率を求めることもできる．MSLRパーザでは，規則（右辺の記号列長が0の規則）を含む文法は扱えない．文法が大規模化するにつれ，文法作成者が予期しない規則の適用や，それによる解析結果の曖昧性の増大が起きるため，MSLRパーザの仕様として，文法に規則は含まれないことを前提としている．本論文でも，規則を含まない文法を前提とする．</subsection>
  <subsection title="接続制約と接続表">終端記号と文末記号の集合t_1,t_2,,t_n,t_n+1(=)の接続制約は，n行n+1列の表（接続表）で表現できる．[connect[t_i,t_j]=1&amp;t_it_jの順で接続可能な場合0&amp;t_it_jの順で接続不可能な場合cases]ただし，1in，1jn+1である．また，終端記号または非終端記号Xの直後に接続可能な終端記号の集合を返す関数Connectを以下のように定義する．[Connect(X)=t|connect[X,t]=1tFollow(X)&amp;Xが終端記号の場合Connect(t)Follow(X)|tLast(X)&amp;Xが非終端記号の場合cases]ただし，Follow(X)とLast(X)は，それぞれCFGの開始記号から展開した場合に非終端記号Xの直後に出現し得る終端記号の集合，Xを展開した場合に末尾に出現し得る終端記号の集合を表す．さらに，終端記号または非終端記号列(=Y)の場合や，終端記号または非終端記号の集合の場合は，関数Connectを以下のように定義する（Yは終端記号または非終端記号）．Connect()&amp;=Connect(Y)Connect()&amp;=_XConnect(X)align*</subsection>
  <subsection title="従来の接続制約組み込み手法">LR表への品詞間接続制約の組み込み手法には，まず接続制約を考慮しないLR表を作成してから不要な動作を削除する手法，LR表作成前と作成後の両方で不要動作を削除する手法などがある．ここでは，MSLRパーザのLR表生成器で採用されている2つ目のLR表作成前と作成後の両方で不要動作を削除する手法（Liの手法）について述べる．LR構文解析では，LRアイテムを利用してCFGから状態遷移図（gotoグラフ）を作成する．Liらは，gotoグラフを作成する段階で，接続制約を利用してアイテムの生成を抑制することにより，接続制約を組み込んだgotoグラフを作成する．さらに，接続制約を組み込んだgotoグラフからLR表を作成した後，接続制約を伝播させることにより，LR表作成前に削除できなかった動作を削除する．接続制約を利用したLR(0)アイテムの生成の抑制は，核アイテム[X]Goto(I,Z)をclosure展開する際，以下の2つの条件を満たすLR(0)アイテムのみを生成することにより行う(I,Z)の場合は，第2条件をtConnect()に置き換える．．Connect(Z)First()&amp;Follow(X)Connect()&amp;align*ただし，Goto(I,Z)は，gotoグラフにおいて状態Iから終端記号または非終端記号Zで遷移した先の状態を表す．また，First()は，を展開した場合に先頭に出現し得る終端記号の集合を表す．接続制約を組み込んだgotoグラフを作成したら，それをもとにLR表を作成する．この時点で既にいくらかの不要な動作は削除されているが，削除できずに残っている動作もあるため，LR表作成後に接続制約を伝播させることにより，さらに不要な動作を削除する．具体的には，LR表中の各動作について，その直前に実行すべき動作が存在しない場合，または直後に実行すべき動作が存在しない場合，その動作を削除する．</subsection>
  <subsection title="従来手法の問題点">図に示すような文法GをGの非終端記号集合に，文末を表す終端記号を終端記号集合に追加し，SSSをGに追加する（Sは元のGの開始記号）．本論文では，新たに追加するCFG規則の番号を常に0番とする．と接続制約C（と文法Gから作成されるgotoグラフ）を例に，従来手法（Liの手法）の問題点を述べる．Liの手法により作成されるLR表を表に示す．ただし，括弧で囲まれた動作は，接続制約により削除されたものである．ここで，状態2，先読みcにおける移動(shift)動作sh_7に注目する．この動作は，Liの手法では削除されない．このshift動作に関連する動作実行列として，以下のような場合が想定される（(2,c,sh_7)は，状態2，先読みcにおけるshift動作sh_7を表す）．[(2,c,sh_7)(7,d,sh_13)(13,d,re_6)(2,Z,goto_5)(5,d,sh_11)]一方，以下のような動作実行列も存在する．[(3,c,sh_7)(7,d,sh_13)(13,e,re_6)(3,Z,goto_9)(9,e,sh_14)]接続制約より，終端記号dは終端記号eと接続するが，終端記号dとは接続しないため，前者の実行列は制約に違反する．その結果，(13,d,re_6)は削除される．しかし，(7,d,sh_13)は，もう一方の接続制約を満たす動作実行列に含まれるため，残される．(2,c,sh_7)は，接続制約を満たすどのような動作実行列にも含まれず，削除すべき動作であるが，次の(7,d,sh_13)が残されるため，Liの手法では削除できない．従来手法では，1つ先または1つ前の動作が存在しないことが判明した場合に，その動作を削除する．この例では，2つ先の動作が存在するか否かを調べなければ，削除可能かどうかを判断できない．これを一般化すると，1つ先や2つ先だけでなく，n個先の動作が存在するか否かを調べる必要があり，連続する動作の存在を局所的に調べるだけでは，接続制約に違反する動作を完全に削除することはできない．このような例でも動作を削除できるようにするためには，その動作実行列が最終的にacc動作に到達可能であるか否かを調べる必要がある．</subsection>
  <section title="提案アルゴリズム">初期状態から実行すべき動作を順番に決めていくと，動作の実行列（アクションチェイン）ができる．このアクションチェインがacc動作に到達すれば，解析が成功することになる．一方，実行すべき動作がLR表から決まらないときには，解析が失敗することになる．このアクションチェインは有向グラフ（アクションチェイングラフ）として表現できる．初期状態からacc動作に至るアクションチェインを成功パスと呼ぶ．成功パス上の動作は，必要な動作としてLR表に残す．提案アルゴリズムでは，アクションチェインを最終状態（acc動作）から逆向きに横型探索によりたどることにより，成功パスを探索する．すなわち開始記号を左辺に持つCFG規則について，その右辺の末尾の記号から順番に展開しながら（最右導出を行いながら）接続制約を満たすか否かをチェックする．開始記号Sを左辺に持つSX_1X_2X_nというCFG規則（規則番号をmとする）があったとする．gotoグラフには図(a)に示すような状態とリンクが存在する（開始状態を0とする）．このCFG規則の展開に対応するLR表中の動作は，状態s_n，先読みにおけるreduce動作_mとその後の状態0，非終端記号Sにおける状態s_0への遷移であり，この動作をアクションチェインに追加する．そして，右辺の各終端記号または非終端記号について，X_n，X_n-1，…X_1の順に接続制約を満たすか否かをチェックする．X_nが終端記号の場合，X_nとの間の接続制約をチェックする．接続制約を満たすならば，状態s_n-1，先読みX_nにおけるshift動作_s_nをアクションチェインに追加し，X_n-1のチェックに移る（先読みはX_nとなる）．X_nが非終端記号の場合は，X_nを左辺とするCFG規則で展開する．このCFG規則がX_nY_1Y_2Y_n^（規則番号m^）であるとすると，gotoグラフ中では図(b)に示すような状態とリンクが存在する．このCFG規則の展開に対応する，状態s^_n^，先読みにおけるreduce動作_m^と状態s_n-1，記号X_nにおける状態s_nへの遷移をアクションチェインに追加し，Y_n^，Y_n^-1，…Y_1の順に接続制約を満たすか否かを同様にチェックする．すべてのチェックが完了したら，X_n-1のチェックに移る（先読みはY_1のチェックで最後にアクションチェインに追加したshift動作の先読みとなる）．以下，同様に続け，最終的に状態0におけるshift動作がアクションチェインに追加されたら，それが成功パスとなる．提案アルゴリズムの概要を図に示す．図中の記法については，以下のとおりである．図の（2）では，wait状態のreduce動作要素について，その状態をcheckとして，対象となる動作の実行後に解析開始状態まで接続制約に違反することなく到達可能かどうかのチェックを行う．wait状態のshift動作要素ならば，その状態をcheckとして，それに先行するinit状態の要素について，その状態をwaitとする．ただし，先行する要素がshift動作要素の場合は，両者の先読み記号の間の接続制約をチェックする．また，gotoグラフにおける状態0でのshift動作要素の場合は，解析開始状態まで到達可能であることが判明したので，要素の状態をpassとする．図の（4）では，pass状態の要素について，その状態をendとし，そこから（2）のときとは逆に要素をたどり，check状態の要素が解析開始状態まで到達可能であることを伝えていく（状態をcheckからpassにする）．最終的に状態がendとなった要素の列が成功パスとなる．図に示す文法Gと接続制約Cに対し，上述のアルゴリズムを適用すると，以下のような手順で処理が進行する．[0,re_0,,]を作成．[0,re_0,,]について，処理状態をcheckに変更し，[0,re_1,,]，[0,re_2,,]を作成．[0,re_1,,]について，処理状態をcheckに変更し，[0,sh,a,]，[2,re_3,e,]，[4,sh,e,]を作成．[0,re_2,,]について，処理状態をcheckに変更し，[0,sh,b,]，[3,re_4,,]を作成（図（1））．[4,sh,e,]について，処理状態をcheckに変更し，[2,re_3,a,]の処理状態をwaitに変更．[3,re_4,e,]について，処理状態をcheckに変更し，[3,re_5,e,]，[3,re_6,e,]，[9,sh,e,]を作成．[2,re_3,e,]について，処理状態をcheckに変更し，[2,re_5,d,]，[2,re_6,d,]，[5,sh,d,]を作成（図（2））．[5,sh,d,]について，処理状態をcheckに変更し，[2,re_5,d,]，[2,re_6,d,]の処理状態をwaitに変更．[9,sh,e,]について，処理状態をcheckに変更し，[3,re_5,e,]，[3,re_6,e,]の処理状態をwaitに変更．[2,re_5,d,]について，処理状態をcheckに変更し，[2,sh,b,]，[6,sh,c,]を作成．[2,re_6,d,]について，処理状態をcheckに変更し，[2,sh,c,]を作成（[6,sh,d,]は，connect(d,d)=0より作成しない）．[3,re_5,e,]について，処理状態をcheckに変更し，[3,sh,b,]を作成（[7,sh,c,]は，connect(c,e)=0より作成しない）．[3,re_6,e,]について，処理状態をcheckに変更し，[3,sh,c,]，[7,sh,d,]を作成．[6,sh,c,]について，処理状態をcheckに変更し，[2,sh,b,]の処理状態をwaitに変更．[7,sh,d,]について，処理状態をcheckに変更し，[3,sh,c,]の処理状態をwaitに変更．[2,sh,b,]について，処理状態をcheckに変更し，[0,sh,a,]の処理状態をwaitに変更．[3,sh,c,]について，処理状態をcheckに変更し，[0,sh,b,]の処理状態をwaitに変更．[0,sh,a,]について，処理状態をpassに変更．[0,sh,b,]について，処理状態をpassに変更（図（3））．[0,sh,a,]について，処理状態をendに変更し，[2,sh,b,]の処理状態をpassに変更．[0,sh,b,]について，処理状態をendに変更し，[3,sh,c,]の処理状態をpassに変更．[2,sh,b,]について，処理状態をendに変更し，[6,sh,c,]の処理状態をpassに変更．[3,sh,c,]について，処理状態をendに変更し，[7,sh,d,]の処理状態をpassに変更．以下，同様に処理を続け，処理状態がpassの要素がなくなったら終了（図（4））．アルゴリズムを適用後，処理状態がendである動作要素をたどることにより，成功パスを抽出できる（図（4）の実線のリンクが成功パスである）．作成されるLR表を表に示す．また，表において，括弧で囲まれた動作は，Liの手法で削除できず，提案手法により削除されたものを表す．</section>
  <section title="実験と評価">提案手法の効果を調べるため，従来手法との比較実験を行った．コーパスは東工大コーパス20,190文（1文あたり約23形態素）を利用する．20,190文すべてから抽出した文法G_を使用し，MSLRパーザで構文解析を行う．入力は平文とする．解析結果の順位付けはPGLRモデルにより行う．比較は，提案手法により生成されるLR表と，Liの手法により生成されるLR表，接続制約を組み込まないLR表の3つで行う．抽出したCFG規則数は2,722規則（非終端記号294個，終端記号412個）である．各手法により生成されたLR表中の状態数と動作数を表に示す．状態数において，「shift後」，「reduce後」とは，それぞれshift/reduceを実行した直後に到達する状態を指す．PGLRモデルによる確率計算ではこの2種類の状態を区別する必要があるため，参考として内訳を示している．また，動作数において，丸括弧，角括弧で囲まれた数字は，それぞれ，コンフリクトが生じる動作の数，PGLRモデルによる確率が1ではない動作の数を表す．前者は解析途中での曖昧性の大小の目安に，後者はPGLRモデルによる確率計算の影響の大小（パラメータ数の大小）の目安になる．この表より，状態数にはそれほど大きな差は生じないが，総動作数については，接続制約を組み込まない場合と比較して約64%削減できていることが分かる．コンフリクトが生じる動作数，PGLRモデルによる確率が1にならない動作数は，それぞれ約56%，71%削減できている．一方，Liの手法と比較すると，総動作数では約1.2%，コンフリクトが生じる動作数とPGLRモデルによる確率が1ではない動作数はどちらも約1.4%削減できている．次に，全20,190文を構文解析する際の所要時間（ユーザCPU時間）を計測した．結果を表に示す．ただし，計測はDual-CoreIntelXeon3~GHz，メモリ4~GBの環境で行った．結果より，接続制約を組み込まない場合と比較して約52%，Liの手法と比較して約2.4%短縮された．接続制約を組み込まない場合，接続制約を満たさない構文木も解析結果として出力される．速度向上の要因は，接続制約を組み込んだことによる曖昧性の減少にあると考えられる．一方，Liの手法では，接続制約が組み込まれているため，最終的に出力される解析結果は提案手法の場合と同じである．しかし，不要な動作が残っているため，解析途中での無駄な曖昧性（最終的にaccに到達できない解析途中状態）が多く存在する．例えば，第節で示した動作実行列の場合，提案手法では，状態2，先読み記号cにおける動作がLR表中に存在しないことが分かった時点で解析を終了するが，Liの手法では，状態13，先読み記号dとなるまで解析が継続する．提案手法とLiの手法の解析所要時間の差は，ここで生じる．最後に，PGLRモデルによる順位付けの評価を10分割交差検定により行った．すなわち，全体の10分の9にあたる18,171文を利用してモデルの学習を行い，残りの2,019文で評価を行った（文法はG_を使用した）．解析精度は，文正解率により比較した．文正解率は以下のように定義する．[=]ここで「正解」とは，出力された解析木が正解とすべき構文木と完全に一致する場合を指す．結果を表に示す．提案手法では，PGLRモデルによる順位が1位の解析木のみを見た場合，接続制約を組み込まない場合と比較して0.74%向上している．一方，Liの手法と比較すると，1位の解析木のみでは0.16%向上しているが，上位10位までを見るとほとんど差がなく，LR表中の不要動作の削除が解析精度に与える影響は大きくないことが分かる．解析所要時間の差と同様，解析精度の差についても，提案手法と接続制約を組み込まない場合との間では，最終的に出力される解析木の数の違いが要因と考えられる．一方，Liの手法によるLR表での最終的な解析結果の曖昧性は提案手法の場合と同じである．また，提案手法でのみ削除可能な動作は，どのような動作実行列をたどっても，最終的にaccに到達することのないものであるため，学習データ中にも存在しない．PGLRモデルによるLR表中の各動作の確率は，学習データに付与された構文木を生成する際に実行する動作の使用回数をもとに計算されるが，最終的にaccに到達できない動作に対する確率は0となり，最終的に出力される各解析木の確率は提案手法の場合と同じになるはずである．しかし，MSLRパーザでは，確率計算の平滑化のため，全ての動作の実行回数に一定数（初期設定では0.5）を加えている．その結果，学習データ中で使用されない動作についても0ではない確率が与えられ，最終的に出力される各解析木の確率が提案手法の場合とLiの手法の場合との間で異なる場合があり，それが，解析精度に差が生じる要因になる．平滑化を行わなければ同じ結果になるが，その場合，accに到達可能であり，かつ，妥当な動作であるにもかかわらず学習データに偶然出現しなかった動作に対する確率も0となる．確率が0である動作が，接続制約を組み込んだことによってaccに到達不可能となった動作であるか，偶然学習データに出現しなかった動作であるかを，学習の段階で区別することは困難である．LR表を作成する段階でaccに到達不可能な動作を削除しておけば，この問題を回避することが可能であり，その点においても提案手法が有効であることが分かる．</section>
  <section title="提案アルゴリズムの完全性の証明">本節では，提案アルゴリズムの完全性について考察する．ここで，完全性とは，作成されるLR表に不要なアクションが存在しないことである．これを示すためには，LR表が以下の2つの性質を満たすことを示せばよい．妥当性任意の構文木trに対し，以下が成り立つ．[Generate(tr,G,C)=GenerateLR(tr,T)]ただし，最小性妥当性を満たすLR表中の任意の要素（動作）aに対し，以下が成り立つような構文木trが存在する．[GenerateLR(tr,T)=1GenerateLR(tr,T_a)=0]ただし，文法Gは，第節で述べた，規則を含まないという条件のほかに，以下の条件を満たすことを前提とする．文法規則は重複しない．すなわち，文法G中の任意の2つの文法規則A，Bについて，AB循環する導出は存在しない．すなわち，文法G中の任意の非終端記号Aについて，AAとなるような導出は存在しない</section>
  <subsection title="妥当性の証明">提案アルゴリズムによって作成されるLR表が妥当性を満たすことを示すためには，以下の2つを示せばよい．Generate(tr,G,C)=1ならばGenerateLR(tr,Table(ACG))=1GenerateLR(tr,Table(ACG))=1ならばGenerate(tr,G,C)=1ただし，提案アルゴリズムでは，開始記号から最右導出を行いながらアクションチェイングラフを生成し，その中に含まれる成功パスからLR表を生成する．ここで，Generate(tr,G,C)=1を満たす構文木trに相当する最右導出の際に，提案アルゴリズムによって生成されるアクションチェインは，成功パスである．この成功パス中の要素に対応する動作は，このアクションチェイングラフから生成されるLR表に含まれるので，trはTable(ACG)から生成可能である．すなわち，（1）が成り立つ．一方，ある構文木trがGenerateLR(tr,Table(ACG))=1を満たすと仮定する．このとき，Table(ACG)からtrを生成する際の実行動作列について，先頭の実行動作から順に，以下の法則に従ってACG中のアクションチェイン要素をたどることにより，成功パスを得ることができる．注目する実行動作がacc動作の場合，[0,re_0,,end]をたどる．注目する実行動作が状態s，先読みlaにおけるshift動作の場合，[s,sh,la,end]をたどる．注目する実行動作が状態s，先読みlaにおける規則番号nによるreduce動作，さらにその次の動作が状態s^，非終端記号LHS(n)における状態s^へのgoto動作の場合，[s^,re_n,la,end]をたどる．ACG中の成功パスに対応する構文木は文法G，接続制約Cを満たすので，（2）が成り立つ．以上より，提案アルゴリズムによって作成されるLR表は妥当性を満たす．</subsection>
  <subsection title="最小性の証明">T=Table(ACG)が最小性を満たさないと仮定すると，次を満たす要素aがT中に少なくとも1つ存在する．任意のtrtr|GenerateLR(tr,T)=1に対して，GenerateLR(tr,T_a)=1quotationこのとき，tr|GenerateLR(tr,T)=1tr|GenerateLR(tr,T_a)=1となり，aに対応するACG中の要素をeとすると，tr|GenerateLR(tr,T_a)=1中の任意の構文木を生成する際の実行動作列に対応するACG中の成功パスは，eを含まない．一方，T中にaが存在することから，ACG中にはeを含む成功パスが存在する．その成功パスに対応する実行動作列はaを含み，その実行動作列で生成される構文木をtr^とすると，以下が成り立つ．[GenerateLR(tr^,T)=1GenerateLR(tr^,T_a)=0]これはTが最小性を満たさないという仮定に矛盾する．以上より，提案アルゴリズムによって作成されるLR表は最小性を満たす．</subsection>
  <section title="結論と今後の課題">コーパスベースの自然言語処理技術は，音声認識などにおいて，精度向上のブレイクスルーを持たらした．これは，コーパスの量を増やすことによって精度が向上したからであるが，それには限界が見えはじめている．この限界を越える技術として，コーパスの量を増やすのではなく，ルールベースの手法を再考すべき時期に来ていると考えている．本論文では，ルールベースの構文解析の1つである一般化LR構文解析に注目し，品詞間接続制約をLR表に組み込み，不要な動作を削除する手法を提案した．提案手法により，接続制約による削除を行わない場合と比較して約64%の不要動作を削除でき，従来手法と比較するとさらに約1.2%の不要動作を削減できた．提案手法により作成したLR表で構文解析を行った場合，解析所要時間は，接続制約を組み込まないLR表で構文解析を行った場合と比較して約52%，従来手法と比較して約2.4%短縮された．解析精度（文正解率）は，接続制約を組み込まない場合と比較すると向上が見られたが，従来手法と比較すると大きな差は見られなかった．しかし，PGLRモデルによる確率計算の平滑化における問題を回避するためにも，不要な動作を削除することは有効であり，今後，コーパスベースの手法を取り入れた場合の精度向上の効果が大きくなると考えている．実験で示した解析精度（文正解率）はコーパスベースの解析と比較すると低いと思われるかもしれない．しかし，MSLRパーザは品詞間の接続制約とCFGのみを利用して構文解析を行う．この結果に共起データ等の情報を加えれば，コーパスベースの解析と同程度の正解率が得られるものと期待される．筆者らはルールベースの自然言語処理にはまだ検討の余地があると考えている．document</section>
</root>
