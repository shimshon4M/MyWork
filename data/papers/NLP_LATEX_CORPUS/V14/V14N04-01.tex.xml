<?xml version="1.0" ?>
<root>
  <jtitle>関係データベースを用いた構文木付きコーパス検索手法</jtitle>
  <jauthor>橋本泰一吉田恭介野口正樹徳永健伸田中穂積</jauthor>
  <jabstract>本論文では，構文木をクエリとして与え，構文木付きコーパスからクエリと同じ構文木を部分木として含む文を検索する手法を提案する．構文木付きコーパスは，関係データベースに格納する．このような構造検索の過去の研究では，クエリの節点数が増加すると，検索時間が大幅に増加する問題があった．本論文で提案する手法は，節点数が多いクエリを部分木に分割し，漸進的に検索することで検索を効率化する．クエリの分割の単位やその検索順序は，検索対象となるコーパス中の規則の出現頻度をもとに自動的に決定する．本手法の有効性を確認するために7種類のコーパスを用いて評価実験を行ったところ，4種類のコーパスで分割の有効性が確認できた．</jabstract>
  <jkeywords>構文木付きコーパス，情報検索，コーパス作成支援ツール，関係データベース</jkeywords>
  <section title="はじめに">近年，自然言語処理の分野では，大規模な言語資源を利用した統計的手法が研究の中心となっている．特に，構文木付きコーパスは，統計的手法に基づく言語処理の高性能化のためだけでなく，言語学や言語処理研究の基本データとしても貴重な資源である．そのため，大規模な構文木付きコーパスの作成が必要となっている．しかし，大規模な構文木付きコーパスを全て人手により作成することは，多大なコストを必要とするため困難である．一方，現在の構文解析の精度では，構文木の付与を完全に自動化することが難しい．現実的には，構文解析器の出力から人手によって正しい構文木を選択し，それを文に付与することが望ましい．コーパス作成中には，文法や品詞体系の変更など，コーパス作成方針の変更により，コーパスへの修正が必要になることもあり，継続的な修正作業や不整合の除去などの機能を持った構文木付きコーパスの作成を支援するシステムが必要になる．このようなシステムの多くは，GUIツールを用いて，構文木付けをするコーパスのファイル形式や品詞ラベルの不整合を防ぐことにより，コーパス作成者を支援するのが主な機能である．しかし，それだけでは，正しい構文木付きコーパスの作成には，不十分であり，構文木の一貫性を保つための支援が必要となる．構文木の一貫性を保つための支援として，過去の事例を参照することは有効である．複数の構文木候補のうち，正しい木の選択を迷った場合に，すでに構文木を付与されたコーパス中から，作業中の構文木と類似した部分を持つ構文木を参照できれば，正しい構文木付けが容易になり，一貫性を保つための支援ができる．このためには，構文木付きコーパスを検索対象とし，木構造の検索が可能な構文木付きコーパス検索システムが必要となる．構文木付きコーパス検索システムは，木構造検索を行うことになるため，UNIXの文字列検索コマンドgrepなどの文字列検索よりも検索に時間を要することが多い．既存の構文木付きコーパス検索システムにおいても，主な課題として，検索時間の高速化が挙げられているが，検索時間を高速化する優れた手法はまだ提案されていない．今後，コーパスの規模が更に大きくなると，検索時間の高速化は不可欠な技術となる．本論文では，高速な構文木付きコーパス検索手法を提案する．本論文で提案する検索手法は，構文木付きコーパスを関係データベースに格納し，検索にはSQLを用いる．部分木を検索のクエリとして与え，クエリと同じ構造を含む構文木を検索結果として出力する．クエリの節点数が多い場合，クエリを分割し，それぞれのクエリを別のSQL文で漸進的に検索する．クエリを分割すべきかどうか，分割するクエリの大きさや検索順序は，構文木付きコーパス中の規則の出現頻度を用いて自動的に決定する．6言語，7種類のコーパスを用いて評価実験を行い，4種類のコーパスにおいて，漸進的に検索を行う本手法により検索時間が短縮され，本手法の有効性を確認した．また，残りの3種類のコーパスにおいては，漸進的に検索を行わなくても多大な検索時間を要しないことを本手法で判定することができた．そして，クエリの分割が検索時間の短縮に効果があった4種類のコーパスと分割の効果がなかった3種類のコーパスの違いについて，コーパスに含まれる文数，ラベルの頻度，節点の平均分岐数の観点から考察を行い，節点の平均分岐数がその一因であることを確認した．</section>
  <section title="構文木付きコーパスのデータベース化">構文木をデータベース化する手法として，XML文書を関係データベースを用いてデータベース化する吉川らの手法を適用した．吉川らの手法は，クエリとしてXPathを用い，XML文書を関係データベースに格納する．XPathとは，W3Cにより勧告されたXML文書中の特定の構文を表現する記述方法である．XML文書を検索する場合，クエリであるXPathをSQL文に変換し，クエリを含むXML文書を検索する．吉川らの手法の大きな特徴は，検索が高速である点である．その理由は，XML文書の木構造の各節点を出現位置という2つの数字で表現し，その大小関係により，節点の親子関係や兄弟関係を表現する点にある．本手法では，構文木の構造をXML文書の構文構造に対応させ，データベース化を行った．</section>
  <subsection title="出現位置">構文木をデータベースに格納するにあたり，構文木中の各節点対して，出現位置と呼ばれる節点間の関係を計算するための2つの数字を与える．出現位置は，(left_position，right_position)の対で表現され，次のアルゴリズムにより決定する．葉左端からN番目の葉に対する出現位置は，(N,N)という整数値の対を与える．葉以外の節点変数positionを1以下の微小値で初期化する．根から深さ優先探索で辿り，節点を辿るときにをpositionに加算し，葉を辿るきに葉のleft_positionまたはright_positionの値を代入する．節点を最初に通過するとき変数positionの値をleft_positionとして，最後に通過するときにright_positionとして決定する．ただし，は，木の最大の深さの逆数よりも小さい値でなければならない．このアルゴリズムで決定した出現位置の例をに示す．また，このように各節点に出現位置を与えることで，のように節点間の関係を出現位置の大小関係で表現することができる．</subsection>
  <subsection title="関係データベースへの格納">前節で計算した出現位置とともに各節点の情報を関係データベースに格納する．データベースは，NodeTable，DocumentTable，LabelTableの3つのテーブルにより構成される．テーブルの例をそれぞれ表，，に示す．NodeTableは，構文木を構成する各節点に関する情報を格納する．各項目は，IDが節点固有の値，parentIDが節点の親のID，docIDが節点を含む構文木のID，labelIDが節点のラベルのID，nextSibIDが節点の右隣の兄弟のID，l_pos,r_posが節点の出現位置を表す．DocumentTableは，構文木が記述されているファイルに関する情報を格納する．各項目は，docIDが構文木固有の値，fileが構文木が記述されているファイル名を表す．LabelTableは，コーパスに含まれる記号，単語に関する情報を格納する．各項目は，labelIDがラベル固有の値，labelがラベル名，frequencyがコーパスにおけるラベルの頻度を表す．</subsection>
  <section title="構文木付きコーパスの検索手法"/>
  <subsection title="クエリの定義">前節では，構文木付きコーパスを関係データベースに格納する方法について述べた．本手法では，木構造をクエリとし，クエリを部分木として含む文を検索する．まず，クエリの例をに示す．図中の``''は，任意のラベルを意味する．さらに，クエリを部分木として含むかどうかの判定方法として，完全一致と部分一致の二種類を用意した．完全一致は，クエリの各節点の分岐数とコーパス内の対応する節点の分岐数が一致しなければならない．一方，部分一致は，この分岐数が必ずしも一致する必要がない．例えば，において，完全一致で検索した場合，(a)の木は，各節点の分岐数，ラベルが一致するためにクエリと一致すると見なす．一方，(b)の木は，分岐数が異なるため，クエリと一致すると見なさない．しかし，部分一致で検索した場合，節点の分岐数は一致する必要がないため，両方の木がクエリと一致すると見なす．</subsection>
  <subsection title="構文木をクエリとした検索手法">本手法は，吉川らの手法と同様に検索を行うためにクエリである部分木を関係データベースのデータの操作，定義，検索などを行う言語SQLの文へ変換する．そして，変換したSQL文により該当した構文木をデータベース内から検索し，クエリを部分木として含む構文木を得る．クエリとそのクエリに対応するSQL文をに示す．中のSQL文のwhere構文以降が各節点の条件式となっている．システムは，条件を満たす節点をデータベース内を検索し，すべての条件を満たす節点をもつ構文木を出力する．</subsection>
  <subsection title="予備実験">吉川らは，シュークスピアの戯曲をJonBosakがタグ付けしたXML文書を用いた評価実験により，検索手法が高速であることを示した．そこで，吉川の手法を構文木付きコーパスに適用し，予備実験を行った．検索対象のコーパスとして，PennTreebankCorpus（48,884文）を用いた．クエリは，PennTreebankCorpusからランダムに4文を抽出した．そして，4文から節点数が2から20の抽出可能なすべての部分木をクエリとして，部分一致により検索を行った．その結果を，に示す．実験結果より，クエリの節点数が7から12の間は，高速に検索を行っているが，節点数が7以下，12以上の場合，検索時間が非常に増加している．クエリの節点数が7以下の場合，クエリに一致する文が非常に多いために検索に時間を要とすると考えられる．一方，クエリの節点数が12以上の場合は，クエリと一致する文かどうかの判定，つまりSQL文の条件判定に検索時間を要していると考えられる．検索条件が多ければ，条件判定を行う処理が多くなり検索に時間を要する．吉川らが評価実験を行ったXML文書は，DTD(DocumentTypeDefinition)により，節点のラベルや構造があらかじめ定義されている．構文木付きコーパスにおいては，文脈自由文法がDTDに相当する．XML文書は，少ないDTDの規則で簡潔な構造を定義している場合が多く，文書間での大きな構造の違いは少ない．そのため，SQL文の条件は多くなりにくい．一方，構文木付きコーパスは，数千の規則を用いて文法を定義し，文によって様々な木構造が付与されている．そのため，XML文書よりもSQL文の条件が多くなる可能性が高く，検索時間が増加するケースが多くなることが予想できる．関係データベースの検索速度は，関係データベースシステムの種類，格納するデータ，検索に要するSQL文に依存する．関係データベースを構築する際，技術者が格納するデータをみて関係データベースシステムを選んだり，生成するSQL文の条件部分の優先度などの調整を経験的に行い，検索の効率化をはかることが多い．クエリの節点数が多くなると変換したSQL文の条件部分が多くなり，条件を満たすデータの検出時間がかかる．そのため，検索時間が大幅にかかるようになる．このような場合，人手により条件の記述順序の変更などにより，チューニングを行う．しかし，構文付きコーパスは，言語や対象文書の違いなど様々なコーパスが存在する．コーパスそれぞれを人手でチューニングすることは困難である．そのため，自動的に検索速度をチューニングする手法が必要である．</subsection>
  <subsection title="漸進的検索">予備実験の結果から，クエリの節点数が7から12の間は，高速に検索が可能であることがわかった．例えば，節点数16のクエリの平均検索時間は，0.56秒である．それに対して，節点数8のクエリの平均時間は，0.09秒である．もし，節点数16のクエリを節点数8のクエリ2つに分割し検索できれば，検索を高速化することが可能である．本手法では，クエリをSQL一文で検索するのではなく，複数のSQL文に分割し，SQL一文に要する検索時間を短くすることで高速化を行う．また，単一のSQL文により効率よく絞り込みが行うことができるように，コーパス内のラベルの頻度をもとにクエリの分割方法を決定する．</subsection>
  <subsubsection title="検索単位">クエリの節点数が多い場合には，クエリを複数のクエリに分割し，漸進的に検索を行う手法を提案する．本論文では，分割されたクエリを検索単位，効率的に検索可能なクエリの節点数の最大値を最大検索単位節点数と定義する．コーパスが与えられたとき，コーパスから最大検索単位節点数を計算し，ノード数が多いクエリは最大検索単位節点数をもとに分割して，漸進的に検索を行う．まず，コーパスから，節点数2から31のクエリ（部分木）各50個をランダムに抽出する．そして，各節点数ごとに平均検索時間を算出する．そのデータから，以下の2つの条件を満たす最大値iを最大検索単位ノード数とする．節点数i-n+1からiの間のクエリの平均検索時間がt以下節点数i+1からi+nの間のクエリの平均検索時間がt以上nとtは，最大検索単位節点数を決定する際のパラメータである．nは，正の整数，tは，秒数である．例えば，nを3，tを0.5（秒）をした場合，の予備実験結果では，節点数13，14，15において平均検索時間がtを下回り，節点数16，17，18において平均検索時間がtを上回っている．このとき，最大検索単位節点数は，15となる．</subsubsection>
  <subsubsection title="クエリの分割">前節で，コーパスに最適化された検索単位の節点数を決定する手法について述べた．しかし，クエリの分割方法，分割されたクエリの検索順序によって，検索時間は大きく変わる．もし，最初に検索する検索単位の出力数が少なければ，次に絞り込む検索範囲が狭まり，検索を効率よく行うことができる．つまり，絞り込みが早く行われるように分割や順序を決定することが望ましい．コーパス中の節点や文脈自由規則の頻度をもとにクエリの検索単位への分割，検索単位の検索順序を決定する．クエリの分割アルゴリズムを以下に示す．検索単位の検索順序は，分割された順である．Step9=1=Step1クエリに含まれる節点のラベルのコーパス内での出現頻度を計算する．=1=Step2クエリ内の最小頻度の節点を検索単位U_0とする．=1=Step3i=1=1=Step3検索単位U_i-1に含まれる節点に近接する最小頻度のラベルの節点で初期化する．=1=Step4検索単位U_iに含まれる節点を持ち，検索単位U_iに加えても最大検索単位節点数を越えない部分木があれば，根の頻度が最小である部分木の節点を検索単位U_iへ追加する．=1=Step5もし，Step4において，部分木を加えられたのであれば，Step4へ．そうでなければ，Step6へ．=1=Step6i=i+1．クエリをすべて分割したならば，Step7へ．そうでなければ，Step3へ．=1=Step7各検索単位をSQL文へ変換．クエリ分割方法を例を用いて説明する．クエリとして，の(1)が与えられ，最大検索単位節点数が5であると仮定する．まず，クエリに含まれる節点のラベルの出現頻度を計算する．その中で，最も出現頻度が低い``join''（出現頻度50）を検索単位U_0に加える．次に，節点(``join'')を含む部分木の中で，最も出現頻度が低い``VP''を根とする部分木（出現頻度179,161）の節点を加えることを考える．しかし，この部分木の節点を加えると最大検索単位節点数を越えるためU_0には加えない．（の(2)）次に，新たな検索単位U_1をU_0に含まれる節点と隣接する節点のうち最小頻度である節点(``VP'')初期化する．そして，``VP''を含む部分木をU_1に加えることを考える．``VP''を根とする部分木の節点を加えた場合，U_1の節点は，``VP'',``NP'',``PP-CLR'',``NP-TMP''の4つとなり，最大検索単位節点数を越えない．そのため，これらの節点をU_1に追加する．さらに，U_1に``VP''を根とする部分木の節点を加えることを試みるが最大検索単位節点数を越えるために加えられない．（の(3)）そして，新たな検索単位U_2を構築を始める．最終的に，の(4)のように，クエリは3つの検索単位U_0，U_1,U_2に分割される．そして，それぞれの検索単位をSQL文へ変換し，検索を行う．そして，最初に決定した検索単位U_0により検索を行い，その結果に対して検索単位U_1により絞り込みを行う．絞り込みは，検索単位の初期化に利用した隣接する節点を次の検索単位のSQL文内の条件式として追加する．つまり，直前に利用したSQL文で次の検索単位に隣接する節点のIDを獲得し，その条件を次の検索単位のSQL文の条件として加える．例では，U_1に対応するSQL文の節点``n4''に関する条件式，U_2に対応するSQL文の節点``n3''に関する条件式が追加される条件式である．（の(5)）</subsubsection>
  <section title="評価実験">クエリ分割による検索の有効性を確認するために，7つの構文木付きコーパスを用いて，評価実験を行った．評価実験に使用したコーパスは，PennTreebankCorpus，TIGERCorpus，PennKoreanTreebank，FLORESTAsint'a(c)tica，PennChineseTreebank，東工大コーパス(RWC)，東工大コーパス(EDR)である．各コーパスの諸元をに示す．評価実験では，最大検索単位節点数を決定するパラメータtを0.5（秒），nを3とし，最大検索単位節点数を計算した．クエリは，コーパスからランダムに抽出した部分木を用い，節点数1から31までの各50個を用いた．検索方法としては，完全一致と部分一致の2種類を行った．各コーパスにおける評価実験結果をからに示す．PennTreebankCorpus，TIGERCorpus，PennKoreanTreebankCorpus，FLORESTsint'a(c)ticaの4つコーパスにおいては，完全一致による検索では節点数16以上，部分一致による検索では節点数11から13以上のクエリに対して，クエリの分割を行わずに検索を行った場合，急激に検索時間が増大することがわかる．一方，クエリを検索単位に分割することで高速に検索が行うことができた．また，対照的にPennChineseTreebankCorpus，東工大コーパス(RWC),東工大コーパス(EDR)では，完全一致と部分一致ともに許容検索時間を越えることがなく，最大検索単位節点数は最大の31と計算された．これら3つのコーパスにおいては，クエリの分割を行う必要がなかった．</section>
  <section title="考察">評価実験で用いたコーパスは，大きく分けて2つに分類できる．1つは，分割せずに検索した場合，クエリを構成する節点数が増えると検索時間が非常に遅くなるものである．このタイプのコーパスは，PennTreebankCorpus，TIGERCorpus，PennKoreanTreebankCorpus，FLORESTsint'a(c)ticaが当てはまる．もう1つは，クエリの節点数が増えても検索時間に影響を与えないものである．このタイプのコーパスとして，PennChineseTreebankCorpus，東工大コーパス(RWC),東工大コーパス(EDR)が当てはまる．このような違いが，コーパスのどの特徴と関連しているのか，コーパスの以下の特徴に着目し考察した．コーパスの文数ラベルの頻度節点の平均分岐数</section>
  <subsection title="コーパスの文数">コーパスの文数が検索時間に影響を与えることが考えられる．つまり，文数が多ければ検索に時間がかかり，少なければ時間がかからないはずである．しかし，からわかるようにPennKoreanTreebankCorpus（5,083文），FLORESTsint'a(c)tica（8,307文）は，比較的コーパスに含まれる文数が少ないが，クエリの節点数が増加するとともに検索時間が大幅に増加している．また，PennChineseTreebank（15,168文）は文数が多いにも関わらず，節点数が増加しても検索時間は増加していない．さらにPennTreebankCorpusの文数を1,000文，5,000文，11,976文，48,884文と変化させ，検索時間の変化を調べた．クエリなどの実験環境は，評価実験で用いたものと同じである．その結果をに示す．この結果からコーパスに含まれる文数が減少しても，節点数が増加するとともに検索時間が増大していることがわかった．つまり，コーパスの文数と検索時間増大の間には，関連性は低いものと考えられる．</subsection>
  <subsection title="ラベルの頻度">クエリ内のラベルが検索時間に影響を与えることが考えられる．例えば，クエリに含まれるラベルが非常に稀にしか出現しないラベルであれば，非常に早く検索することができるはずである．しかし，からわかるように，PennTreebankCorpusはラベル（非終端記号）の異なり数が多いが検索時間が急激に増加している．一方，東工大コーパス(RWC)はラベルの異なりが少ないが，検索時間が増大していない．PennTreebankCorpus，東工大コーパス(RWC)を用いて，ラベルを``''で置き換えたクエリを用いて，実験を行った．クエリは，評価実験を行ったときと同一である．その結果をに示す．ラベルの情報がなくなったため，双方ともに評価実験よりも検索時間を要しているが，節点数と検索時間との関係に変化はなかった．ラベルの頻度と検索時間の増大は関連性が低いと考えられる．</subsection>
  <subsection title="節点の平均分岐数">次に，コーパスの特徴として節点の平均分岐数に注目した．分岐数が多くなれば，構文木は複雑になり，検索に時間を要することが考えられる．そこで，全てのコーパスについて，それぞれの節点の平均分岐数を調べた．その結果をに示す．この結果から確かに検索時間が増大する傾向にあるコーパスは，平均子供数が比較的大きいことがわかる．しかし，PennKoreanTreebankとPennChineseTreebankの差はあまりなく，平均分岐数が決定的な原因であるとは考えがたい．だが，コーパス内の文の構造の複雑さが一因である可能性は確認できる．</subsection>
  <section title="まとめ">本論文では，構文木付きコーパスを高速に構造検索する手法を提案した．構文木付きコーパスのデータベース化は，木構造を持つXML文書を格納・検索する手法を用い，部分木で表現されたクエリをSQL文に変換して検索を行う．節点数の多いクエリに対する検索時間が増大するという問題を解決するために，クエリを分割し，漸進的に検索する手法を提案した．クエリの分割は，まずコーパスから最大検索単位節点数を計算し，最大検索単位節点数をもとに，効率的に検索できるようクエリを分割し，検索を行う．評価実験では，7つのコーパス中の4つに対して，クエリを分割せずに検索する手法よりも効率的に検索を行うことができることを示した．また，評価実験で用いたコーパスには，クエリの節点数が増加すると検索時間が非常に遅くなるものと，そうでないものの2種類が存在した．その違いの要因が，コーパスに含まれる構文構造の複雑さに起因するものであることについて考察した．今後の課題として，次のようなものがあげられる．節点が少ないクエリに対する検索の高速化検索時間とコーパスに含まれる構文構造の複雑さとの関連性の解明コーパス作成支援システムへの応用document</section>
</root>
