<?xml version="1.0" ?>
<root>
  <title>音声対話システムにおける日本語自己修復の処理</title>
  <author>船越孝太郎徳永健伸田中穂積</author>
  <jabstract>音声対話システムが話し言葉に対応するためには，言い直し，助詞落ち，倒置などの不適格性とよばれる現象に対処する必要がある．これらの不適格性の中で特に問題となるのは，言い直しあるいは自己修復と呼ばれている現象である．しかし，自己修復に関する既存の手法は，自己修復を捉えるモデルと，その修正処理に問題点がある．本論文では，それらの問題点を改善した新しい手法を提案する．そして，提案手法を音声対話コーパスに適用した結果を基に，提案手法の有効性と問題点について考察する．</jabstract>
  <jkeywords>不適格性，自己修復，言い直し，話し言葉の解析，音声対話システム</jkeywords>
  <section title="はじめに">音声対話は，人間にとって機械との間のインターフェースとして最も望ましいものである．しかし，音声対話システムが日常にありふれた存在となるためには，人間の使用する曖昧で誤りの多い言葉，いわゆる話し言葉に対応できなければいけない．そのためには，繰り返し，言い淀み，言い直し，助詞落ち，倒置などの不適格性とよばれる現象に対処できる必要がある．これらの不適格性の中で特に問題となるのは，言い直しあるいは自己修復と呼ばれている現象である．ユーザの発話中に自己修復が存在した場合，システムはその発話の中から不必要な語を取り除き，受理可能な発話を回復する必要がある．この自己修復に関する研究は，英語に関するものでは，などがあり，日本語に関するものでは，などがある．しかしながらこれらの論文で提案されている手法では，自己修復を捉えるモデルに不十分な点があり，ソフトウェアロボットとの疑似対話コーパスに見られるような表現をカバーできない．また，自己修復を検出した後の不要語の除去処理に関しても十分な手法を与えていない．本論文では，日本語の不適格性，特に自己修復に対処するための新しい手法を提案する．この手法では，従来の手法では捉えられなかった自己修復を捉える事ができるように自己修復のモデルを拡張する．そして，表層及び意味レベルでのマッチングを用いた自己修復の解消法を提案する．まず，節では不適格性とその中での自己修復の位置づけについて述べる．節では，本論文で用いるパーザと文法について述べる．節では，本論文で提案する自己修復の処理手法について述べる．そして節では，提案手法をコーパスに対して適用した結果に基づいて考察する．</section>
  <section title="不適格性">本論文で扱う不適格性は，助詞落ち，倒置，冗長表現の3つである．このうち，助詞落ちと倒置は，次節で述べる文法記述の方法によって，構文解析の枠組みの中で処理をする．もう一つの不適格性である冗長表現は，同一話者によるものと複数話者によるものに分けられる．本論文では，同一話者による冗長表現のみを考慮する．同一話者による冗長表現を，本論文では図のように分類する．節で言及した自己修復は同一話者による冗長表現の一種となる．自己修復はさらに，繰り返し，言い足し，言い直しに分ける．本論文では，強調を意図した繰り返しについては考慮しない．従って，全ての繰り返し表現は自己修復として扱う．自己修復は，と同様に，パーザに処理機構を埋め込むことで対処する．言い淀みは，話者が単語を最後まで言わなかったために，単語の断片が残る現象である．言い淀みは，自己修復と共に現れる場合が多いため，既存の研究では自己修復の枠組みの中に取り込んでいる．これらの研究では，単語断片が単語断片として正確に認識されることを仮定しているが，現在の音声認識技術では難しい仮定である．そこで本論文では，言い淀みの処理は自己修復とは切り放し，未知語の誤認識を除去するための不要語処理に委ねる．これは，解析の途中で不要語の可能性がある語を読み飛ばすことで行う．ある語が不要語であるかどうかを局所的に見極めることは難しいので，それを不要語と見なした場合と，そうでない場合と，2つの仮説をパーザは保持する．そしてパーザは，できるだけ多くの入力語を用いる仮説を優先することで，不必要に読み飛ばしを行うことを避ける．</section>
  <section title="パーザ">不適格性を解消するための処理は全て，構文解析と平行してパーザの上で行う．本論文では，音声認識の結果が直接パーザに与えられ，パーザは入力された単語列を不適格性を解消しながら解析し，意味構造に変換して談話処理部に出力することを想定する．発話は，必ずしも音声認識器の出力単位に対応する必要はない．ただし，ここでは，発話の終端はなんらかの手法によって判断できるものと仮定する．以下，本論文で用いるパーザとパーザの使用する辞書について説明する．</section>
  <subsection title="係り受け解析を用いた漸進的な構文解析">構文解析の手法として，文節ベースの係り受け解析を採用した．我々の解析手法では内容語を重視し，機能語は内容語に付属するものと捉える．構文解析はスタックを用いて漸進的に行なう．本論文では詳細は省くが，このパーザの使用は，将来，提案手法を組み込む予定の音声対話システムに，漸進的な処理を行わせることを目的としている．パーザは，解析の途中に生成される複数の構文仮説を，別々のスタックに保持する．スタックの各要素には，依存関係で表現された構文木が納められる(図)．各スタックの要素である部分構文木のルートになっている語を「ルート語」と呼ぶことにする．スタックに新しい単語がプッシュされると解析が行われる．プッシュされた語が機能語であった場合には，単純にスタックの上から2つ目の要素のルート語にその機能語を付属させる．既に機能語が付属している場合には，「に・も」のように連接が可能な場合を除いて，機能語が言い直されたと考えて新しい機能語に置換する．次にプッシュされる予定の語が機能語でなければ，ここで係り受け解析を行う．係り受け解析はスタックトップの要素のルート語(rw_2)とトップのすぐ下の要素のルート語(rw_1)の関係を見て行う．すなわち，rw_1がrw_2に係り得るかどうか(もしくはその逆)を調べる．rw_1がrw_2に係ることができないならば，スタックは変化しない．しかし，rw_1がrw_2に係ることができるならばこのスタックをコピーし，片方にはrw_1がrw_2に係る仮説(H1)，もう片方にはrw_1がrw_2に係らない仮説(H2)を保持する．仮説H1を保持するスタックでは，一度上2つの要素をスタックから取り出したあとに，新しい係り受け関係を作った要素1つをスタックトップに戻す．仮説H2を保持するスタックは変化しない．また，H1については同様の操作を再帰的に行う．従って，という仮説スタックに「押せ」という単語がプッシュされると，という3つの仮説スタックが生成される．このパーザは，節に述べたように言い淀みを処理するために読み飛ばしも平行して行うが，本論文では詳細は述べない．</subsection>
  <subsection title="文法表現と辞書">本手法では，文節構造以外の文法に相当するものは，全て単語辞書の中に単語毎に用意する．ある内容語c_1が別の内容語c_2に係る時，c_1はc_2に対して特定の役割を担っていると考える．「赤い玉」という名詞句であれば，「赤い」は「玉」に対してその色に関する情報を与える役割を持っていると見なす．「馬は前行って」という文であれば，「馬」は「行って」に対して，その動作主を特定する情報を与える役割を持ち，「前」は「行って」に対して，その進行方向を特定する役割を持つと見なす．例えば，「押して」という命令動詞の辞書のエントリは図のように記述する．図の第一行目は，「押して」という語が，左から順に，動詞である命令(IMP+)であるPUSH+という動作を表す素性を持つ指定の無いときの動作の程度は#STDである指定の無いときの動作の速さは#STDであるということを表している．第二行目以降は，「押して」に係ることのできる語の制約を役割毎に示している．例えば第二行目の，&lt;OBJECT&gt;(目的格)という役割は，左から順に，必須格(!が示す)である「押して」に対して1つしか存在しない「押して」に係るときは前方依存(F)／後方依存(B)のどちらでも良い(*はワイルドカード)名詞しかこの役割は取れないその名詞についている機能語は「は」「を」「も」「-(無標)」のどれかINSTANCE+素性を持っている語でなければならないという事を表している．節で述べたパーザは，この辞書を用いて解析を行う．内容語c_1が内容語c_2に係ることができるかどうかは，c_1がc_2のエントリに示された役割の内のどれかを満たすことができるかどうかによって決まる．そして解析の段階で，全ての係り受けにその意味役割が割り当てられる．このパーザにより，不適格性の内，助詞落ち，倒置は解決できる．すなわち，助詞落ちは上記の文法での-(無標)の場合として扱い，倒置は前方依存が可能かどうかを辞書に記述することで対処する．またこのように係り受け解析の段階で，語の意味役割を特定することで，後述する自己修復の意味的な修正処理が可能になる．</subsection>
  <subsection title="自己修復の処理">本手法ではと同様に，自己修復個所の検出と修正を，構文解析と平行して行う．ただし，が決定的であるのに対し，本手法では自己修復の処理においても複数の仮説が生成される．複数の仮説が生成される場合，仮説に尤度を与える必要があるが，その方法については本論文では省略する。本手法では，自己修復が検出されるとすぐに修正処理が行われるので，出力を見てもどのような自己修復が存在したのかは判らない．パーザの出力は，修正され冗長性を除去された構文木，もしくは辞書に与えられた役割を基に変換された格フレームの形で出力されるからである．冗長表現はそれ自体が曖昧で，言い直し，リスタート，言い淀みのどれと解釈して処理を行っても得られる結果が同じである場合が多い．結果が同じであるにも関わらず，冗長性の解釈の違いで異なる仮説を保持することは，不必要な曖昧性と計算量の増加を招くだけである．従って本手法では，冗長性の解釈のされかたには関心を持たず，冗長表現の検出と修正処理を同時に行って極力曖昧性を無くす．解析途中で同じ結果をもつ仮説が複数生成された場合は，1つだけ残して残りのものは破棄する．新しい単語が仮説スタックにプッシュされて係り受け解析が行われると，係り受け解析が終わった仮説から順に自己修復の検出・修正処理を受ける．自己修復の検出と修正の処理は，係り受け解析と同様にスタックの上2つの要素を処理することで行う．すなわち，スタックトップの要素の木がRPで，スタックの上から2番目の要素の木がRPDである(あるいはRPDを含んでいる)と考える．要素を2つ取り出した後の処理は，言い足し及び言い直しとリスタートの2つで別れる．図では，言い足しと言い直しは別に分けたが，実際の処理は似ている部分が多いので1つにまとめて処理をする．</subsection>
  <subsection title="過去の研究の問題点">我々の疑似対話コーパスの中に現れる自己修復に過去の研究で提案されていた手法を適用したところ，対処できない例が見られた．対処できない理由は2つある．１つは，自己修復のモデルの問題，もう1つは自己修復を検出した後の修正処理の問題である．まず，自己修復のモデルの問題について説明する．既存の研究では，どれものRepairIntervalModel(RIM)に類するモデルを用いて自己修復を捉えている．RIMは，入力文の上で，修復を受けるものを含む区間をREPARANDUM(以下RPD)，修復するものを含む区間をREPAIR(以下RP)，RPDとRPの間に現れるフィラーや休止，手がかり句(cuephrase)を含む区間をDISFLUENCY(以下DF)としたときに，の関係になるというモデルである．そして，RPDとDFの境界，不適格性が始まる点，を中断点(interruptionsite/point)と呼ぶ．例えば，となる．そしてこのモデルでは，手がかり句やフィラー以外の語がRPDにもRPにも含まれずにRPDとRPの間に現れることはないと仮定する．従って，RIMは日本語に現れる次のような自己修復を扱えない．この例では「前に押して」が，RPDとRPの間に入っており，モデルの前提を破っている．パターンマッチングや統計的言語モデルによる自己修復の検出は，人間が`self-monitoring'によって即座にエラーを訂正するため，自己修復が局所的であり，かつRPDの始端からRPの終端までが3,4語程度の短いものが大多数であると仮定している．従って，パターンマッチングや統計的言語モデルを用いて()のような自己修復を検出することは，原理的には可能でも，精度を悪化させることが予想される．またこれらの手法では，DFの始端をRPDの終端として定義し，検出したRPDは単純に削除してしまうので，()のような例を正しく修正できない(この場合，「前に押して」まで削除される)．はの並列構造推定手法を用いてRPDの始端を推定しており，他のパターンマッチング手法とやや性質を異にするが，仮に正しくRPDの始点を推定できたとしても，RPDの終端はDFの始端に固定されているので，()を正しく修正できない点は変わらない．また，中断点の位置が予め適切に与えられること，2つの並列構造が完全に単語列の中に含まれていることなどが要求されるので，漸進的な処理には向かず，実用上も疑問が残る．も中断点が音響的に検出されることを前提にしているが，その報告では，中断点の音響的な検出の再現率は50,%に満たない．は，自己修復をRPDからRPへの係り受け関係として扱うため，()に類する自己修復は原理的に扱えない．単一化を基にした句構造規則で自己修復を扱うの場合，現在提案されている規則では()のような表現を扱うことはできない．新しい規則を追加すれば扱えるかもしれないが，その場合，条件の判定に必要な仕組みなどを新たにパーザに加える必要があり，規則の追加だけで一般的に解決することはできないだろう．も句構造規則で自己修復を扱うが，検出自体はの手法に頼っており，上のような例は扱えない．も，提案手法のままでは()のような表現は扱えない．次に，自己修復を検出した後の修正処理の問題について説明する．先にも触れたように，従来の手法では，検出したRPDの部分全体を発話から削除する．実際，英語，日本語に関わらずこの処理が正しく機能する場合は多い．しかし，次のような発話では，この方法は重要な情報を落としてしまう．この自己修復の処理は単なる削除だけでは不十分で，もっと複雑な処理が必要である．では，動詞句の自己修復の場合に，RPDには含まれるがRPに含まれていない格情報を保存することの必要性について言及しているが，具体的な方法は述べていない．は，RPDを単純に削除してしまうと，RP内の代名詞がRPD内の名詞を参照する場合に問題が起きることを指摘しているが，RPDも意味解析モジュールに渡す必要があるというだけで，意味解析モジュールでの具体的な処理法については言及していない．</subsection>
  <subsection title="自己修復の再分類">図の内，自己修復に関する部分を，実際の処理に合わせて図のように再分類する．この分類の中では，繰り返しを言い足しに含めている．ここで構造隣接という言葉を使っているのは，従来のなどの分類で使われている表面的な隣接性を示す言葉と区別するためである．言い足しは，``addition''，``appropriaterepair'',などと呼ばれているもので，RPDの中に間違った情報は含まれていないものである．図の言い足しと繰り返しに対応する．言い足しの中で，構造隣接に含まれるものが今までのモデルでも扱える部類である．構造非隣接に含まれるものが，節で述べた，今までのモデルでは扱えないものである．この言い足しのRPDとRPの間には次のような制限がある．言い直しは，``repair''，``errorrepair''などと呼ばれるもので，RPDの中に間違った情報が含まれているものである．図の部分訂正に対応する．言い直しは，手がかり句が挿入されている明示的な言い直しとそうでない非明示的な言い直しとに区別する．これは，非明示的な構造非隣接に分類される類いの発話を人間が通常することはなく，仮に発話されても人間の聞き手ですら混乱し，理解できないと仮定するからである．おそらく，「赤い玉を押して青い玉を」などと指示された場合には，通常の人間であれば発話者に真意を問い質すだろう．リスタートは，``restart''，``freshstart''，``fullsentencerepair''などと呼ばれているもので，これも明示的なものと非明示的なものとに分ける．図の全訂正に対応する．漸進的な処理において，早い段階でリスタートを言い直しと区別することは難しい．RPに連体修飾句が含まれていたりすると，かなり先まで解析が進まないと判別できない場合もある．しかし，日本語においては「名詞句+は」やある種の手がかり句などの検出をすることで，ある程度のリスタートは正しく検出するできる可能性がある．明示的なリスタートの場合には既に訂正を行う意思表示を示す編集表現が与えられているので，この言い直しの手がかり句とその後に現れる情報を組み合わせることで，リスタートの処理を行える．一方，非明示的なリスタートは，ポーズの他にも，アクセントや身ぶりなど，パラリンガルな要素を考慮しないと，有意な検出は難しい．そこで，本論文では明示的なリスタートのみを考慮する．</subsection>
  <subsubsection title="言い足し及び言い直しの処理">まず，構造非隣接型の自己修復をどのように捉えるべきかを考える．ここで，コーパスの観察などから，構造非隣接に分類されるタイプの発話は，という形しか取らず，RPDは，主格や目的格として必ず動詞に係っていると仮定する．この結果，構造非隣接でRPDとRPになることができる組は，名詞句の組か副詞句の組しか無いことになる．この構造非隣接型の冗長性を解消するための解釈の仕方は2通り考えられる．1つは，RPが動詞に後ろから係ると考える方法(A)である．この時既に動詞に係っているRPDは，後から述べられたRPによって置き換えられると捉える．つまり，この解釈では自己修復が倒置と組み合わさったものと考える．もう1つは，RPの後ろに来るべき動詞が省略されたものと解釈する方法(B)である．つまり，という解釈をする．この場合，構造非隣接は見かけ上の存在であり，本質的には構造隣接と同じになる．つまり，省略された動詞を補完することで，という形に還元でき，これは従来のRIMで捉えられるパターンとなる．この解釈の場合，動詞を補完した後の処理は構造隣接の場合の処理とほぼ同じになるために，統一的な解釈ができるという利点がある．しかしながら，(B)の場合，動詞の補完をするまでの処理を特別に用意しなければならず，これは(A)の処理に必要な手続きのほとんどを含む上に更に多くの処理が必要になる．さらに，動詞を補完してしまえば動詞が省略されなかった場合と全く同じように処理してよいのかは疑問である．このような理由に加え，著者の内省では(A)の解釈の方が自然に思えたため，本論文では(A)の解釈を取った．検出処理ある仮説スタックが与えられると，検出は図の手順で行う．図の手順の中で使用されている置き換え条件とは，rw_1あるいはd_i^rw_1(図参照)とrw_2がそれぞれに付属している機能語も含めて満たさなければならない条件である．この条件が満たされるとき，rw_1(あるいはd_i^rw_1)はrw_2で置き換えられる．この置き換え条件はの分類Aの(I)とほぼ同じである．置き換え条件の一部(名詞に対する条件)を図に示す．名詞N_1と名詞N_2の組に関して，図のどれかを満たせば良い．修正処理検出した自己修復には，続いて修正処理を行う．既存の研究での修正処理は，単純にRPDを削除することで行われていた．しかし，これではRPDの中には存在するがRPでは省略されてしまった情報まで削除してしまい好ましくない．そこで本手法では，rw_1をルートとする部分木(t_1すなわちRPD)がrw_2をルートとする部分木(t_2すなわちRP)で置き換えられるときに，t_1には存在するがt_2には存在しない情報を，t_1からt_2に移し替える処理を行う．これは，具体的にはrw_1に係っている語の内，t_2では省略された語をrw_2に付け替えることで行う．ただし，この時rw_2に付け替えることで矛盾が起きるような語は付け替えないで捨てる．例えば，という例の場合(+&lt;GEN&gt;+,+&lt;LOC&gt;+,+&lt;COL&gt;+などは，そのすぐ上の語にパーザが与えた役割を示す)，t_2で省略されている``((ニワトリの)前の)''を，t_2の「玉を」に付け替える．その結果t_2'は，となる．この処理は部分木のルートだけではなく，その中間ノードに対しても再帰的に適用する必要がある．例えば，という自己修復で，t_1とt_2のルートの「押して」に対してのみこの処理を適用した場合t_2'は，となり「前の」が落ちてしまう．これを防ぐためには，t_1の「玉を」とt_2の「玉を」を対応づけて，「玉を」に関しても同様に付け替え処理を行う必要がある．語rw_1をルートとする部分木t_1を，語rw_2をルートとする部分木t_2で置き換えるとする．この時，rw_1に係っているm個の語をd_1^rw_1,d_2^rw_1,...,d_m^rw_1とする．rw_2に係っているn個の語をd_1^rw_2,d_2^rw_2,...,d_n^rw_2とする．このt_1とt_2に対して，付け替え処理を行う関数dmerge(rw_1,rw_2)のアルゴリズムの概要を図に示す．このアルゴリズムは人間の自己修復の認識に関する下の3つの仮定を満たすようになっている．d_1^rw_1,...,d_m^rw_1の中の任意の語d_i^rw_1と同じ語はd_1^rw_2,...,d_n^rw_2の中にただ1つd_j^rw_2しかなく，その逆もまた成り立つ時に限り，d_i^rw_1とd_j^rw_2のそれぞれのrw_1とrw_2に対する役割が例え異なろうとも，d_i^rw_1はd_j^rw_2によって置き換えられたと認識できる．d_1^rw_1,...,d_m^rw_1の中の任意の語d_i^rw_1と同じ役割を持つ語はd_1^rw_2,...,d_n^rw_2の中にただ1つd_j^rw_2しかなく，その逆もまた成り立つ時に限り，d_i^rw_1とd_j^rw_2が例え異なる語であろうとも，d_i^rw_1はd_j^rw_2によって置き換えられたと認識できる．上の2つの認識に食い違いがない場合にのみ，d_i^rw_1はd_j^rw_2によって置き換えられたと認識できる．つまり，図のアルゴリズムは，d_i^rw_1が語そのものか役割によってd_j^rw_2と1対1に対応付けが可能な場合で，なおかつ語と役割に関する対応付けに食い違いがない場合のみ，d_i^rw_1とd_j^rw_2を対応づけ，dmerge(d_i^rw_1,d_j^rw_2)を再帰的に実行する．この条件を満たさないd_i^rw_1とd_j^rw_2に関しては処理は何も行われずに無視される．これは，RPD(t_1)とRP(t_2)の間での対応関係が曖昧な場合には人間も特定の解釈をすることができないと仮定するからである．仮定1によって，という発話から，t_2''ではなくt_2'を得ることができる．同様に仮定2によって，「あれを馬の前に押してごめん後ろに押して」という発話から「あれを馬の後ろに押して」という解釈を得ることができる．このアルゴリズムで，語と語の対応を取るのに役割を使うのは，基本的には助詞が同じかどうかを見ることと同じである．しかしながら，助詞は省略される場合があるので，助詞を見るだけでは解決できない場合がある．例えば，という例の場合，単語も助詞も異なるため，意味すなわち役割を考えないと「玉」と「やつ」の対応を取ることができない．もともと助詞がない場合(名詞に係る形容詞など)でも，すでに役割のラベルが与えられているので，新たに意味素性などの情報を用いて対応関係を計算する必要がなく，処理が効率的になる．また，対応付けた2つの内容語のうち，より詳細な情報を持つ下位クラスの語を残すことによって，代名詞による繰り返しなどの場合も情報の損失を防げる(図の3.の後半)．上の例の場合，下のt_2''ではなく，t_2'を得られる．</subsubsection>
  <subsubsection title="リスタートの処理">先に述べたように，リスタートに関しては明示的な場合，つまり編集表現が発話された場合しか扱わない．リスタートの場合重要なのは適切な検出のみで，処理に関してはリスタートの発生点より以前の入力を無視すれば良い．リスタートの検出には，2つの特徴を捉えることで対処する．1つは，日本語の特性を利用し，編集表現の後に「名詞+は」が出現するかどうかを調べる．もう1つは，で述べた，置き換え条件を逆に利用する．もし，編集表現の後に出現している部分木のルートが編集表現の直前に出来ていた部分木のルートと置き換え条件を満たさないならば，それは明示的な言い直しではなく，リスタートである可能性が高いと考えられる．この可能性は，編集表現の後に出現している部分木のルートの，編集表現からの形態素列上の距離が離れれば離れるほど高くなる．</subsubsection>
  <section title="提案手法の評価と考察">提案手法を評価するために，提案手法を「ソフトウェアロボットとの疑似対話コーパス」(以後，疑似対話コーパス)に人手で適用した．その結果に基づいて，定性的な考察を行う．</section>
  <subsection title="疑似対話コーパスへの提案手法の適用">「ソフトウェアロボットとの疑似対話コーパス」は，全15対話，532発話を含む．疑似対話コーパスは，「仮想世界内にある2体のロボットを操作して，同じく仮想世界内にある4つの球をあらかじめ指定された位置に配置する」という課題で収集された．収集に参加したのは，1対話につき5人である．5人の参加者の内訳は，ロボットに音声言語で指示を与える者(指示者)指示者の指示にしたがってロボットを操作する者(ロボット操作者)仮想世界の様子を映すカメラを操作する者(カメラ操作者)仮想世界を管理するシステムを担う者(システム管理者)タスクの終了を判断する者(終了判定者)である．参加者は対話毎に役割を交替した．指示者はモニタに映されるカメラの映像を通して仮想世界内の様子を知り，球を操作する2体のロボットに加えて，カメラの位置も言語によって操作する．また，指示者は自分や球の位置などをシステム管理者に質問することができる．1対話の収集は，ロボットや球がランダムに配置された状態から始まり，指示者が指定された配置を完了したと終了判定者が判断した所で終る．コーパスの収集は，「発話者が指示を与え，それに対してロボットが動作する」といサイクルの繰り返しによって採集された．また，収集経過は市販のビデオカメラで撮影された．このコーパスを調べた結果，今回対象とした不適格性の内，助詞落ち以外のものは99個所あった．この内，単純な倒置15個を除いた84個所が冗長表現で，14個所の言い淀みを除く70個所が，単語断片ではないはっきりとした単語で構成される自己修復であった．70個の自己修復を図の分類に従って分類した結果は以下の通りである．RPが文頭から始まっていて，言い足し／言い直しともリスタートとも解釈できる場合には，言い足し／言い直しとした．分類不能の5個は後で説明する挿入表現に該当する．提案手法をこれらの自己修復に適用した場合，提案手法で解決できるものが53個，解決できないものが17個であった．疑似対話コーパスの調査，及び手法の適用に際しては，「ねえ」，「ですねえ」，「さあ」，「下さい」等の，間投詞的あるいは定型的な接尾表現は無視した．コーパスの規模が小さいことと，人手での作業であることから，本論文ではこれ以上の定量的な評価は行わない．かわりにこのコーパスを用いて定性的な考察を行う．</subsection>
  <subsection title="考察">図に，今回使用した疑似対話コーパス中のデータで，提案手法が有効に動作する例を示す．今回使用した疑似対話コーパスに現れた自己修復を含む発話には，図の例(I)のような単純なものから，例(VI)，(VII)のような複数の自己修復を含むものまであった．例(V)では構造非隣接の言い足しが起きているが，提案手法により問題なく対処できている．また，例(IV)，(V)，(VI)，(VII)では修正処理によってRPDからRPへ適切に情報が残されている．例(V)，(VI)では「その」という連体詞が，RPDにしか現れていない．「その」という連体詞は具体的な情報を与えるものではないが，「その」という語が発話されたということを意味解析以降の処理に伝えることで，対象の特定などにおいてある種の絞り込みを行なうことができる可能性がある．従って，このような語を削除せずに残しておけることにも意義がある．また，本手法は漸進的に処理を行なっていくので，例(VII)のように自己修復が入れ子になっている場合でも問題なく処理できる．次に提案手法では対処できなかった表現をタイプ別に分類し，それぞれに必要な処理について述べる．*挿入表現このタイプの自己修復はでは分類Aの(II)[愛甲石田まで二十分もかからない]_Zから」という例が挙げられている．に分類され，では挿入と呼ばれている．これには5つ該当する例があった．その内の1つとして，が挙げられる(ここで，「黒」は「黒いブロック」をさしている)．のように係り受け解析を基本とする場合，このタイプのものが解決できないことはで指摘されている．しかし，読み飛ばしや非明示的なリスタートの処理をポーズの情報などを用いて高い確信度で行うことができれば，うまく解決出来る可能性がある．また，構造非隣接の扱いを拡張するか，パターンマッチングによる対応付けを別に導入することによって解決することも可能である．は，の様な手法は漸進的な処理に用いられないと述べているが，その理由は不明である．は音声認識器の出力を解析することを前提にしており，そうであるならばパターンマッチング手法を併用することも(その結果を必ず信用するかどうか，あるいは修正処理までを行わせるかどうかは別として)可能なはずである．の手法自体も，挿入表現を扱う規則の条件から(脚注参照)，読み飛ばし以上の事はできず，例えば，というような発話は扱えない．*単純な置き換えによる情報の損失これに含まれるものは1つであった．本手法では，RPDの単純な削除は情報の損失を招くとして，付け替えによる情報の保存を考えた自己修復の処理手法を提案した．しかし，本手法で提案した情報の保存はRPで省略された係り受け関係の移し替えのみを考慮していて，言い直された単語自体は単純に置き換えている．このままでは，次のような例で情報の損失を起こす．この例では，「青」は青いものを示す代名詞として使われている．この「青」を単純に「ブロック」で置き換えてしまうと，折角話者が提供した「青色」という情報を失い，システムは曖昧性を正しく解決できない恐れがある．これを防ぐためには，単純に表層のシンボルの操作として自己修復を扱うのではなく，本論文で提案した手法よりもより深い意味の操作として自己修復を扱う必要がある．この例であれば，単語間においても単純な置き換えを行うのではなく，意味素性の引き渡しを行わなければならない．*より高度な意味処理が必要な表現これには9つの例が含まれる．上に述べたタイプも，本手法よりも高度な意味処理を要求するものであるが，上のタイプはまだ比較的簡単な問題である．それよりも，ここに分類されるものは更に複雑な意味処理を要求するものである．提案手法では，情報の保存のために行われるRPDとRPの対応づけが単語のレベルで行われるため，下の例のような場合正しく修正処理を行うことができない．この例の場合，「前に」は「辺りに」と対応づけられるために，「ガンダムの」は「辺りに」に付け替えられてしまい，``((それを)((ガンダムの)(前の)辺りに)押して)''という結果が生成されてしまう．この例を正しく解釈するためには，「前に」が「前の辺りに」という複合表現と対応していることを理解できる必要がある．また，本手法を含めて，表層のレベルで自己修復を扱う既存の手法はどれも，品詞が異なるために次のような簡単な表現も扱う事ができない．当然，のような，表層上はかなり異なるが意味的にはほぼ同じと考えられる表現も扱う事ができない．*主辞の省略このタイプのものは2つあった．2つとも下の例のように「〜から見て」という句が動詞の後から付け足されている例である．「カメラから見て」は「押して」に係るわけではないので，本論文で提案した構造非隣接に対する処理手法では解決できない．これを解決するためには「右に」あるいは「右に押して」までを，何らかの推論によって補完して考える必要がある．あるいは，交差する係り受けも許すような仕組みが必要である．*見かけは普通の言い直しだが，単純な言い直しとしては解決できない表現このタイプのものは1つ見つかった．この例の場合，一見動詞句の非明示的な言い直しのように見えるが，単純に「映して」を「回り込んで」で置き換えてしまうことはできない．ここでは，話者は「右から映す」ための手段として「右に回り込む」ことを依頼しているのであって，回り込みながら「(何かを)撮影する」ことが重要なのである．このような発話を正しく理解するためには，談話解析までも構文解析と並列化した仕組みが必要である．そして，外界の状況やユーザの意図に応じた処理を行わなければならない．</subsection>
  <section title="おわりに">本論文では，自己修復のモデルを拡張し，従来よりも多くの表現を検出する方法を示した．そして，RPDとRPの間で単語間の対応関係を取ることにより，従来の手法では単純に削除されてしまった情報を，自己修復の冗長性を修正した後にも適切に残すことができる手法を提案した．また，本論文で用いたパーザは，単語の役割を認識することで，日本語に見られる不適格性の1つである助詞落ちを回復することができる．そして，自己修復の修正処理は，パーザによって構文木に付与される単語の役割を利用することで，適切かつ効率的に行なうことができる．提案した検出処理は，日本語，及び導入したパーザに依存するため，その他の言語への直接の応用は難しいかも知れない．しかし，修正処理は，日本語やパーザに関係なく応用が可能である．本論文では，小規模のコーパスに人手で適用した結果をもとに定性的な考察を行った．今後の課題の1つとして，実際の音声対話システム上での利用を視野にいれたより定量的な評価を行う必要がある．提案手法では，自己修復の検出に構文的な手がかりのみを用いた．構文的な手がかりを用いれば，ほとんどの自己修復の検出は可能である．しかし，非明示的なリスタートはこの限りではない．また，節で述べたように，本手法で用いたパーザは，多くの語を含んでいる仮説を優先する．従って，自己修復の可能性を検出することはできても，そこに自己修復の存在を認めない仮説の方が優先されてしまうことがある．例えば，「馬の右の，馬の左の玉を押して」という発話の場合，「馬の右の」を「馬の左の」で言い直しているとする仮説よりも，「馬の右の」が2番目の「馬」に係るとする仮説が優先される．この問題を解決するためには，等のように音響/音韻情報を導入して，自己修復として処理する仮説の方が尤度が高くなるような処理が必要になる．検出後の修正処理のために提案したアルゴリズム(図)は，我々のコーパス内の事例と我々が解釈可能であると考え出した例とを満足する．しかしながら，このアルゴリズムが前提としする３つの仮定(節)が，広く一般に成り立つものであるかどうかについては，他の分野のコーパスなどを用いて検証する必要がある．また，本論文では，発話の終端は判るものと仮定して話を進めたが，実際にはこれは大きな問題であり，本論文で用いたパーザが漸進的な構文解析を行うのも，1つにはこの問題を踏まえてのことである．発話が連続する状態では，自己修復として扱うべきか別々の発話として扱うべきかを決定できる枠組みが必要である．そのような枠組みとの連携も今後の課題である．自己修復を検出する手がかりとして，編集表現と呼ばれるキーワードが用いたが，これらの表現は必ずしも自己修復だけに用いられるのではなく，通常の否定表現としても用いられる．自己修復とそれらの表現の区別をつけられる仕組みも必要である．document</section>
</root>
