<?xml version="1.0" ?>
<root>
  <jtitle>冗長性制約付きナップサック問題に基づく複数文書要約モデル</jtitle>
  <jauthor>西川仁平尾努牧野俊朗松尾義博松本裕治</jauthor>
  <jabstract>本論文では，複数文書要約を冗長性制約付きナップサック問題として捉える．この問題に基づく要約モデルは，ナップサック問題に基づく要約モデルに対し，冗長性を削減するための制約を加えることで得られる．この問題はNP困難であり，計算量が大きいことから，高速に求解するための近似解法として，ラグランジュヒューリスティックに基づくデコーディングアルゴリズムを提案する．ROUGEに基づく評価によれば，我々の提案する要約モデルは，モデルの最適解において，最大被覆問題に基づく要約モデルを上回る性能を持つ．要約の速度に関しても評価を行い，我々の提案するデコーディングアルゴリズムは最大被覆問題に基づく要約モデルの最適解と同水準の近似解を，整数計画ソルバーと比べ100倍以上高速に発見できることがわかった．</jabstract>
  <jkeywords>自動要約，複数文書要約，ナップサック問題，最大被覆問題，ラグランジュ緩和</jkeywords>
  <section title="はじめに">現在の自動要約の多くは文を単位にした処理を行っている．具体的には，まず入力された文書集合を文分割器を用いて文集合に変換する．次に，文集合から，要約長を満たす文の組み合わせを，要約としての善し悪しを与える何らかの基準に基づいて選び出す．最後に，選び出された文に適当な順序を与えることによって要約は生成される．近年では，複数文書の自動要約は最大被覆問題の形で定式化されることが多い．これは，入力文書集合に含まれる単語のユニグラムやバイグラムといった単位を，与えられた要約長を満たす文の集合によってできる限り被覆することによって要約を生成するものである．最大被覆問題に基づく要約モデル（以降，最大被覆モデルと呼ぶ）は，複数文書要約において問題となる要約の冗長性をうまく取り扱うことができるため，複数文書要約モデルとして高い能力を持つことが実証されている．しかし，その計算複雑性はNP困難であるため，入力文書集合が大規模になった場合，最適解を求める際に多大な時間を要する恐れがある．本論文で後に詳述する実験では，30種類の入力文書集合を要約するために1週間以上の時間を要した．平均すると，1つの入力文書集合を要約するために8時間以上を要しており，これではとても実用的とは言えない．一方，ナップサック問題として自動要約を定式化した場合，動的計画法を用いることで擬多項式時間で最適解を得ることができる．ナップサック問題に基づく要約モデル（以降，ナップサックモデルと呼ぶ）では，個別の文に重要度を与え，与えられた要約長内で文の重要度の和を最大化する問題として自動要約は表現される．この問題は個別の文にスコアを与え，文のスコアの和を最大化する形式であるため，要約に含まれる冗長性が考慮されない．そのため，最大被覆モデルとは異なり冗長な要約を生成する恐れがある．最大被覆モデルとナップサックモデルを比較すると，前者は複数文書要約モデルとして高い性能を持つものの求解に時間を要する．一方，後者は複数文書要約モデルとしての性能は芳しくないものの高速に求解できる．本論文では，このトレードオフを解決する要約モデルを提案する．本論文の提案する要約モデルは，動的計画法によって擬多項式時間で最適解を得られるナップサック問題の性質を活かしつつ，要約の冗長性を制限する制約を陽に加えたものである．以降，本論文ではこの複数文書要約モデルを冗長性制約付きナップサックモデルと呼ぶことにする．冗長性を制限する制約をナップサックモデルに加えることで冗長性の少ない要約を得ることができるが，再び最適解の求解は困難となるため，本論文では，ラグランジュヒューリスティックを用いて冗長性制約付きナップサックモデルの近似解を得る方法を提案する．ラグランジュヒューリスティックはラグランジュ緩和によって得られる緩和解から何らかのヒューリスティックを用いて実行可能解を得るもので，集合被覆問題において良好な近似解が得られることが知られている．本論文の貢献は，新しい要約モデル（冗長性制約付きナップサックモデル）の開発，および当該モデルに対する最適化手法の提案（ラグランジュヒューリスティックによるデコーディング）の両者にある．冗長性制約付きナップサックモデルの，最大被覆モデルおよびナップサックモデルに対する優位性を表に示す．提案する要約モデルを提案する最適化手法でデコードすることで，最大被覆モデルの要約品質を，ナップサックモデルの要約速度に近い速度で得ることができる．以下，2節では関連研究について述べる．3節では提案する要約モデルについて述べる．4節では，デコーディングのためのアルゴリズムについて述べる．5節では提案手法の性能を実験によって検証する．6節では本論文についてまとめる．</section>
  <section title="関連研究">複数文書要約においては，要約の冗長性に対する対処が重要な課題の1つである．複数の文書から1つの要約を生成する際に，複数の文書が類似する情報を含んでいるときには，類似する情報がいずれも要約に含まれる恐れがある．複数文書要約の目的を鑑みると，類似する情報が要約に2度含まれることは好ましくないため，この問題に対処する必要がある．この冗長性に対する対処として，Filatovaらによって最大被覆問題による要約モデルが提案された．最大被覆問題による要約モデルは文の集合と要約長を入力とする．集合中の文はそれぞれ何らかの概念を含んでおり，この概念はその性質に応じて重要度を持っている．概念はユニグラムやバイグラムなど，文から抽出できる何らかの単位である．また，文はそれぞれその単語数や文字数に応じて，長さを持っている．最大被覆問題の最適解は，合計の長さが要約長を超えない文の集合のうち，集合中の文が持っている概念の重要度の和が最大となるものである．ただし，文の集合に含まれる概念の重要度の和を計算するときには，同じ概念は一度しか数えない．例えば，文の集合にある概念が3つ含まれていたとしても，最大被覆問題においては，文の集合に含まれる概念の重要度の和は，その概念が1つしか含まれないときと同じである．複数文書の要約を最大被覆問題として考えた場合，同じ概念は一度しか数えないという性質が重要な役割を果たす．すなわち，文が含む概念を情報とすると，同じ情報を3つ含んだ要約も同じ情報を1つ含んだ要約も解としての良さは同じであり，よりよい解はより多様な情報を含んだ解である．このような，多様な情報を含んだ解がより良好な解であるという最大被覆問題の性質は，複数文書要約に必要なモデルの性質として適切であり，これまで最大被覆問題に基づいた要約モデルがいくつも提案されてきた．Filatovaらは単語を概念として，重要度をtf-idfで与え，これを貪欲法で解いた．Yihらはスタックデコーダを用いてこれを解いた．高村らはこれに整数計画問題としての厳密な定式を与え，近似解法と分枝限定法による結果を報告した．Gillickらも同様に整数計画問題としての定式を与え結果を報告した．これらは全て新聞記事を要約の対象としているが，他の領域を対象にした複数文書要約も行われている．東中らはコンタクトセンタログを要約の対象として，発話を文，発話に含まれる単語を概念とする要約モデルを提案した．西川らはレビュー文書集合を要約の対象として，商品やサービスに対して評価を行っている記述を概念の単位とする複数文書要約モデルを提案した．最大被覆問題はNP困難であるため，解の探索が重要な課題である．貪欲法のような単純な探索法を用いた場合，良好な解を得られる可能性は必ずしも高くないものの，高速に解を得られる．Khullerらによって提案された貪欲法による最大被覆問題の解は，最悪でも最適解の目的関数値の(1-1/e)/2を達成する．高村らはこれを複数文書要約に応用して結果を報告している．スタックデコーダのようなより複雑な探索法を用いることによってより良好な解を得られる可能性が高まるが，探索に要する時間も増加する．分枝限定法を用いることで最適解を得ることができるものの，問題の規模が増加するにつれて探索に要する時間は著しく増加する．単一文書要約に目を向けると，単一文書要約は冗長性が問題となる恐れが少ないため，冗長性を加味しない手法を利用することができる．単一文書要約は，ナップサック問題として定式化できる．ナップサック問題による要約モデルも文の集合と要約長を入力とする．最大被覆問題と異なり，ナップサック問題はそれぞれの文が直接重要度を持っている．ナップサック問題の最適解は，合計の長さが要約長を超えない文の集合のうち，集合を構成する文の重要度の和が最大となるものである．ナップサック問題の最適解は動的計画法の一種である動的計画ナップサックアルゴリズムによって擬多項式時間で求めることができる．そのため，ナップサック問題の最適解は高速に求めることができる．しかし，ナップサック問題は文に対して直接重要度を定義し，その和を最大化するものであるため，冗長性を削減する仕組みを持たない．従って，複数文書要約に適用した場合，冗長な要約が生成される恐れがある．先に述べたように，最大被覆問題は複数文書要約に適した性質を持っているものの，良好な解の探索には多大な時間を要する．一方，ナップサック問題は複数文書要約に適さないものの，最適解の探索は容易である．本論文で提案する方法は，このトレードオフを解決するため，ナップサック問題に対して冗長性を削減する制約を加えたものである．</section>
  <section title="最大被覆モデルとナップサックモデル">ここでは最大被覆問題に基づいた要約モデル，最大被覆モデルと，ナップサック問題に基づいた要約モデル，ナップサックモデルを比較する．</section>
  <subsection title="最大被覆モデル">n文の入力および，それらに含まれるm個の概念を考える．概念は先に述べたよう単語のユニグラムやバイグラムなどであるが，文中から抽出できる他の何らかの情報でもよい．xを文iが要約に含まれる際にx_i=1となる決定変数を要素とするベクトルとする．zを概念jが要約に含まれる際にz_j=1となる決定変数を要素とするベクトルとする．wを概念jの重要度w_jを要素とするベクトルとする．行列Aの要素a_j,iを文iに含まれる概念jの数とする．lを文iの長さl_iを要素とするベクトルとする．Kを要約長とする．このとき，最大被覆問題は以下のように定式化される．_z&amp;w^z.t.&amp;Axz&amp;x0,1^n&amp;z0,1^m&amp;l^xKalign式(1)が目的関数であり，式(2)とベクトルbの要素b_iにa_ib_i(i)が成り立つときとする．から式(5)が制約である．式(4)が示すようにzの要素は0あるいは1である．もし概念z_jが要約に含まれれば，z_j=1となり，その重要度w_jは目的関数に加算される．可能であれば全ての概念を要約に含めたいが，要約長の制限によってはそれは許されない．式(2)が示すように，概念z_jを要約に含めるためには，z_jを含むいずれかの文が要約として選択されていなければならない．仮に文x_iが要約に含まれた場合，式(5)の左辺の値はl_iだけ増える．式(5)によって要約として選択された文の長さの合計はKを超えることが許されない．式(3)の示すようにxの要素は0あるいは1である．このことは1つの文は一度しか要約に含めないことを示す．これらのことから，最大被覆モデルの最適解は，要約長を満たす文の組み合わせを全て試し，全ての組み合わせに対してzを計算し，wとかけあわせ，かけあわせた値が最大となる文の組み合わせを探し出せば見つけられるとわかる．しかし，一部の組み合わせは要約長を満たさない場合があるものの，文の組み合わせの数は2^nにもなる．そのため，全ての組み合わせを列挙することは困難である．</subsection>
  <subsection title="ナップサックモデル">次に，ナップサック問題に目を向けることにする．xを文iが要約に含まれる際にx_i=1となる決定変数を要素とするベクトルとする．zを概念jが要約に含まれる際にz_j=1となる決定変数を要素とするベクトルとする．上述した最大被覆モデルと同様の記法に従ってナップサックモデルを記述すると以下のようになる．_z&amp;w^z.t.&amp;Ax=z&amp;x0,1^n&amp;z(N^0)^m&amp;l^xKalignここで，N^0は，0を含む，0以上の自然数である．目的関数である式(6)，1つの文は一度しか要約に含めないとする制約である式(8)，要約の長さに関する制約である式(10)は最大被覆モデルと変わらないものの，式(2)と式(7)，式(4)と式(9)がそれぞれ異なる．式(4)ではベクトルzは0と1を要素とするベクトルであったが，式(9)ではベクトルzは0以上の自然数を要素とするベクトルである．最大被覆モデルでは要約に同じ概念が何個含まれていようともそれぞれの概念について目的関数において一度しかその重要度を加算しなかった．それに対してナップサックモデルでは要約に同じ概念が複数含まれていた場合その数だけ重要度を目的関数において加算する．この性質のため，ナップサックモデルを用いて複数文書要約を行った場合には冗長な要約ができる可能性が高く，したがって，ナップサックモデルの複数文書要約における性能は芳しいものではない．式(7)は，式(2)と異なり，文が含む概念の数をそのままベクトルzに反映させる．例えば，文1は概念5を2つ含むとすると，a_5,1=2である．文2は概念5を1つ含むとすると，a_5,2=1である．文1と文2のいずれもが要約に選ばれたとすると（すなわちx_1=1，x_2=1），式(7)から，z_5=a_5,1x_1+a_5,2x_2=21+11=3となり概念5は要約に3つ含まれることになる．</subsection>
  <section title="冗長性制約付きナップサックモデル"/>
  <subsection title="ナップサックモデルへの冗長性制約の付与">前節で述べたように，最大被覆問題が冗長性に強い理由は式(4)にあり，ナップサックモデルが冗長性に弱い理由は式(9)であった．そこで，式(9)に工夫を施すことでナップサックモデルの冗長性を抑制することを考える．すなわち，ある単語が要約に含まれる回数を直接制御することで，ナップサックモデルの冗長性を削減する．本論文の主たる貢献はここにある．_z&amp;w^z.t.&amp;Ax=z&amp;x0,1^n&amp;zz_j|N^0[0,r_j]^m&amp;l^xKalign式(14)は，ベクトルzの各要素は0以上r_j以下の自然数であることを示す．すなわち，各概念が要約に含まれてよい個数を制限するベクトルr=(r_1,r_2,,r_m)を考え，これによって要約の冗長性を削減する．本論文では式(11)から式(15)で記述される要約モデルを冗長性制約付きナップサックモデルと呼ぶ．このモデルは最大被覆モデルと等価ではない．最大被覆モデルは，要約に概念が複数含まれることを許す．ただし，目的関数を計算する上では1つの概念の重要度は一度しか加えない．それに対し，冗長性制約付きナップサックモデルは，ある概念が要約に含まれる数を直接制限する+x_21と記述することができる．．上に述べた例と同じように，文1は概念5を2つ含み(a_5,1=2)，文2は概念5を1つ含むとする(a_5,2=1)．このときr_5=2であったとすると，文1と文2を同時に要約に含めることはできない．概念5は要約には2つしか含めることができないが，文1と文2いずれも要約に含めてしまうと要約には概念5が3つ含まれてしまうからである．最大被覆モデルでは，長さの制約に違反しない限り，このような組み合わせも許される．一方，冗長性制約付きナップサックモデルでは式(14)が示す制約を違反する組み合わせは許されない．ナップサックモデルに式(14)が示す冗長性に関する制約（以下，冗長性制約と呼ぶ）を加えることで冗長性を削減することができるが，動的計画ナップサックアルゴリズムで擬多項式時間で最適解を求めることはできなくなる．冗長性制約付きナップサックモデルを動的計画法で解くことは可能だが，冗長性制約を考慮するためには，探索の過程において，ある時点での要約に含まれる概念の数を記録しておかなければならない．ある時点において要約に含まれる概念の数の組み合わせは複数存在するため，これによって探索空間が増大してしまい，素早い求解ができなくなる．</subsection>
  <subsection title="冗長性制約のラグランジュ緩和">この冗長性制約付きナップサックモデルから冗長性制約を除去すれば，元のナップサックモデルが得られる．そこで，この冗長性制約をラグランジュ緩和する．以下は，式(14)を緩和し，ベクトルrによる冗長性制約を目的関数に組み込んだものである．_z&amp;w^z+(r-z).t.&amp;Ax=z&amp;x0,1^n&amp;z(N^0)^m&amp;(R^+)^m&amp;l^xK&amp;align=(_1,_2,,_m)は非負のラグランジュ乗数ベクトルである．式(16)から式(21)は，目的関数である式(16)の2つ目の項(r-z)および式(20)を除いてナップサックモデルと同じである．このラグランジュ緩和問題は，要約に含まれる概念jの個数z_jがr_jを超えた際に，非負のラグランジュ乗数_jを通じて目的関数に罰を与える．例えば，あるとき，概念5が要約に3つ含まれている(z_5=3)が，ベクトルrによって要約に2つまでしか含めてはならないと制限されている(r_5=2)とする．また，ラグランジュ乗数_5が1だったとする．このとき_j(r_5-z_5)=1(2-3)=-1となり，目的関数は低下する．の調整は，この緩和問題のラグランジュ双対問題L()=__zw^z+(r-z)を解くことで行う．このように，を適切に調整し，冗長性の原因となりやすい概念の重要度を低下させることで，動的計画ナップサックアルゴリズムによって元のナップサックモデルを解いた際でも複数文書要約として良好な解を得ようとするのが本論文の提案である．具体的なデコーディングの方法については次節で述べる．</subsection>
  <section title="デコーディング">デコーディングで必要になるのは，ラグランジュ乗数ベクトルの値を適切に設定することである．の値が適切に設定されていれば，あとはそれを動的計画ナップサックアルゴリズムで解くだけでよい．は前節で述べたラグランジュ双対問題を解くことで得られる．このラグランジュ双対問題は最小化の中に最大化が入れ子になっており，最適化が困難であるものの，劣勾配法を用いると良好な近似解が高速に得られることが知られている．劣勾配法は，初期値として適当なを設定し，の値を繰り返し更新していくものである．このとき，一度にどの程度_jの値を動かすか，という点が問題となる．一度に大きく値を動かせばデコーディングに要する時間が短くなると考えられるものの，最適解から離れてしまう可能性もある．そこで，本論文ではラグランジュヒューリスティックを利用する．ラグランジュヒューリスティックは，ラグランジュ乗数を更新するとき，上界と下界の差を利用してステップサイズを調整する．また，下界を計算する際に，ヒューリスティックを利用する．上界はある反復におけるラグランジュ緩和問題の解である．冗長性制約が緩和されているため，冗長性制約付きナップサックモデルの緩和問題の最適解の目的関数値は，明らかに緩和されていない元問題の最適解の目的関数値より高い．劣勾配法によってラグランジュ乗数を更新していく過程で，ラグランジュ緩和問題の解は，制約に違反している解，すなわち実行不能解から，徐々に目的関数値を低下させながら実行可能解に近づいていく．下界はなんらかのヒューリスティックによって得られる実行可能解である．本論文では，Haddadiによる方法と同様に，貪欲法を用いて実行可能解を復元する．詳細については次節で述べる．ラグランジュヒューリスティックによるデコーディングの具体的なアルゴリズムをAlgorithm1に示す．Algorithm1の基本的な手順は以下のようになる．[b][1]0,s0,x0,z0t=1toT	ssentence(A,,m,n,w)	xdpkp(K,l,n,s)	score(A,m,n,x,w)b_u		b_uscore(A,m,n,x,w)		zcount(A,m,n,x)	zviolatesr		xheuristic(A,K,l,m,n,w)		score(A,m,n,x,w)b_l			b_lscore(A,m,n,x,w)			x_lx				update(,b_l,b_u,,m,r,z)			x	x_lalgorithmicalgorithmラグランジュ乗数ベクトルを適当な値に初期化する．以下の手続きを既定回数だけ繰り返す．動的計画ナップサックアルゴリズムで式の最適解を得る．aで得た最適解が制約を満たしているときはそれを下界とし，(3)へ．そうでなければヒューリスティックを用いて実行可能解を得る．bで得た実行可能解がこれまでの下界を上回るものであれば，下界を更新する．下界を出力して終了する．はのステップサイズを調整するパラメータである．ベクトルs=(s_1,s_2,,s_n)の要素s_iは文iの重要度をあらわす．各文の重要度は関数sentenceによって計算される．関数dpkpは動的計画ナップサックアルゴリズムである．動的計画ナップサックアルゴリズムの詳細はAlgorithm2に示す．b_lとb_uはそれぞれ目的関数の下界と上界である．これらはのステップサイズの調整に利用される．関数scoreは要約xの重要度を計算する．関数countは要約xに含まれる概念の数zを返す．x_lは下界b_lに対応する解である．ラグランジュ緩和問題の劣勾配ベクトルd=(d_1,d_2,,d_m)は以下のようになる．ラグランジュ緩和された集合被覆問題に対するUmetaniらの更新式に基づき，ラグランジュ乗数は以下の更新式によって更新する．は更新幅を調整するパラメータである．更新式の基本的な考え方は，上界b_uと下界b_lの差が大きい際には更新幅を大きくしつつ，劣勾配ベクトルに従ってラグランジュ乗数を更新していくというものである．</section>
  <subsection title="貪欲法による実行可能解の復元">ラグランジュヒューリスティックは，実行不能解から実行可能解を何らかのヒューリスティックを用いて復元するものである．本論文では，以下の手続きで実行可能解を復元する．制約に違反している概念を含む文のうち，最も重要度が低いものを要約から除去する．要約がまだ制約を満たさない場合は(1)へ．要約が制約を満たした場合は，要約に含まれていない文と，要約長Kと制約を満たした要約の長さの差から，部分問題を生成し，これを貪欲法で解く．例えば，要約長が300文字であったとする．制約に違反する文を除去し，制約を満たした要約の長さが200文字だったとすると，100文字分まだ要約に文を含めることができる．そこで，まだ要約に含まれていない文を，100文字分，貪欲法を用いて要約に含めることで，実行可能解を求める．</subsection>
  <subsection title="動的計画ナップサックアルゴリズム">ナップサックモデルのデコーディングは動的計画ナップサックアルゴリズムを用いて行う．具体的なアルゴリズムはAlgorithm2に示す．[t][1]x0k=0toK	T[0][k]0i=1ton	k=0toK		T[i][k]T[i-1][k]		U[i][k]0		k=l_itoK		T[i-1][k-l_i]+s_iT[i][k]			T[i][k]T[i-1][k-l_i]+s_i			U[i][k]1			kKi=nto1	U[i][k]=1		x_i1		kk-l_i	xalgorithmicalgorithm動的計画ナップサックアルゴリズムでは，(n+1)(K+1)次元の表TとUを用意し，これに計算の過程を保存していく．表Tの要素T[i][k]は，文1から文iまでが与えられており，最大要約長がkであったときのナップサックモデルの最適解の目的関数値を格納している．表Uの要素U[i][k]は，T[i][k]の値を計算する際に，すなわちその時点での最適値を計算する際に文iを要約に利用している場合は1，そうでない場合は0を格納している．すなわち，T[n][K]まで計算し終わった時点で，最大要約長がKで文1から文nまでが使われた場合にどの文が要約に含まれるか表Uに格納されている．そのため，U[n][K]まで表を埋めたのち，U[n][K]に到達するまでの過程を逆にたどることで，ナップサックモデルの最適解を得ることができる．</subsection>
  <section title="実験">本節では提案した手法の性能を評価した結果について報告する．本節では，で述べる手法を用いて，で述べる文書集合を要約し，生成された要約をで述べる評価手法で評価する．で述べる手法が必要とするパラメータの設定についてはで述べる．結果とその考察についてはで述べる．</section>
  <subsection title="比較手法">以下の手法を比較した．RCKM提案手法．冗長性制約付きナップサックモデルを整数計画ソルバーを用いてデコードしたもの．冗長性制約付きナップサックモデルの最適解における性能を示す．ソルバーはlp_solveを用いたを用いた．．RCLM-LH提案手法．冗長性制約付きナップサックモデルを本論文で提案するラグランジュヒューリスティックを用いてデコードしたもの．提案するデコーディングアルゴリズムによって得られる近似解の性能を示す．MCMベースライン．最大被覆モデルをソルバーを用いてデコードしたもの．MCM-GRベースライン．最大被覆モデルを貪欲法を用いてデコードしたもの．KMベースライン．ナップサックモデルを動的計画ナップサックアルゴリズムでデコードしたもの．HUMAN達成しうる性能の上限を調べるため，複数の参照要約を用いて，性能の上限を求める．節で述べるコーパスのうち，レビューコーパスは1つの評価セットに対して4つの参照要約が付与されているため，参照要約同士を比較することで性能の上限を示すことが可能である．4つの参照要約があるため，それらの6つの組み合わせのうち，節で述べる評価尺度ROUGEの値が最も高いものを性能の上限として採用する．なお，節で述べるコーパスのうち，TSC-3は1つの評価セットに対して1つの参照要約しか付与されていないため，これを計算できるのはレビューのみである．RCKM-LH，MCM-GRおよびKMのデコーダはPerlで実装した．全てのプログラムはIntelXeonX5560(QuadCore)2.8~GHzCPUを2つ，64~Gバイトのメモリを搭載した計算機上で動作させた．</subsection>
  <subsection title="コーパス">上の手法を以下の2種類のコーパスによって評価した．TSC-3TSC-3コーパスは自動要約のシェアード・タスクTextSummarizationChallenge3で用いられたコーパスで，複数文書要約の評価セットを含む．要約の対象となる文書は新聞記事であり，記事は毎日新聞および読売新聞から収集されている．それぞれの評価セットは企業買収やテロなど特定のトピックに関する新聞記事から構成されている．評価セットは30セットからなる．1セットは新聞記事10記事前後からなり，1つの評価セットに含まれる記事の文字数の和は平均して約6,564文字である．評価セット全体では352記事3,587文が含まれる．それぞれの評価セットに対しては人間の作業者が短い要約と長い要約の2種類の参照要約を付与している．Hiraoらによれば，参照要約の付与に際し，作業者は要約の対象となる記事を全て読んだのち，当該記事集合にふさわしい要約を作成した．短い要約は平均して約413文字であり，要約率8000となる．にして約6%，長い要約は平均して約801文字であり，要約率にして約12%である．本実験では短いものを用いて評価を行った．評価セットごとに参照要約の長さが異なるため，要約を生成する際には参照要約と同じ長さを要約長として与え要約を生成した．すなわち，本コーパスを用いた際には，平均として，約12記事からなる約6,564文字の記事集合を入力とし，約413文字の要約を生成する，要約率約6%の要約タスクとなる．レビュー新聞記事とは異なるドメインで提案する要約モデルを評価するため，レビュー記事を用いて評価を行った．インターネット上のレビューサイトから飲食店30店舗に関するレビュー記事を収集し，これを30セットの複数文書要約の評価セットとした．1セットはレビュー記事15記事前後からなり，1つの評価セットに含まれる記事の文字数の和は平均して約2,472文字である．評価セット全体では468記事2,275文が含まれる．それぞれの評価セットに対しては4人の作業者が参照要約を付与しており，作業者は要約の対象となる記事を全て読んだのち，当該記事集合にふさわしい要約を作成した．要約長はすべて200文字を上限とした．そのため，実験において要約を生成する際には一律200文字を要約長として要約を生成した．従って，要約率は平均して8%である．本コーパスを用いた際には，平均として，約16記事からなる約2,472文字の記事集合を入力とし，200文字の要約を生成する，要約率約8%の要約タスクとなる．表にコーパスに関する統計量をまとめておく．</subsection>
  <subsection title="評価尺度">我々の提案する手法を評価するため，以下の2つの尺度を用いた．要約品質要約の品質の評価には要約の自動評価尺度であるROUGEを用いた．ROUGEの亜種のうち，ROUGE-1およびROUGE-2を評価に利用した．なお，平尾らは，参照要約のROUGE値を計算する際には，文を構成するすべての単語ではなくて，内容語のみを用いて計算を行った方が人間による評価と相関が高い結果が得られると報告している．そのため，本論文でもROUGE値を計算する際には内容語のみを用いた．生成された要約を単語に分割し品詞を付与する際にはFuchiらによる形態素解析器を利用した．ROUGE値を算出するプログラムはLinの文献に従い独自に実装した．なお，レビューコーパスについては1セットに対して複数の参照要約が付与されているため，評価の際には，当該セットに付与されているすべての参照要約に対してROUGE値を求め，最も高いROUGE値をその要約のROUGE値とした．このROUGE値の計算方針はLinの提案によるものである．これは，ある入力文書集合に対して妥当な要約は複数存在し得ると考えられることから，参照要約の中で機械による要約にとって最も近いものとのROUGE値をもってその要約の評価とするためである．要約速度要約の生成までの速度を計測した．いずれのコーパスでも，30セットすべてを要約するまでの時間を計測した．なお，要約品質の検定にはウィルコクソンの符号順位検定を用いた．多重比較となるため，全体の有意水準は0.05とした上で，p値の大きさに従って検定それぞれにおいて有意水準をホルム法で調整した．</subsection>
  <subsection title="パラメータ">本節では要約に際して必要なパラメータの設定について述べる．以下に述べるパラメータのうち，概念重要度は全ての手法が利用する．概念冗長性はRCKMおよびRCKM-LHが利用する．ステップサイズおよびイテレーションはRCKM-LHのみが利用する．</subsection>
  <subsubsection title="概念重要度">概念jおよびその重要度w_jはコーパスに合わせそれぞれ以下のように設定した．TSC-3概念jは内容語とし，その重みw_jはtf-idfに基づき，w_j=tf_jlog(Ndf_j)とした．ここで，tf_jは要約の対象となる入力文書集合中での内容語jの出現頻度，df_jは新聞記事コーパス中で内容語jを含む記事の数，Nは新聞記事コーパスに含まれる記事の総数である．新聞記事コーパスとして，2003年と2004年の毎日新聞コーパスを利用した．文を単語に分割し品詞を付与する際にはFuchiらによる形態素解析器を利用した．レビューレビューを要約の対象としたため，概念jとして評価情報を利用した．評価情報の定義とその抽出方法は西川らによるものに従った．概念jの重みw_jは当該評価情報の入力文書集合中での出現頻度を利用した．評価情報を文中から抽出する際，形態素解析にはFuchiらによる形態素解析器を，係り受け解析にはImamuraらによる係り受け解析器を，評価表現辞書は浅野らによる評価表現辞書をそれぞれ利用した．なお，本論文では内容語を概念としてレビューを対象に要約を実施する実験は行わない．西川らは，内容語を概念としてレビューを対象に要約を実施した場合，評価情報を用いた場合と比べ良好な結果を得ることができなかったと報告している．彼らはこの結果について，レビューの要約においては焦点となる情報が評価情報であるため，それを被覆の対象としなければ良好な結果が得られないと結論づけており，これは妥当な解釈であると考えられる．同様に，評価情報を概念として新聞記事を対象に要約を実施する実験も行わない．これは，予備実験として，新聞記事に付録記載の評価情報抽出を行ったところ，ほとんど評価情報が抽出されず，従って評価情報を概念として新聞記事を対象に要約を行っても意味のある結果は期待できないと考えられるためである．新聞記事においては「〜はよかった」「〜は悪かった」というような何らかの評価に関する記述があまり存在しない．そのため評価情報は新聞記事を対象として要約を実施する際に有効な概念であるとは言えない．</subsubsection>
  <subsubsection title="概念冗長性">冗長性パラメータr_jは以下の4種類を設定した．ON概念冗長性を1とする．これは，同じ概念が2回以上要約に出現することを禁じる．すなわちr_j=1である．この制約を用いた場合，同一の概念は一度しか要約中に出現することができず，そのため最大被覆問題と同様に冗長性が削減されることが期待される．最大被覆問題とこの制約を用いた冗長性制約付きナップサックモデルの差異は，前者は目的関数を利用して冗長性を削減するのに対し，後者は制約を用いて冗長性を削減することにある．KL概念jの入力文書集合中の出現頻度に，要約長Kと入力文書集合のサイズL=^n_i=1l_iの比をかけたものとする．ただし，値が小数となることが多いため，その場合は値を切り上げることとした．すなわちr_j=tf_jKLである．この制約を用いた場合，入力文書集合中での概念の出現頻度の分布が，要約長を加味した上で要約にも同程度再現されることが期待される．SR概念冗長性を，各単語の入力文書集合中での出現回数の平方根とする．KLと同様，値が小数となることが多いが，その場合は値を切り下げることとした．これはKLではr_jの値が1未満になることがあるのに対し，平方根を取る場合はその恐れがないためである．すなわちr_j=tf_jである．この制約はKLと異なり要約長の影響を受けない．また，KLに比べ冗長性に寛容である．RF概念冗長性を，参照要約に含まれる概念の数とした．これは，概念冗長性が理想的に設定された場合の性能を示している．なお，レビューコーパスについては複数の参照要約が存在するため，同一の概念については複数の参照要約の平均を取り，小数となった場合は値を切り上げることとした．これらは2つのコーパスで共通である．</subsubsection>
  <subsubsection title="ステップサイズ">は最初は1とし，以降，ラグランジュ乗数がアップデートされた回数の逆数とした．すなわち，最初のアップデートの際はは1であり，次のアップデートの際は12，さらに次のアップデートの際には13となる．</subsubsection>
  <subsubsection title="イテレーション">ラグランジュヒューリスティックによるデコーディングの際にはイテレーションの回数Tを調整することができる．イテレーションの回数は10回と100回とし，それぞれRCKM-LH(10)とRCKM-LH(100)として示す．</subsubsection>
  <subsection title="結果と考察">要約品質の評価を表に，要約時間の評価を表に示す．TSC-3コーパスにおける評価の結果から述べる．まず，RCKMとMCM，KMの差異に目を向ける．RCKMの中ではRFが最も高いROUGE値を得ており，次いでSRという結果となった．RFおよびSRはその最適解においてMCMを有意に上回っていた．提案するラグランジュヒューリスティックによるデコーディングを用いた場合RCKM-LHでは，イテレーション回数が10回の場合でも100回の場でも，RFはMCMを有意に上回っている一方，SRはMCMと有意な差がなかった．表に示すように，提案するデコーディング法はソルバーによるデコーディングと比べ高速に要約を生成できており，MCMと同水準以上の要約を高速に生成できることがわかる．MCMとMCM-GRを比べると，貪欲法はソルバーに比べ高速にデコーディングを行うことができるものの，MCM-GRの方が有意にROUGE値が低く，探索誤りが生じていることがわかる．KMとMCMの間に有意差はなかったものの，全体としてMCMがより高いROUGE値を示した．提案する要約モデルRCKMは，冗長性パラメータをRFあるいはSRとした際にMCMに比べ優れている．この理由は，参照要約は単語のレベルにおいてある程度の冗長性を持っているためである．図は，TSC-3コーパスに含まれる参照要約の1つである．同一の内容語はゴシック体として示してある．図から，明らかに参照要約は単語のレベルにおいて冗長性を持つことがわかる．図はTSC-3コーパスを用いた実験における冗長性の分布である．縦軸に内容語の種類，横軸に同一の参照要約中での出現頻度をとりプロットした．点は，参照要約，節で述べた方法によって設定された冗長性パラメータ，および各手法によって実際に生成された要約における冗長性の分布を示している．例えば，TSC-3コーパスに含まれる2093種類の内容語は同一の参照要約に一度しか出現しない．一方，10種類の内容語は，同一の参照要約に10回以上出現することがある．図および図が示すように，ある1つの参照要約において，同一の単語が複数回出現することは何ら珍しいことではない．提案する冗長性制約付きナップサックモデルRCKMは，冗長性パラメータを通じ，生成する要約に一定の冗長性を許容することができる．一方，最大被覆モデルMCMは冗長性を忌避する．実際に図が示すように，MCMが生成する要約は参照要約に比べ冗長性が低い．そのため，図のように1つの参照要約において同一の単語が複数回出現するという現象を十分に捉えることができない．それに対し，ナップサックモデルKMが生成する要約は高い冗長性を持つ．図が示すように，要約中に4回以上出現する単語の種類が参照要約に比べて多く，特に10回以上出現する単語が42種類存在している．このように過度に冗長な要約を生成する性質は複数文書要約にとっては好ましいものではない．図を見ると，冗長性パラメータSRは参照要約の冗長性に近い冗長性を有する要約を実現できている．全体的な傾向として，ナップサックモデルでは，要約中にある回数だけ出現する単語の種類は左から右に向かってなだらかに減少していく．これは，要約中に1度しか出現しない概念の種類と，何度も出現する概念の種類にあまり差がないことを示しており，すなわち，何度も出現する概念の種類が相対的に多いことを示している．一方，最大被覆モデルは左から右に向かって急峻な勾配で種類が減少していく．これは，要約中に1度しか出現しない概念の種類が相対的に多いことを示している．参照要約の冗長性は，これらナップサックモデルと最大被覆モデルの中間を取るように推移しており，冗長性パラメータSRによって生成された要約の冗長性も，参照要約の冗長性に近い位置で推移している．このように参照要約に近い冗長性を再現できたため，SRは良好な性能を示すことができたものと考えられる．ナップサックモデルのような過度の冗長性は複数文書要約において問題となる一方，同一の単語，あるいは関連する単語が前後の文に出現する性質は，自動要約の分野においてLexicalchainと呼ばれており，重要文抽出の際の重要な手がかりとして利用されている．RCKMはこの性質を捉えることができたということもできよう．テキスト一貫性に関する研究においても，人手によって書かれたテキストにおいて同一の単語が同一のテキストに複数回出現するという性質は利用されている．テキストの一貫性を評価する手法の1つであるEntitygridは，連続する2つの文における，単語の意味役割の変化を特徴量として用いており，同一の単語が同一のテキストに複数回出現するという仮定を置いている．参照要約は人手によって書かれたものであるため，テキスト一貫性の観点からこの性質を持っていると考えることができる．このことから，冗長性パラメータrはテキスト一貫性の観点から設定することもできよう．次に，冗長性パラメータについて述べる．RCKMの中ではRFが最も良好な性能を示し，ついでSR，KL，ONとなった．参照要約の冗長性を模倣した場合が最良の結果を得たことから，冗長性の設定はRCKMにとって重要であると言える．冗長性パラメータrを正確に設定するためには，入力文書集合と参照要約の組から回帰モデルを構築し，各単語の参照要約における適切な出現頻度を予測することも考えられよう．ONに目を向けると，ONの生成した要約の品質はSRやKLに比べて著しく悪い．これは，上に述べたように，テキスト一貫性の観点から説明できる．同一の単語は一度しか要約に出現できないというONの制約は，上に述べた性質を持ったテキストを生成することを許さない．このため一貫性を欠いたテキストを生成してしまい，これは人間による要約を模倣するという観点からは大きな問題がある．SRとKLを比較すると，有意にSRのROUGE値が高かった．図のConst-KLが示すように，KLによる冗長性の制約は参照要約の冗長性をうまく模倣しているものの，2回以上の出現を許す単語の種類が参照要約に比べて少ない．TSC-3コーパスの評価セットの要約率は平均して6%前後であるため，KLは要約長に影響され冗長性について厳しい制約を要約に課す．このため，Summ-KLが示すように，要約に十分な冗長性を許すことができず，SRに比べてROUGE値において劣後したものと考えられる．一方，Const-SRは全体的に高い冗長性を許すものとなっているが，実際に生成された要約の冗長性Summ-SRは参照要約の冗長性に近い．SRによって生成された要約を確認すると，高い冗長性の原因となり要約の品質の低下を招く概念の冗長性を抑制しつつ，概念重要度に従って他の概念を要約に組み込んでおり，これが良好なROUGE値を得た理由と考えられる．次にレビューにおける評価の結果について述べる．RCKMとMCM，KMの差異について目を向けると，KMはMCMと比べ有意にROUGE値が低かった．TSC-3での評価と異なり，MCMとMCM-GRの間に有意な差はなかった．また，MCMとRCKMの全ての手法の間にも有意な差はなかった．RCKMの中でも，冗長性パラメータによる有意な差はなかった．一方，TSC-3での評価と同様に，表が示すように提案するデコーディング法はソルバーと比べ高速に要約を生成できており，MCMと同水準の要約を高速に生成できることがわかる．HUMANに対してはいずれの手法も及ばなかった．これには2つの理由があると考えられる．1つは概念重要度の設定である．今回は要約対象の文書集合中での評価情報の頻度を概念重要度として用いたが，参照要約を用いて概念重要度を学習することでより良好なROUGE値を得られる可能性がある．もう1つは文の選択のみで要約を作成することの限界である．前述したように，レビューコーパスの参照要約は人間によって自由に記述されているため，文の選択だけでは参照要約と同水準の要約に到達することは難しいと考えられる．この点の解決のためには，文短縮など，文を書き換える処理を要約の過程に加える必要があろう．TSC-3とレビューを比較すると，前者においてはRCKMがMCMを上回る性能を持つものの，後者においてはそれらの間に差がない．これらは新聞記事の要約とレビュー記事の要約の差異を端的に表している．前者は単語を被覆の対象としているため，上に示したように，1つの要約に複数の単語が含まれることを許すことによって，より高いROUGE値を得ることができる．一方，後者が被覆の対象とするものは評価情報であり，ある特定の評価情報は1つの要約に1つだけ入っていれば十分である．これは，TSC-3においては劣った要約品質を示したONが，レビューにおいては他の手法と同水準の要約品質を示していることからもわかる．図は，レビューコーパスに含まれる評価情報を，縦軸に評価情報の種類，横軸に同一の参照要約中での出現頻度をとりプロットしたものである．図と比較するとその差は明らかであり，レビューでは参照要約においてある特定の評価情報は1度しか出現しないことがほとんどである．最後に，提案したラグランジュヒューリスティックによる近似解法の近似精度についても述べておく．近似精度を表に示す．数値は，ソルバーによって得られた最適解の目的関数値を100としたときの，近似解法による解の目的関数値を百分率で示したものである．計算にあたっては，いずれも冗長性パラメータはSRとし，30セットそれぞれの近似精度の平均を取った．表が示すように，提案する近似解法は良好な近似精度を持つことがわかる．</subsection>
  <section title="まとめ">本論文では，複数文書要約において重要なモデルである最大被覆モデルのデコーディングを高速化することを企図し，要約に含めるべき単語数を直接制御する冗長性制約付きナップサック問題に基づく要約モデルを提案した．本論文の新規性および貢献を以下にまとめる．冗長性制約付きナップサック問題に基づく要約モデルは，その最適解において，最大被覆問題を用いた要約モデルに対して，ROUGEにおいて同等以上の性能を持つことを示した．ラグランジュヒューリスティクスに基づくデコーディング法によって得られる近似解は，最大被覆問題の最適解とROUGEにおいて同等であることを示した．提案手法のデコーディング速度は，整数計画ソルバーによる最大被覆問題のデコーディング速度より100倍以上高速であることを示した．今後の課題としては，上で述べたように冗長性パラメータをテキスト一貫性の観点から推定することを検討している．また，冗長性パラメータを入力文書集合と参照要約の組から推定することも検討している．</section>
  <section title="評価情報の抽出方法">まず，評価情報について述べる．西川らの提案と同様に，本論文では，評価情報を評価属性aspectと評価極性polarity-1,0,1の組e=(aspect,polarity)として考える．評価属性は，何らかの対象が評価される際の観点を示す．評価極性は，対象が評価属性に関してポジティブな評価をされているときに1，ネガティブな評価をされているときに-1，どちらとも言えないときに0の3値を取るものとする．一例として，「このデジタルカメラは画質がよい」という表現を考える．この表現の評価属性は「画質」である．また，評価表現「よい」はポジティブな評価であることから，評価極性は1となる．そのため，この表現から評価情報e=(画質,1)が得られる．評価情報は以下のように抽出する．文に係り受け解析を行う．評価表現とその評価極性の組を格納した辞書（評価表現辞書）と係り受け解析の結果を照合し，評価表現とその評価極性を得る．係り受け木で，評価表現に係っている名詞を評価属性とする．得られた評価属性と評価極性を出力する．document</section>
</root>
