<?xml version="1.0" ?>
<root>
  <title>文節重要度と係り受け整合度に基づく日本語文簡約アルゴリズム</title>
  <author>小黒玲尾関和彦張玉潔高木一幸</author>
  <jabstract>これまで主に検討されてきた文書要約手法は，文集合から重要文を抽出するものである．この方法によれば，段落などを要約した結果として誤りのない文の集合が得られる．しかし，目的によっては更に要約率を上げるため，または段落などの単位での要約が不適当であるときなど，一文毎の簡約が必要となる場合がある．このような文書要約手法では，簡約文が日本語として自然な文であることが重要ppである．そこで本論文では，文の簡約を「原文から，文節重要度と文節間係り受け整合度の総和が最大になる部分文節列を選択する」問題として定式化し，それを解くための効率の良いアルゴリズムを提案する．本稿の定式化では簡約文の評価に文節間の係り受け整合度が用いられていることから，簡約結果は適切な係り受け構造を持つことが期待できる．したがって本手法を用いることにより，自然で正確な簡約文を高速に生成できる可能性がある．このアルゴリズムを実用するには，文節重要度と係り受け整合度の適切な設定が不可欠であるが，本稿ではこれらについては議論せず，アルゴリズムの導出と計算効率，実装法などに重点を置いて報告する．</jabstract>
  <jkeywords>文書要約，構文解析，係り受け構造，文節重要度，文簡約</jkeywords>
  <section title="はじめに">電子化テキストの爆発的増加に伴って文書要約技術の必要性が高まり，この分野の研究が盛んになっている．自動要約技術を使うことにより，読み手の負担を軽減し，短時間で必要な情報を獲得できる可能性があるからである．従来の要約技術は，文書全体もしくは段落のような複数の文の中から，重要度の高い文を抽出することにより文書全体の要約を行うものが多い．このような方法で出力される個々の文は，原文書中の文そのものであるため，文間の結束性に関してはともかく，各文の正しさが問題になることはない．しかし，選択された文の中には冗長語や不要語が含まれることもあり，またそうでなくとも目的によっては個々の文を簡約することが必要になる．そのため，特にニュース字幕作成を目的として，表層文字列の変換を行ない，1文の文字数を減らすなどの研究が行われている．また，重要度の低い文節や単語を削除することによって文を簡約する手法も研究されており，単語重要度と言語的な尤度の総和が最大となる部分単語列を動的計画法によって求める方法が提案されている．しかし，この方法ではtrigramに基づいた局所的な言語制約しか用いていないので，得られた簡約文が構造的に不自然となる可能性がある．削除文節の選択に係り受け関係を考慮することで，原文の部分的な係り受け構造の保存を図る方法も研究されているが，この方法ではまず一文全体の係り受け解析を行い，次に得られた構文木の中の冗長と考えられる枝を刈り取るという，二段階の処理が必要である．そのため，一つの文の係り受け解析が終了しなければ枝刈りが開始できず，枝刈りの際に多くの情報を用いて複雑な処理を行うと，文の入力が終了してから簡約された文が出力されるまでの遅延時間が長くなる可能性がある．本論文では，文の簡約を「原文から,文節重要度と文節間係り受け整合度の総和が最大になる部分文節列を選択する」問題として定式化し，それを解くための効率の良いアルゴリズムを提案する．この問題は，原理的には枚挙法で解くことが可能であるが，計算量の点で実現が困難である．本論文ではこの問題を動的計画法によって効率よく解くことができることを示す．文の簡約は，与えられた文から何らかの意味で``良い''部分単語列あるいは部分文節列を選択することに尽きる．そのとき，削除/選択の単位として何を選ぶか，選ばれる部分単語列あるいは部分文節列の``良さ''をどのように定義するか，そして実際の計算をどのように行うか，などの違いにより，種々の方式が考えられる．本論文では，削除/選択の単位として文節を採用している．この点は，三上らの方法と同じであるが，一文を文末まで構文解析した後で枝刈りを行うという考え方ではなく，部分文節列の``良さ''を定量的に計るための評価関数を予め定義しておき，その基準の下で最適な部分文節列を選択するという考え方を採る．その点では堀らの方法に近いが，削除/選択の単位がそれとは異なる．また評価関数の中に二文節間の係り受け整合度が含まれているので，実際の計算は係り受け解析に近いものになり，その点で堀らの方法とは非常に異なったものとなる．さらに，このアルゴリズムでは文頭から係り受け解析と部分文節列の選択が同時に進行するので，一つの文の入力が終了してから，その文の簡約文が出力されるまでの遅延時間を非常に短くできる可能性がある．オンラインの字幕生成のような応用では，この遅延時間はできるだけ短い方が良い．以下では，あらためて文簡約問題の定式化を行い，それを解くための再帰式とアルゴリズム，および計算量について述べる．そして，最後に文の簡約例を掲げ，このアルゴリズムによって自然な簡約文が得られることを示す．</section>
  <section title="問題の定式化">文節を削除/選択の単位として行う文の簡約は，原文からできるだけ``良い''部分文節列を選択することであると考えることができる．この問題を明確に定式化するためには，文節列の``良さ''を計る評価関数が必要である．このような評価関数は，理想的には，文脈を考慮した上で原文の意味を理解し，その意味を部分文節列がどの程度保つかという観点から定められるべきものであろう．しかし，そのような評価関数を構成することは現時点では困難である．そもそも，文の``意味''とは何かということさえ，現時点で明確に定義づけることは困難と思われる．そこで，本研究では，各文節の重要度と二文節間の係り受け整合度という限られた情報のみを用いて，現実的に定義や計算ができるようなアプローチを採る．すなわち，文の簡約においては，簡約された文が原文の持つ重要な情報をできるだけ保つこと，簡約された文ができるだけ文法的に良い構造を持つこと．の２つが重要であることを考慮し，ここでは，部分文節列の``良さ&quot;を計る評価関数を，a),b)に対応した２つの評価関数の和として以下のように定義する．まず，原文を文節列としてw_0w_1w_M-1と表し，その中の長さl/の部分文節列w_k_0w_k_1w_k_l-1を考える．もし，各文節w_mの重要度を表す関数q(m)が与えられているとすると，この部分文節列の重要度はそれらの総和_i=0^l-1q(k_i)で計ることができよう．もちろん，他の定義も可能であるが，ここでは，これを部分文節列の重要度を計る評価関数として採用する．また，文節w_mが文節w_nに係るときの係り受け整合度p(m,n)が与えられているとすると，このような係り受け整合度の総和が大きい値となる係り受け構造が存在するような文節列は，日本語文として見たとき，文法的に``良い''文節列であると考えられる．文節列w_k_0w_k_1w_k_l-1上の係り受け構造は，係り文節番号を受け文節番号に対応させる写像c:k_0,k_1,,k_l-2k_1,k_2,,k_l-1displaymathによって表される．ただしcは後方単一性:k_m&lt;c(k_m)非交差性:m&lt;nならば	[c(k_m)k_nc(k_n)c(k_m)]を満たす必要がある．本研究では，写像cを用いて，文節列w_k_0w_k_1w_k_l-1の文法的な``良さ''を_c_i=0^l-2p(k_i,c(k_i))で定義することとする．ここで，最大化は可能な全ての係り受け構造に対して行う．以上のことから，本論文では文節列w_k_0w_k_1w_k_l-1の``良さ''を計る評価関数gを次のように定義する:g(k_0,k_1,...,k_l-1)=.displaymath評価関数gを用いると，M文節からなる原文をN文節からなる文に簡約する問題は次のように述べることができる．文簡約問題\\文節列w_0w_1w_M-1の部分文節列w_k_0w_k_1w_k_N-1(0k_0&lt;k_1&lt;&lt;k_N-1M-1)の中で，関数g(k_0,k_1,,k_N-1)が最大になるものを求めよ．与えられた原文の部分文節列の総数は有限である．また，各部分文節列上の係り受け構造の総数も有限である．したがって，上の文簡約問題は，原理的には枚挙法で解くことができるが，計算量の点で現実的でない．本論文では，動的計画法の原理に基づき，この問題を効率的に解くアルゴリズムを導出する．評価関数gの定義には，文節重要度qと係り受け整合度pの２つの関数が含まれている．これらの関数をどのように定義するかは実際の応用においては重要な問題であるが，本論文ではこれについては議論しない．しかし，文節重要度qの定め方については，例えばのような方法が考えられ，係り受け整合度pの定め方については係り受け解析の分野で研究されているなどの方法が利用できると考えられる．3節で導かれるアルゴリズムは，これらの関数の定義には依らない．二文節間の係り受け整合度の総和は，従来，係り受け解析にも用いられている評価関数であり，その意味で本手法による簡約文は，係り受け整合度pが適切に設定されていれば，原文の部分的な係り受け構造を保った自然な係り受け構造を持つことが期待できる．しかし，それにより原文の意味がどの程度保たれるかについては，最終的には人間の簡約結果と比較するなどの評価が必要となる．本論文では，そこまでは立ち入らず，上のような評価関数を用いて問題を定式化したとき，それを現実的な計算量で解くアルゴリズムが構成できることを示すことに重点を置いている．</section>
  <section title="再帰式とアルゴリズム"/>
  <subsection title="再帰式">文簡約問題，すなわち関数g(k_0,k_1,,k_N-1)の最大化問題を解くために，その``部分解とそれらの間の関係''を考える．まず，先頭文節をw_mに，末尾文節をw_nに，文節列長をl/に固定したときの最大化を考え，その最大値を表す関数fを以下のように定義する．最大値関数f[f(m,n,l)=_m=k_0&lt;k_1&lt;&lt;k_l-1=ng(k_0,k_1,,k_l-1)]definitionそうするとf(m,n,l)は次の再帰式を満たすことが示される．証明は付録とする．再帰式m=nのとき:(lの動く範囲:l=1のみ)m&lt;nのとき:(lの動く範囲:2ln-m+1)l=2のとき*1zhl=3のとき		f(m,n,l)=				.eqnarray*equation1*1zhl4のとき		f(m,n,l)=	&amp;&amp;				.eqnarray*equation1thesis</subsection>
  <subsection title="アルゴリズムの構成">再帰式は2;;l/のとき，l'&lt;,l/となるf(m,,l')とf(,n,l-l')の全てが既に計算されていれば，高々3つの変数に関する最大化問題を解くことによりf(m,n,l)が計算できることを表している．すなわち式()より，f(,,1)は，入力文節の重要度から直接計算できる．また，式()より2文節の重要度とその間の係り受け整合度の和から，f(,,2)が計算できる．これらから始めて，l=3のときはf(,,3)を2変数m',n'が制約条件を満たす範囲で最大化を行ない，4lでは3変数m',n',l'/が制約条件を満たす範囲で最大化を行なうという再帰的な処理によって，f(m,n,l)を計算することができる．以上の事実に注意すると，計算済のf(,,)の値を図のようなテーブルの升目に順次埋めていくアルゴリズムが構成できる．図にはf(m,n,l)を埋める場合を示した．再帰式によると，f(m,n,l)の計算は，その左の領域f(m,,1)f(m,,l-1)からf(m,n',l')を，その下の領域f(,n,1)f(,n,l-1)からf(m',n,l-l')を選択する組合わせの中から，それぞれの持つfの値と両者の係り受け構造間の係り受け整合度の総和が最大となるようなm',n',l'/を探索することで行なわれていく．このとき，係り文節w_mは必ず受け文節w_nより文頭側にあること，文節列w_mw_m+1w_nを簡約する場合，簡約後の部分文節列の長さは原文節の長さより大きくなることがないことから，変数には以下のような制約が課せられる．m;;nm=nのときl=1m&lt;nのとき1&lt;l;;n-m+1これを図示したものが図である．また，ここでは1NMを満たす任意のNに対して最適解が探索できる領域を考えているが，Nの最大値N_maxがあらかじめ定まっているときは，l/の動く範囲を1ln-m+1,,N_maxに制限できる．したがってN_max&lt;Mの場合には探索領域はさらに小さくてすみ，計算量と記憶量を減らすことができる．図のテーブルの升目を埋める順序については，f(m,n,l)を計算する際にf(m,n',l')とf(m',n,l-l')が制約条件の範囲で全て計算済であるという条件さえ満たしていればよいので，その順序には大きな自由度がある．変数l,m,nを動かすとき，アルゴリズムのように最外ループをnに関するループとすると，入力文節に同期した処理が可能なアルゴリズムとなる．すなわち，文頭文節からある文節までが入力されたとき，そこまでの情報に基づいてできる計算は，それより後の文節に関係なく済ませることができる．そして，もし必要ならば，その時点で3.3に述べるバックトレースを行い，そこまでの入力に対する簡約文を出力することができる．また，最外ループをl/に関するループとすれば，そのループの第lステップの処理が終わった時点で，N=lとしてバックトレースが可能になるので，文節数1から順に求めたい文節数までの簡約文を出力するアルゴリズムが構成できる．再帰式の実行*5mm=*3mm=*3mm=*3mm=*3mm=*3mm=*3mm+forn:=0toM-1+beginform:=ndownto0do+beginif(m=n)thenf(m,m,1):=q(m);`[10zw]式()else+beginforl:=2ton-m+1do+beginif(l=2)thenf(m,n,l):=...;`[10zw]式()elseif(l=3)thenf(m,n,l):=...;`[10zw]式(a,b)elsef(m,n,l):=...;`[10zw]式(a,b,c)end;-end;-end;-end;tabbingalgorithm</subsection>
  <subsection title="バックトレース">アルゴリズム１の計算結果から最適部分文節列を構成することを，ここでは「バックトレース」という．ここで用いるバックトレースの方法はの手法に類似したものであり，形式的な証明も可能であるが，ここでは，考え方の概略とアルゴリズムを示すにとどめる．まず「係り受け構造の分解」について述べる．v_1v_2v_Kを文節列とし，その上の係り受け構造cを考える．cにおいて，末尾の文節v_Kに係る最も文頭側の文節をv_kとすると，cはv_1v_2v_k上の係り受け構造とv_k+1v_2v_K上の係り受け構造に分解できる．ただし，v_kがv_Kに係るという情報を加えておく必要がある．付録の証明から明らかなように，f(m,n,l)に対する再帰式の導出においては，この事実が以下のように利用されている．f(m,n,l)を計算するためには，w_mから始まり，w_nで終わる長さlの部分文節列上の係り受け構造を考慮する必要がある．上に述べたことから，そのような係り受け構造は，w_nに係る最も文頭側の文節をw_n^とするとき，w_nから始まりw_n^で終わる長さl^の部分文節列上の係り受け構造と，ある文節w_m^から始まりw_nで終わる長さl-l^の部分文節列上の係り受け構造に分解できる．ただし，w_n^がw_nに係るという情報を加えておく必要がある．さて，再帰式の証明が示すように，f(m,n,l)を求めるためには，評価関数gを，上のように分解した部分文節列，および係り受け構造に関して最大化すればよい．それは，f(m,n^,l^)+f(m^,n,l-l^)+p(n^,n)displaymathを，l^，m^，n^に関して最大化することに帰着する．最大値を与えるこれらの変数の値を再びl^，m^，n^と表せば，以上のことから，f(m,n,l)を与える最適部分文節列Aはf(m,n^,l^)を与える最適部分文節列Bとf(m^,n,l-l^)を与える最適部分文節列Cの連接で与えられること，またA上の最適係り受け構造はB上の最適係り受け構造とC上の最適係り受け構造を併せたものに，w_n^がw_nに係るという情報を加えたものになることが分かる．また，m=nの場合はl=1しか許されず，f(m,n,l)を与える最適部分文節列は``w_m''となる．したがって，アルゴリズムの各ステップで最大値を与えるl^，m^，n^の値(最適分割点)を記憶しておけば，アルゴリズムの終了後，任意の長さの簡約文と，必要ならばその上の係り受け構造を再帰的に得ることができる．最適分割点はバックトレースのための，いわゆるバックポインタの役割を果たす．実際の計算では，アルゴリズムの各ステップにおいて最適分割点を記憶するための変数bp[m,n,l]を用意する．最適分割点は再帰式中の場合に応じて，次のように設定される．m',n',l'/は再帰式の中で最大値を与えるそれらの変数の値を表す．最適分割点m=nの場合	何も記憶する必要がない．m&lt;nの場合definition与えられた文節列から1NMの範囲で任意に指定した長さNの最適部分文節列を探索するには，まず，最も評価値の高いf(m_o,n_o,N)を見つけることから始める．そして，このm_o,n_o,Nを出発点として，アルゴリズムで示す再帰関数を用いて最適部分文節列が得られる:(m_o,n_o)&amp;:=&amp;_m,nf(m,n,N);最適部分文節列&amp;:=&amp;out(m_o,n_o,N)eqnarray*ここでは，最適分割点が一意に定まる場合を考えているが，これが複数個存在する場合には，その全てを記憶し，そのそれぞれに対して最適部分文節列を求めればよい．異なる最適分割点から，同じ最適部分文節列が得られる可能性があるが，この場合，これらの最適部分文節列上には複数の最適係り受け構造が存在している．バックトレース(は文字列の連接を表す)*5mm=*3mm=*3mm=*3mm=*3mm=*3mm=*3mm+functionout(m,n,l):charstring;+beginif(m=n)thenout:=``w_m'';elsebegin+l^:=bp[m,n,l].lp;n^:=bp[m,n,l].np;m^:=bp[m,n,l].mp;out:=out(m,n',l')out(m',n,l-l');-end;-end.tabbingalgorithmここで，本アルゴリズムにおける最適分割点と簡約文の係り受け構造の対応について述べる．bp[m,n,l]は文節列w_mw_nを長さl/に簡約するときの最適分割点であるが，再帰式の証明(付録)からわかるように，n'=bp[m,n,l].npは簡約結果においてw_nに係る文節の中で最も文頭側にあるものの番号である．したがって，w_n'はw_nに係ることがわかる．これを再帰的に繰り返せば，簡約文中の全ての文節の係り先がわかる．すなわち，アルゴリズムを用いてバックトレースを行なうとき，n'=bp[m,n,l].npならばc(n')=nであることを記憶し，まとめて出力すれば，簡約文中の全ての文節に対するcの値，つまり係り受け構造を知ることができる．</subsection>
  <subsection title="計算量">まず，アルゴリズムにおける加算回数について考察する．計算ステップm,n,lにおける加算回数をF(m,n,l)とするとf(m,n,l)に対する再帰式より，次のことが容易に分かる．l=1のとき:		F(m,n,1)&amp;=&amp;0[10zw](式(1)より)	eqnarray*l=2のとき:		F(m,n,2)&amp;=&amp;2[10zw](式(2)より)	eqnarray*l=3のとき:		F(m,n,3)&amp;=&amp;2[18zw](式(3a)より)	&amp;&amp;+(n-m-1)+1[10zw](式(3b)より)	&amp;=&amp;n-m+2	eqnarray*l4のとき：		F(m,n,l)&amp;=&amp;2[23.5zw](式(4a)より)	&amp;&amp;+2(l-3)(		)[10zw](式(4b)より)	&amp;&amp;+(n-m-l+2)+1[14zw](式(4c)より)	&amp;=&amp;(l-3)(n-m-l+3)(n-m-l+2)+(n-m-l+5)	eqnarray*総加算回数A(M)はF(m,n,l)を0mnM-1，1ln-m+1について加え合わせたものになるが，m=nのときはl=1であり，そのときF(m,n,l)=0であるから，A(M)&amp;=&amp;_0m&lt;nM-1;_2ln-m+1F(m,n,l)eqnarray*となる．詳細は省略するが，この右辺を計算すると，A(M)&amp;=&amp;1360(M-3)(M-2)(M-1)M(M+1)(M+2)&amp;&amp;+124(M-4)(M-3)(M-2)(M-1)&amp;&amp;+23(M-3)(M-2)(M-1)&amp;&amp;+16(M-1)(M-2)(M+9)&amp;&amp;+(M-1)Meqnarray*が得られる．同様の計算により，総比較演算回数C(M)はC(M)&amp;=&amp;1720(M-3)(M-2)(M-1)M(M+1)(M+2)&amp;&amp;+112(M-4)(M-3)(M-2)(M-1)&amp;&amp;+12(M-2)(M-2)(M-1)eqnarray*で与えられる．したがって計算量のオーダはA(M),C(M)共にO(M^6)となる．これはかなり大きな計算量のように見えるが，最高次の係数が小さいこととMは高々40程度までを考えておけばよいことから，計算が困難なほど大きな値にはならない．実際，M=40の場合，加算回数と比較演算回数は表で示したように，A(40)1.110^7,C(40)5.410^6であり，アルゴリズムをCで実装しUltraSPARC-IIi(270MHz)上で処理したときの処理時間は，1秒以内である．また，アルゴリズムの実行時間は，これに比べて無視できる程度である．</subsection>
  <section title="簡約例">本手法の評価は今後の課題であるが，アルゴリズムの動作を示すため，文節重要度と係り受け整合度を仮に与えて実行した例を2つ示す．簡約文の係り受け構造もによる括弧表記を用いて示している．50zw文節数:簡約結果例1原文&lt;&lt;また&gt;&lt;&lt;&lt;&lt;&lt;袖や&gt;袖口&gt;ポケット口などが&gt;&lt;油汚れで&gt;&lt;変色を&gt;おこす&gt;ことも&gt;あります&gt;8:&lt;&lt;&lt;&lt;&lt;&lt;袖や&gt;袖口&gt;ポケット口などが&gt;&lt;油汚れで&gt;&lt;変色を&gt;おこす&gt;ことも&gt;あります&gt;7:&lt;&lt;&lt;&lt;&lt;&lt;袖や&gt;袖口&gt;ポケット口などが&gt;&lt;変色を&gt;おこす&gt;ことも&gt;あります&gt;6:&lt;&lt;&lt;&lt;&lt;袖や&gt;袖口&gt;ポケット口などが&gt;&lt;変色を&gt;おこす&gt;ことも&gt;5:&lt;&lt;&lt;&lt;袖や&gt;袖口&gt;ポケット口などが&gt;&lt;変色を&gt;おこす&gt;4:&lt;&lt;&lt;袖口&gt;ポケット口などが&gt;&lt;変色を&gt;おこす&gt;3:&lt;&lt;&lt;変色を&gt;おこす&gt;ことも&gt;2:&lt;&lt;変色を&gt;おこす&gt;例2原文&lt;&lt;&lt;年齢は&gt;&lt;まだ&gt;十四だが&gt;&lt;&lt;数えきれぬほど&gt;&lt;&lt;日本の&gt;舞台を&gt;踏んだので&gt;&lt;日本語は&gt;ぺらぺらだそうだ&gt;8:&lt;&lt;&lt;年齢は&gt;&lt;まだ&gt;十四だが&gt;&lt;&lt;&lt;日本の&gt;舞台を&gt;踏んだので&gt;&lt;日本語は&gt;ぺらぺらだそうだ&gt;7:&lt;&lt;&lt;年齢は&gt;十四だが&gt;&lt;&lt;&lt;日本の&gt;舞台を&gt;踏んだので&gt;&lt;日本語は&gt;ぺらぺらだそうだ&gt;6:&lt;&lt;十四だが&gt;&lt;&lt;&lt;日本の&gt;舞台を&gt;踏んだので&gt;&lt;日本語は&gt;ぺらぺらだそうだ&gt;5:&lt;&lt;&lt;&lt;日本の&gt;舞台を&gt;踏んだので&gt;&lt;日本語は&gt;ぺらぺらだそうだ&gt;4:&lt;&lt;&lt;舞台を&gt;踏んだので&gt;&lt;日本語は&gt;ぺらぺらだそうだ&gt;3:&lt;&lt;踏んだので&gt;&lt;日本語は&gt;ぺらぺらだそうだ&gt;2:&lt;&lt;日本語は&gt;ぺらぺらだそうだ&gt;verbatimminipagefootnotesize本アルゴリズムで必要とされる係り受け整合度は，の係り受けペナルティに-1を乗じたものとした．ここで定義されているペナルティ関数は学習コーパス中の係り受け距離の頻度分布を元に作成されている．また文節重要度は，主部/述部や名詞/動詞を含む文節に形容詞や動作の程度や目的を表す文節より大きい値文末の動詞には大きな値形式名詞には小さな値を人手で設定した．この例における具体的な値を表に示す．例にあげた文はの手法で正しく係り受け解析できたものである．簡約文の文節数Nを原文の文節数Mに等しく設定すると簡約文は原文そのものしかあり得ない．したがって，その場合には本アルゴリズムは原文の係り受け解析のみを行なうことになり，その結果はの手法によるものと一致する．実際に簡約文を出力するためには，その長さNを指定する必要がある．これは，現実の場面で文章全体をどの程度に圧縮したいかという要求と簡約文の品質を考え合わせて決めるものであるが，本手法を人が文を簡約するときの支援システムとして使用する場合にはNの値を順次変化させ，それに応じて得られる簡約文の中から人が適切なものを選ぶという使い方も考えられる．また，評価関数の値を利用して，「できるだけ短く」と「できるだけ情報を保つ」という相反する要求のバランスを自動的に取ることも考えられるが，それは今後の問題である．</section>
  <section title="おわりに">文節重要度と係り受け整合度に基づいて，効率的に文の簡約を行なうアルゴリズムを提案した．このアルゴリズムは簡約文の係り受け構造も同時に出力できるので，簡約文を引き続き他言語に翻訳するときなどにも有用である．計算量は原文文節数の6乗のオーダとなるが，各変数の制約条件のために現実的な文節数に対して実行可能なものとなっている．また，最外ループを制御する変数の選び方には自由度があるため，即答性が求められる場合には文節の入力と同期して計算を進めるようにアルゴリズムを構成することが可能である．今後は，文節重要度や係り受け整合度の設定の仕方が簡約結果に与える影響や，文節重要度から定まる評価関数値と係り受け整合度から定まる評価関数値の適切な重み付けなどについて検討し，簡約手法としての評価を行なう予定である．</section>
  <section title="再帰式の証明">最も一般的な式(a)(c)の場合について証明する．他の場合については，より容易に証明できる．f(m,n,l)&amp;=&amp;_m=k_0&lt;k_1&lt;&lt;k_l-1=ng(k_0,k_1,,k_l-1)&amp;=&amp;_m=k_0&lt;k_1&lt;&lt;k_l-1=n_c_i=0^l-2p(k_i,c(k_i))+_i=0^l-1q(k_i)&amp;=&amp;_m=k_0&lt;k_1&lt;&lt;k_l-1=n&amp;&amp;.&amp;&amp;に係る文節		の中で最も左にあるもの&amp;&amp;&amp;=&amp;.&amp;=&amp;.&amp;=&amp;.&amp;=&amp;.eqnarray*appendixdocument</section>
</root>
