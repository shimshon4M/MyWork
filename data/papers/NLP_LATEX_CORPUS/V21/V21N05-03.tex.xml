<?xml version="1.0" ?>
<root>
  <jtitle>単語並べ替えと冠詞生成の同時逐次処理：日英機械翻訳への適用</jtitle>
  <jauthor>林克彦須藤克仁塚田元鈴木潤永田昌明</jauthor>
  <jabstract>本稿では，機械翻訳の単語並べ替え問題にシフトリデュース構文解析法を応用するための手法を提案する．提案手法では，単一言語のInversionTransduction文法によって単語並べ替え問題を定式化する．また，日本語文と英語文との単語対応をとりやすくするため，あらかじめ除去した英冠詞を翻訳結果へ挿入する問題も単語並べ替えと同時に定式化する．提案法を日英特許翻訳に適用したところ，句に基づく統計的機械翻訳のBLEUスコア29.99に対して，+3.15の改善が得られた．</jabstract>
  <jkeywords>統計的機械翻訳，単語並べ替え，後編集，冠詞生成，シフトリデュース構文解析</jkeywords>
  <section title="はじめに">句に基づく統計的機械翻訳が登場し，仏英などの言語対における機械翻訳性能は大きく向上した．その一方で，文の構文構造が大きく異なる言語対（日英など）において，長距離の単語並べ替えを上手く扱うことができないという問題がある．近年，この問題を解決するため，同期文脈自由文法や木トランスデューサにより，構文情報を使って単語並べ替えと訳語選択を同時にモデル化する研究が活発化している．しかし，単語アライメントや構文解析のエラーを同時にモデルへ組み込んでしまうため，句に基づく手法と比較して，いつでもより良い性能を達成できているわけではない．これらの研究と並行して，事前並べ替え法や事後並べ替え法に関する研究も盛んに行われている．これらの手法は単語並べ替えと訳語選択の処理を分けてモデル化し，語順が大きく異なる言語対で，句に基づく手法の翻訳性能を大きく向上させられることが報告されている．特に，文献で提案された主辞後置変換規則による事前並べ替え法は，特許文を対象とした英日翻訳で高い性能を達成している．この規則はある言語（本稿では英語を仮定する）を日本語（主辞後置言語）の語順へと変換するものであるが，文献では，主辞後置変換規則によってできた日本語語順の英語文を元の英語文へと復元するためのモデルを構築し，主辞後置変換規則の利点を日英翻訳へと適用可能にしている（事後並べ替え法）．文献では事後並べ替えを構文解析によってモデル化している．この手法は，1言語の上で定義されたInversionTransduction文法(ITG)にBerkeley構文解析器を適用することで，単語並べ替えを行う．また，主辞後置変換規則では日英単語アライメント性能を向上させるため，データから英冠詞を除去する．そのため，翻訳結果に冠詞生成を行う必要があり，文献では，構文解析による単語並べ替えとは独立して，N-gramモデルによる冠詞生成法を提案している．文献の手法は，Berkeley構文解析器の解析速度の問題や冠詞生成を独立して行うことから，解析効率や精度の点で大きな問題が残る．本稿では，この構文解析に基づく事後並べ替えの新たな手法を提案し，解析効率，及び，翻訳性能の改善をはかる．提案手法はシフトリデュース構文解析法に基づいており，文献で利用された段階的枝刈り手法によるBerkeley構文解析と比べて，次の利点を持つ．線形時間で動作し，高速で精度の高い単語並べ替えが可能．並べ替え文字列のN-gram素性（非局所素性に該当）を用いても計算量が変わらない．アクションを追加するだけで，並べ替えと同時に語の生成操作などが行える．1と2の利点は，解析効率における利点，また，2と3は翻訳性能を向上させる上での利点となる．特に，3つ目の利点を活かして，単語並べ替えと冠詞生成問題を同時にモデル化することが，提案法の最も大きな新規性と言える．本稿では，日英特許対訳データを使って，提案手法が従来手法を翻訳速度，性能の両面で上回ることを実験的に示す．以下，第2章では構文解析による事後並べ替えの枠組み，第3章では提案手法，第4章では実験結果について述べる．第5，6章では研究の位置付けとまとめを行う．</section>
  <section title="構文解析による事後並べ替え">図~に示すように，事後並べ替えによる機械翻訳方式は2つのステップに分けられる．最初のステップでは入力文をそのままの並びで出力言語文（中間言語文）へと翻訳する．そして，次のステップにおいて中間言語文を並べ替え，出力言語の語順になった文を生成する．文献はこの2番目のステップを構文解析によってモデル化し，そのための学習データを次のような手順で作成している．まず，図~の左図に示すように，英語文に対して語彙化構文木を作成する．次に，主辞後置変換規則によって，図~の右図に示すような木（中間英語木）へと変換する．この変換では，非終端記号に付随する主辞をその句の後方へと移動する．例えば，左図のPP(with)PR(with)NP(telescope)の辺では，PPの主辞となるwithはtelescopeの前に位置するが，右図ではPP^#N(telescope)^``a/an''PR(with)のようにtelescopeの後ろに位置する．#は並べ替えを意味するマークである．右図の木構造における葉ノードから成る文を中間英語文と呼ぶ．さらに，中間英語文からは冠詞(the,a,an)が消去されており，逆に，日本語の助詞（が(ga)，は(wa)，を(wo)）が挿入されているが，これらは日本語文との単語対応をとりやすくするためである．削除された冠詞はそれが先頭に挿入される句を表す品詞ないしは非終端記号にマークしている．例えば，N(telescope)^``a/an''である．文献はこのような削除した冠詞のマークを行っていないが，提案手法では削除した冠詞の挿入を構文解析の枠組みとして定式化するため，このようなマークを行っている．#や冠詞マークを使うことで，図の右図に示す中間英語木から元の英語文を復元することは可能である．よって，中間英語木から学習した構文解析器によって，翻訳器が出力した中間英語文に中間英語木構造を自動推定することで，機械翻訳の単語並べ替えを行うことができる．</section>
  <section title="シフトリデュース構文解析による単語並べ替えと冠詞生成"/>
  <subsection title="単一言語のInversion Transduction文法">第節で説明した単語並べ替え（及び，冠詞生成）問題は，文献などで言及されているように，Inversiontrasduction文法(ITG)と関連付けられる．本来，ITGは2言語の構文解析(biparsing)を扱う枠組みであるが，単語並べ替え問題を扱う場合，1言語の構文解析として定式化する点に注意する（単一言語のITG）．単一言語のITGGはG=(V,T,P,I,TOP)から成る．ここでVは非終端記号，及び，品詞の集合，Tは終端記号の集合，Pは生成規則の集合，Iは冠詞挿入(``the''，``a/an''，``noarticle'')を行う非終端記号及び品詞の候補集合，TOPは開始記号である．生成規則の集合Pは[Xw,XYZ,X^#YZ,TOPX|X^#]の形式を持つ規則から構成される(wT，X,X^#,Y,ZV)．最初の規則は単語wを生成する語彙生成規則，次の2つは2分生成規則，最後は終了規則である．</subsection>
  <subsection title="シフトリデュース構文解析">単一言語のITGに対するシフトリデュース構文解析法を定義する．本稿で用いる記法は，文献やを参考にしているため，以下の定義を読解する上で，それらを参考にすると良いだろう．シフトリデュース構文解析は状態とアクションを使って解析を進める．基本的な動作原理は，まず，入力文W=w_1w_|W|をバッファBに積み込み（慣習に従い，左端が先頭），シフトと呼ばれるアクションによって，バッファの先頭単語に語彙生成規則を適用して，状態が持つスタックの先頭へと移す．そして，リデュースと呼ばれるアクションを使って，状態が持つスタックの先頭2つの要素に対して2分生成規則を適用して，構文木を組み上げていく．本稿ではさらに，挿入アクションを使って，冠詞の生成問題も同時にモデル化する．シフトリデュース構文解析における状態pは[p:[:i,j,S:]]として定義され，はステップ数，Sはスタックを表す．スタックは|s_1|s_0を要素に持ち，各要素は部分解析木を表現する．慣習に従い，スタックの要素は右端を先頭とし，各要素を|で区切る．iはスタック先頭要素s_0が持つ部分解析木の左端単語のW中での位置インデックスを表し，jはバッファBの先頭単語のW中での位置インデックスを表す．は予測前状態へのポインタ集合である．予測前状態とは，現状態のs_0が構築される直前の状態のことであり，はそこへのバックポインタを保持する．が集合となるのは，文献の動的計画法により状態の結合が起こると，をもう一方の状態のへと結合するからである．各スタックの要素は以下の部分解析木に関する変数を持つ．[s=H,h,w_left,w_right,a.]ここでHとはsが持つ部分解析木のルートにある非終端記号または品詞ラベルの変数を表す．hはHに付随する主辞単語のW中のインデックスを表す変数である，aは``the''，``a/an''，``noarticle''，またはnullが割り当てられる変数を示している．w_leftとw_rightは部分解析木が覆う並べ替え文字列の左端と右端単語を表す変数である（解析時に並べ替えが起こったとき，w_leftとw_rightだけを明示的に並べ替えることに注意）．sの要素*はs.*として参照する．図には状態の説明図を示す．以下のアクションに関する説明が煩雑になることを防ぐため，スタック要素の定義からL,R,w_lは除いたが，後述する識別モデルの素性にはこれらを利用する．LはHの左側の子供となる非終端記号，Rは右側の子供となる非終端記号，w_lはLに付随する主辞単語のW中の位置インデックスを表す変数である．提案手法はシフト-X，挿入-x，リデュースMR-X，リデュースSR-X^#，終了の5種類のアクションを持つ．以下，各アクションは推論規則[前状態p後状態p'条件部]を使って定義する．条件部にはアクションの適用条件を記述し，状態pにアクションを適用すると，状態p'になることを表す．解析は初期状態p_0:[0:0,1,:]から始まり，終了アクションによって導かれる終了状態に至るまで続ける．シフト-X:バッファの先頭単語をスタックに積み，品詞を割り当てる．[p:[:i,j,S|s_0':]p':[+1:j,j+1,S|s_0'|s_0):p]	Xw_jP.]ここでs_0はH=X，h=j，w_left=w_j，w_right=w_j，a=nullとなり，単語w_jに品詞Xが割当られたことを意味する．挿入-$x$:現在の状態が持つスタック先頭要素の部分解析木が覆う単語列の先頭に``the''，``a/an''，``noarticles''のいずれか（変数xで表す）を挿入する操作を行う．p:[:i,j,S|s_0'):]p':[+1:i,j,S|s_0:]s_0'.XI	(s_0'.a=null||x``noarticle''s_0'.a``the''s_0'.a``a/an'').multline*ここでs_0はH=s_0'.H，h=s_0'.h，w_left=s_0'.w_left，w_right=s_0'.w_right，a=xとなる．アクションの適用条件でs_0'=nullは現状態でまだ一度も冠詞挿入が行われていないことを意味し，``the''，``a/an''，``noarticle''が代入できる．一方，すでに``noarticle''が挿入された位置には，条件x``noarticle''s_0'.a``the''s_0'.a``a/an''によって，``the''か``a/an''のみ挿入可能で，そのいずれかを挿入以後，その位置には冠詞挿入は行えない．リデュース：リデュースMR-XとリデュースSR-X^#の2種類を定義する．これらは同じ形式の推論規則で表記できる．[q:[_:k,i,S'|s_1':']p:[:i,j,S|s_0':]p':[+1:k,j,S'|s_0:']XYZPq.]リデュースはs_0'とs_1'を文法規則XYZによって結合し，新たなスタック要素s_0を作り出す．リデュースMR-Xでは[s_0=X,s_0'.h,s_1'.w_left,s_0'.w_right,s_1'.a]を新たに作り出す．新たな非終端記号はXとなり，その主辞単語はs_0.h=s_0'.hとして，Zの主辞単語の位置インデックスを代入する．リデュースMRは非終端記号YとZが覆う2つの句をそのままの並びで結合するため，Xが覆う句の左端はs_0.w_left=s_1'.w_left，右端はs_0.w_right=s_0'.w_rightとなる．冠詞変数はs_0.a=s_1'.aとして，Yの先頭に挿入された冠詞変数が代入される．リデュースSR-X^#はMR-Xとは逆に，文法規則X^#YZによってYとZの句を並べ替えて結合し，新たなスタック要素[s_0=X^#,s_0'.h,s_0'.w_left,s_1'.w_right,s_0'.a]を作り出す．新たな非終端記号はX^#となり，その主辞単語はリデュースMR同様にs_0.h=s_0'.hとして，Zの主辞単語の位置インデックスを代入する．リデュースSRは非終端記号YとZが覆う2つの句を並べ替えて結合するため，X^#が覆う句の左端はs_0.w_left=s_0'.w_left，右端はs_0.w_right=s_1'.w_rightとなる．冠詞変数はs_0.a=s_0'.aとして，Zの先頭に挿入された冠詞変数が代入される．終了：シフトやリデュースをこれ以上適用できなくなり，終了規則が適用できる場合，[p:[:0,|W|,s_0':]p':[+1:0,|W|,s_0):]TOPX|X^#P.]として，終了状態p'を導く．ただし，s_0'.H=X|X^#，s_0.H=TOPとする．終了状態p'からバックトレースすることで，中間英語木，または，英語文は出力できる．図に解析の例を示す．図では，解析の過程が全て理解できるよう，スタック要素を省略せず，解析部分木を全て示した．入力文Wが与えられたとき，初期状態p_0から終了状態に至る状態とアクションの系列を完全アクション状態系列と呼び，と定義すると，シフトリデュース構文解析の探索問題は以下のように定式化される．ここでY(W)は，Wに対して解析可能な全ての完全アクション状態系列の集合を表す．一般に，Score(p,a)は識別モデルによってモデル化される．素性関数は状態pとアクションaを素性ベクトル(p,a)へ写像する関数である，素性ベクトルは発火した素性が対応する次元に1，それ以外は0をとる．は重みベクトルで，素性ベクトルとの内積をスコアとする．表には本稿の実験で使用した素性テンプレートを示す．によって結合された要素は組み合わせ素性を表し，状態pが持つ要素から全て計算される．さらに，全ての素性はaを結合して，状態pでアクションaを行う判断をモデル化している．例えば，図のstep5の状態でレデュースSR-VP^#アクションを行う場合，素性テンプレートのs_0.Hs_1.Hs_1.LはVNPNレデュースSR-VP^#という素性になり，素性関数によって素性ベクトルの対応する次元へ写像される．表の最も下の行は並べ替え文字列に関わる素性で，本稿ではこれらを非局所素性(non-localfeature,nf)と呼ぶ．実装上では，解析性能を高めるため，ビームサーチにより，各ステップではスコアが上位beam個の状態をビームスタックに保持して解析を行う．</subsection>
  <subsection title="曖昧性除去によるビームサーチの効率改善">単一言語のITGに従って，ある文字列の並べ替えを行う場合，様々な導出過程から同一の並べ替え文字列を作り出すことができる．例えば，図のような例である．これは元の文``e1e2e3e4''を並べ替えない場合のITG木が複数存在することを示している．この現象をSpuriousAmbiguityの問題と呼ぶ．文献ではSpuriousAmbiguityを解消するために，左分岐重視(Leftheavy)のITGを提案しているが，図のような一般的な複数の非終端記号を持つ文法規則において，一意な構造に変換する方法は自明ではない．シフトリデュース構文解析におけるビームサーチでは，SpuriousAmbiguityが及ぼす問題は大きい．なぜなら，同じ並べ替え文字列を表現した冗長な状態により，ビームスタックが無駄に消費されるからである．実際にこのことは第節の実験で示す．提案法では，この問題に対応するため，2つの手法を活用する．1つは文献の動的計画法に基づくシフトリデュース構文解析法を適用することである．この手法では，識別モデルの素性ベクトルが同じになる状態を結合し，ビームスタック上に不要な解を保持する必要がなくなる．そのため，冗長な状態の多くを効率的に抑えることができる．もう1つは並べ替え文字列を解析と同時に構築し，ハッシュテーブルによって同じ文字列を持つ状態を枝刈りする方法である．同じステップにある状態で，並べ替え文字列とスタック要素s_0とs_1の部分木のルート非終端記号が全て一致する場合，モデルスコアの低い方の状態を削除する．s_0とs_1のルート非終端記号を考慮するのは，解析エラーを軽減するためである．</subsection>
  <subsection title="CKY構文解析との計算量比較">シフトリデュース構文解析は最適解を求められる保証はないが，入力文長に対して，線形時間に動作するという利点がある．一方で，CKY構文解析法は最適解を求めることはできるが，1次の主辞・従属辞関係を考慮した場合，最悪計算量がO(n^5|V|^3)に及ぶことが知られている(nは入力文長，|V|は非終端記号の集合サイズ)．さらに，単一言語のITGに対して，第節で定義したような並べ替え単語列の左端単語w_leftと右端単語w_rightを特徴量（非局所素性）に考慮すると，リデュースMRに対応するCKY構文解析の推論規則は以下のようになる．[[i,h,k,X,w_left,w_right][k,h',j,X',w_left',w_right'][i,h',j,X'',w_left,w_right']X''XX'P]ここで[i,h,k,X,w_left,w_right]はある1つのCKYアイテムを表し，i,kはアイテムが表現する解析結果の左端と右端のインデックス，hは主辞のインデックスを表す．この推論規則では，長さnに対する9つの自由変数i,h,k,h',j,w_left,w_right,w_left',w_right'，非終端記号の集合Vから3つの記号X,X',X''を考慮するため，計算量はO(n^9|V|^3)となる．本稿では，主辞は必ず後置することを仮定しているため，hとh'はそれぞれkとjから参照でき，計算量はO(n^7|V|^3)となる．N-gramを考慮した構文解析がこのような高い計算量に及ぶことは，文献の係り受けと品詞タグ付けの同時解析でも言及されている（品詞タグ付けの場合，連接部分の計算量はnではなく，品詞の候補数となる）．CKY構文解析ではあるCKYアイテムに対して，ビタビスコアを最大にする解をボトムアップに計算していく．([i,j,X'',w_left,w_right'])	=_k,w_right,w_left',X,X'		([i,k,X,w_left,w_right])	([k,j,X',w_left',w_right'])p(X''XX')	nf(w_right,w_left').multlinepは規則のスコア，nfは並べ替え文字列から計算される2-gramモデルなどの非局所素性に関わるスコアである．N-gramを考慮したCKY構文解析の計算量はHookTrickと呼ばれる分配法則によってさらに削減できる．HookTrickは式()の右辺に対して，次のような式変換を行う（演算は積に対して分配的であることに従う）．_k,w_left',X'_w_right,X	([i,k,X,w_left,w_right])	p(X''XX')	nf(w_right,w_left')([k,j,X',w_left',w_right'])multline内部演算ではi,j,k,w_left,w_right,w_left'とX,X',X''を考慮し，外部演算ではi,j,k,w_left,w_left',w_right'とX',X''を考慮する．これより計算量はO(n^7|V|^3)からO(n^6|V|^3+n^6|V|^2)となる．しかし，このような計算量は一般にコストが大きく，提案法と比較して，実用的ではない．非局所素性を考慮したCKY構文解析はCubePruningと呼ばれる近似解法を使うと，O(n^3|V|^3)のCKY構文解析として解くことはできるが，最適解が求められる保証はなくなる．これより，CKY法や同様の原理（動的計画法）に基づくBerkeley構文解析などと比較して，提案法は単語並べ替え問題において，実用性の観点から大きな利点がある．</subsection>
  <section title="実験"/>
  <subsection title="実験データとツール">実験にはNTCIR-9とNTCIR-10の特許データを使い，日英翻訳を行った．日本語の形態素解析にはMecabを使用した．英語文の語彙化構文木を作成するため，Enjuを用いて全ての英語文を解析した．機械翻訳には，デコーダにMoses，単語アライメントにGIZA++，言語モデルにSRILMを用いた．データ及びツールについては表2と表3にまとめる．Enjuによって解析した語彙化構文木を文献の規則によって中間英語木へと変換した．削除した冠詞の挿入マークは，その冠詞を含む句の中で最も葉に近い非終端記号に付与した．冠詞を含む句の非終端記号がない場合，品詞に挿入マークを付与した．日本語の助詞挿入は文献に従って行った．提案手法の単語並べ替えモデルの学習は平均化パーセプトロンで行った．また，学習データの量が多いため，素性ハッシングを使って，素性計算を高速化した．提案手法，及び，比較手法での冠詞挿入によって``a/an''が挿入された場合，挿入位置の後ろに位置する単語の1文字目が母音の場合，anを挿入し，子音の場合，aを挿入して翻訳結果を出力した．日本語助詞は事後並べ替えの解析時には1単語として扱い，翻訳結果の出力時には全て取り除いた．</subsection>
  <subsection title="単語並べ替えに関する実験結果">提案手法の単語並べ替え性能を調べるため，全訓練データの中間英語木3,191,228文からランダムに300,000文を抽出し，並べ替えのための構文解析器を学習した．ただし，中間英語木において冠詞削除，及び，日本語助詞の挿入は行っておらず，ここでは並べ替えのみ（挿入アクションは用いない）を行うようにしている．なぜなら，冠詞削除や日本語助詞の挿入は翻訳時の単語アライメント性能向上を意図した操作であり，ここでは純粋に提案法の構文解析，及び，単語並べ替え性能を調べることが目的だからである．図では提案法を学習したときの学習イテレーションと開発データに対するF値の関係，図~にはBLEUスコアとの関係を示す．F値の計算はEVALBを用いて評価した．``Base''は通常のビームサーチ，``DP''は動的計画法付きビームサーチ，``Hash''は第節で述べたハッシュテーブルによる枝刈りを表し，各システムはビーム幅12で訓練した．図と図から，``DP''や``Hash''に比べて，``Base''による学習の効率が悪いことがわかる．図と図では``Base''のビーム幅を12，24，36にしたときの学習イテレーションと開発データに対するF値，及び，BLEUとの関係を示した．これから``Base''による学習は，``DP''や``Hash''よりもビーム幅を大きく設定しなければ，学習が円滑に行えないことがわかる．表は，NTCIR-9のテストデータの中間英語文を各システムによって解析したときのBLEU，RIBES，構文解析性能（再現率，適合率，F値，文正解率），解析時間を示した．文献は論文から抜粋した数値を示す．Berkeley構文解析はデフォルト設定で学習し，6回の学習イテレーションを行った．結果からは，提案手法のうち``DP''法が他の手法に比べ，高い性能を達成できることがわかった．表では，表の非局所素性を全て取り除いた(nf.無し)モデルを学習し，nf.有りのモデルと比較した．実験結果からは，非局所素性が並べ替えの性能向上に寄与していることがわかる．表では，k-best出力時に，出力リストの中にどれだけの種類の文字列があるかを示す．表~には，テストデータに対して出力した各k-bestリスト中の文字列種類数の合計/k-bestリストサイズの合計を示し，分子の数が多い程，多様な並べ替え文字列を出力できることを意味する．例えば，``Base''法の64-bestリストには，3,4種類程度の並べ替え文字列しか存在せず，Berkeley構文解析でも同様に，同じ文字列を表す解析結果を大量に出力しているがわかる．一方，``Hash''法ではこれらの冗長な表現を排除し，多様な解析結果を出力できている．以上の実験から，シフトリデュース法による単語並べ替え性能を向上させるには，SpuriousAmbiguityの問題に対処し，ビーム幅を効率的に活用することが極めて重要であることがわかった．よって，以下の翻訳実験では，提案法は全て``DP''法を用いて行う．``Hash''は``DP''よりも同じ文字列を多く排除できる一方で，文字列を動的に作り出す必要があり，計算コストが高い．``Hash''法のコスト削減や``DP''法との併用については，今後の課題である．</subsection>
  <subsection title="翻訳に関する実験結果">通常の日英翻訳器は，Mosesのdistortionlimitを0，6，12，20に設定し，言語モデルには訓練データの全英語文から学習した6-gram言語モデルを使用した．Mosesの学習はBLEUに対してMinimumerrorratetraining(MERT)を行った．単語並べ替えによる翻訳実験では，学習データに中間英語木3,191,228文から抽出した中間英語文を使用し，日本語から中間英語文への翻訳モデルを作成した．中間英語文の言語モデルは6-gramまで学習し，Mosesのdistortionlimit(dist)は0に設定した．Mosesの学習はBLEUに対してMERTで行った．事後並べ替えは翻訳器から出力した中間英語文の1-bestを単語並べ替えモデルで元の英語文にし，評価を行った．表に提案手法と他の手法の実験結果を示す．表からは提案手法が文献のモデルを上回る性能を達成していることがわかる．文献の実験結果は我々の実験によるものではないが，実験に使用したツールやデータは同一のものであることを明記しておく．さらに，節で定義した非局所素性(nf.)を使ったモデル(nf.有り)と取り除いたモデル(nf.無し)を比較すると，非局所素性が有効であることがわかる．BLEUスコアを使って，有意水準5%で2項検定を行ったところ，nf.無しモデルとnf.有りモデルには有意な差が確認された．また，非局所素性を使うことによる解析時間への影響も少ない．</subsection>
  <subsection title="実験結果の分析">提案手法では単語並べ替えと冠詞挿入を同時に行っているが，それらを同時解析することの利点を分析するため，様々なシステムとの比較を行った．NTCIR-9と-10のテストデータに対する実験結果は表に示す．単語並べ替えと冠詞生成の同時処理の有効性(1.2.3.4.)2.の結果は1.の結果から冠詞を削除したときの性能を示している．冠詞を削除すると，BLEU評価尺度による翻訳精度が極端に落ちることがわかる．これはBLEUがN-gram単位で評価を行う尺度だからである．次に，3.の結果は，N-gram手法によって2.の翻訳文へ冠詞挿入を行ったときの結果を示している．N-gram手法は文献と同様の冠詞挿入手法を意味する．この結果から，N-gram手法によって性能は向上するが，1.の同時解析ほどの性能は得られないことがわかる．提案手法とN-gram手法による翻訳結果を比較すると，提案手法の方が冠詞挿入を多く行っていることがわかった．N-gram手法では冠詞挿入を行う程，文が長くなるため，確率が小さくなり，なるべく短い文が選ばれてしまうためであると考察される．4.は，Mosesによって日英翻訳を行うとき，英語データから冠詞を削除し，翻訳結果出力後にN-gram手法で冠詞挿入した結果を示している．この結果から，単純に冠詞を後編集で挿入するだけでは，翻訳性能を改善できないことがわかる．日英対訳データから冠詞を除去することの意味(1.5.)5.では，冠詞を英語文から削除せず，提案手法で単語並べ替えのみを行った結果を示している．このアプローチでは翻訳性能を向上させることができなかった．この理由は中間英語文で``thethethe''のように冠詞が連続して出現してしまうため，翻訳文にも不要な冠詞が出現してしまうからである．Berkeley構文解析器との比較(1.2.3.6.7.)Berkeley構文解析器と提案手法を比較する．Berkeley構文解析器は提案手法と同様の500,000文を使って学習した．2.3.と6.7.の結果から，Berkeley構文解析器による単語並べ替え性能と提案手法による単語並べ替えの性能はほぼ同等であることがわかる．一方，1.と7.の結果に対して，BLEUスコアを使って，有意水準5%で2項検定を行ったところ，それらには有意な差が確認できた．これは提案法の冠詞生成がN-gram冠詞生成法よりも高い精度であるためと言える．また，Berkeley構文解析器と提案手法の解析速度を比較すると，提案手法のビーム幅を156に設定したときにちょうど同程度の解析時間となる．さらに，提案手法は冠詞挿入も行っているのに対し，Berkeley構文解析器はN-gram手法による冠詞挿入を未だ行っていない時点での解析時間であり，提案法が従来法よりも効率的に動作することがわかる．</subsection>
  <section title="関連文献">事後並べ替え手法は須藤らによって提案された．須藤らは日本語文から中間英語文への翻訳を行った後，再び機械翻訳によって中間英語文を英語文へと翻訳している．後藤らは中間英語文から英語文への並べ替えを構文解析によって行うことで，須藤らの手法を上回る精度を達成した．本稿でも同様に，構文解析によって事後並べ替えをモデル化した．提案法はシフトリデュース構文解析法を基盤にしており，単語並べ替えと冠詞生成を同時に処理する仕組みや非局所素性の導入を行うことで，精度と解析効率をさらに向上させた．これらの点から，提案法は後藤らの手法と明確に区別できる．文献では，機械翻訳の後編集において冠詞挿入を行うことの重要性を提唱し，英語文への冠詞挿入を決定木によって行った．後続的にいくつかの文献で英語文への冠詞挿入を機械学習によって解く手法が提案されているが，構文解析と冠詞挿入を同時に行う枠組みを提唱したのは，著者らの知る限り，本稿が初めてである．提案手法で採用したシフトリデュース構文解析法は様々な文法理論の構文解析に応用されている．例えば，依存文法，文脈自由文法，組み合わせ範疇文法などへの応用がある．シフトリデュース構文解析法を単一言語のITGへ応用した例は本稿が初めてである．</section>
  <section title="まとめと今後の課題">本稿では，シフトリデュース構文解析法をベースにした単語並べ替えと冠詞生成の同時逐次処理法を提案し，日英機械翻訳における事後並び替え問題に適用した．日英特許翻訳タスクを使った実験から，提案法は文献における事後並べ替え法の解析精度と効率の問題を改善できることがわかった．特に，解析効率の面では，理論上の計算量，及び，実際の解析速度において，従来法より優れることを示した．また，冠詞生成を単語並べ替えと同時にモデル化することが翻訳精度の向上につながることを示した．提案法は，本質的には事後並べ替えだけでなく，事前並べ替えにも適用可能である．ただし，文献の主辞後置変換規則を用いずに，モデルを学習するためのデータを作成する方法は自明ではない．よって，単語アライメントと構文木から単語並べ替え構文解析器の学習データを作るための手法開発が今後の課題である．また，提案手法は翻訳結果の1-bestに対して，動作する仕組みであったが，今後は多様な翻訳結果に対して動作させるため，翻訳ラティスを解析する仕組みに拡張することが課題となる．document</section>
</root>
