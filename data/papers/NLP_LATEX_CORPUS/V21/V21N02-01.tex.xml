<?xml version="1.0" ?>
<root>
  <jtitle>既存のツールと結合した話し言葉コーパス利用環境</jtitle>
  <jauthor>伝康晴小磯花絵</jauthor>
  <jabstract>近年，コーパスアノテーションは多様化し，多層アノテーションを統合利用する仕組みが欠かせない．とくに話し言葉コーパスでは，言語・非言語に関する10種類以上もの単位とそれらの相互関係を統合し，複数の単位を組み合わせた複雑な検索を可能にする必要がある．本研究では，このような要請に応えるため，(1)マルチモーダル・マルチチャネルの話し言葉コーパスを表現できる，汎用的なデータベーススキーマを設計し，(2)既存のアノテーションツールで作成された，種々の書式を持つアノテーションを入力とし，汎用的なデータベーススキーマから具現化されたデータベースを構築するツールを開発する．話し言葉の分野では，広く使われている既存のアノテーションツールを有効に利用することが不可欠であり，本研究は，既存のアノテーションツールやコーパス検索ツールを用いたコーパス利用環境を構築する手法を提案する．提案手法は，開発主体の異なる複数の話し言葉コーパスに適用され，運用に供されている．</jabstract>
  <jkeywords>話し言葉コーパス，多層アノテーション，既存のツールの利用</jkeywords>
  <section title="はじめに">近年，コーパスアノテーションはますます多様化し，多層アノテーションを統合的に利用する仕組みが欠かせない．たとえば，話し言葉の言語学的・工学的研究で広く用いられている『日本語話し言葉コーパス』のコアデータでは，音韻・単語・韻律単位・文節・節を含む10種類あまりの単位に関してさまざまなアノテーションがなされている．また，最近では視線・頷きやジェスチャーなどの非言語情報を含むマルチモーダルコーパスの開発が進んでおり&lt;たとえば&gt;Carletta_2007_UTK,Chen_2006_VMM,Den_2007_SAT,角_2011_マルチ,Waibel_2009_CIT，これらのコーパスでは複数のモダリティに関して多種のアノテーションがなされている．コーパスアノテーションに基づく研究では，このような多層的なアノテーションを統合し，「文末形式を持つ節の先頭の文節の末尾の語が係助詞「は」であるものを抽出し，その語の継続長を算出する」といった，複数の単位を組み合わせた複雑な検索を可能にする必要がある．これまで，多層アノテーションを表現するさまざまなスキーマが提案され，それらに基づくアノテーションツールやコーパス検索ツールが開発されている．しかし，これらのツールは開発主体内部での利用にとどまっている場合がほとんどであり，外部にはあまり普及していない．これらの統合開発環境では提案スキーマに基づいて種々のツール群を提供することを目指しているが，実際に提供されているのは一部のツールのみであり，個別のアノテーションツールのほうが広く使われている場合が多い．とくに話し言葉においては，PraatやELANといった音声や映像を扱う高機能なアノテーションツールが広く普及しており，これらのツールと同等の機能を持つツールを自前で開発するのはコストが高くつくうえ，コーパス開発者の側でも使い慣れたツールにとどまって新たなツールに乗り換えたくないという者が多い．本研究の目的は，話し言葉で広く使われている既存のアノテーションツールを有効に利用しつつ，種々のアノテーションを統合利用できる環境を構築することである（図）．具体的には以下のことを行なう．マルチチャネル・マルチモーダルの話し言葉コーパスを表現できる汎用的なデータベーススキーマを設計する．以下の入出力を持つデータベース構築ツールを開発する．サーバを必要としないスタンドアロンのデータベースソフトとして広く用いられているSQLiteによって実装し，既存のコーパス検索ツールと接続可能にする．本研究は，既存のアノテーションツールやコーパス検索ツールと結合したコーパス利用環境を構築することに主眼があり，アノテーションツールやコーパス検索ツールの開発そのものを目的とするものではない．以下，節では話し言葉を表現できる汎用的なデータベーススキーマの設計について述べ，節ではデータベース構築ツールの開発について述べる．節では提案するコーパス利用環境を用いて実際に運用している2つの事例について述べる．節では関連研究やアノテーション管理・実用性に関する議論を行ない，節ではまとめと今後の課題について述べる．</section>
  <section title="話し言葉を表現できる汎用的なデータベーススキーマの設計">本節では，マルチチャネル・マルチモーダルの話し言葉コーパスを表現できる汎用的なデータベーススキーマを提案する．本スキーマは，基本的には，とが提案したセグメントとリンクに基づくスキーマに依拠している．しかし，彼らのスキーマは書き言葉を想定しており，話し言葉に適用するためにはいくつかの拡張が必要である．以下，拡張・改良点について順に述べ，我々のスキーマを提案する．</section>
  <subsection title="セグメントとリンクに基づくスキーマ">セグメントとリンクに基づくスキーマでは以下の2種類のオブジェクトを用いる．いずれのオブジェクトも型ごとに定まった属性(name)と値(value)の対の集合を持つ．たとえば，単語型セグメントは品詞・活用型・活用形などの属性を持ちうるし，係り受け関係型リンクは係り受けの種類（従属と並列の区別）などの属性を持ちうる．これらの属性値が付随したセグメントとリンクの集合によって文書を表現する．セグメントとリンクに基づくスキーマのクラス図を図に示す．</subsection>
  <subsection title="話し言葉への拡張">セグメントとリンクに基づくスキーマはもともと書き言葉を想定して作られており，話し言葉に適用するためにはいくつかの拡張が必要である．開始・終了位置：開始・終了位置としては文書中での文字位置（文書の先頭から数えて何文字目か）が想定されている．しかし，話し言葉で対象となる要素（アクセント・音調や視線・頷きなど）は必ずしもテキスト情報に基づいていない．そこで，開始・終了位置として文書（音声・映像ファイル）中での時刻（文書の先頭からの経過時間）を用いる．単位の融合：話し言葉ではしばしば隣接する単位間での融合が生じる．たとえば，「私は」が融合して「ワタシャ」のように発音されたりする．この場合，「私」と「は」の境界は実際の音声中には存在しないので，個々の単語を時刻に依拠したセグメントとしては表せない．そこで，セグメントとしては融合した「わたしゃ」全体を一つの単位とし，個々の形態論情報を担う単位を「時間的に整列されないセグメント」（非整列セグメント）として別途表現する（図）-0.5zw．これらのセグメントと非整列セグメントの間の依存関係は後述する階層関係を用いて表現し，各非整列セグメントが「何個の非整列セグメントからなる（長さlenの）セグメント中の何番目の要素であるか(nth)」という情報を与える（図ではnth/lenで表記）．マルチチャネルへの対応：書き言葉の文書は通常，単一のストリームからなる．しかし，話し言葉の対話データでは，複数話者によるマルチチャネルのストリームに対応しなければならない．これはチャネルごとに時刻を相対化することで解決できる．そのために，セグメントの表現にチャネル識別子（話者ラベルなど）を追加する．マルチモーダルへの対応：書き言葉の文書にはテキストという単一のモダリティしかない．しかし，話し言葉のマルチモーダルデータでは，音声言語に加えて，視線・頷きやジェスチャーなどのモダリティに対応しなければならない．セグメントとリンクに基づくスキーマはスタンドオフ形式のため，このような単一の根ノードにまとまらない単位階層にも自然に対応できる．一方で，区間の包含関係で階層関係を表すスタンドオフ形式では，不適切な階層関係が認定されることがある．たとえば，「うん，そうだね」という発話が頷きを伴ってなされた場合，「うん」という単語はこの発話の適切な下位単位であるが，頷きは発話の適切な下位単位とは言えない．どの型のセグメント間に階層関係が設定されるかは，各セグメント型の認識論的な位置づけによってアプリオリに定まっているべきである．そこで，本スキーマでは，セグメント間の階層関係を明示的に表現する．これは，下位セグメントを参照元，上位セグメントを参照先とした特別な型のリンクととらえることができる．</subsection>
  <subsection title="スキーマの具体化">セグメントとリンクに基づくスキーマは，さまざまな属性集合を持ちうるさまざまな型のセグメントやリンクを扱うために，極めて抽象度の高いスキーマになっている（セグメントとリンクという2種類のオブジェクトしかない）．やは，「述語」や「項」といったより具体性の高いオブジェクトを操作できるアノテーションツールやコーパス検索ツールをインターフェースとして提供することで，ユーザの利便性を図っている．しかし，既存のアノテーションツールやコーパス検索ツールを用いてコーパス利用環境を実現しようという本研究においては，このような利便を図ることはできず，スキーマ中のオブジェクトがそのままユーザが操作する対象となる．そこでは，語やアクセント句や節といったオブジェクトがそのまま操作できたほうがユーザの了解度は高いと思われる．そこで，（非整列）セグメントや（階層関係を含む）リンクを型ごとに別々のオブジェクトとして表現し，属性は各オブジェクトに直接表現する．属性集合は型ごとに定まるため，型ごとにオブジェクトを別にすれば，このような表現が可能となる．また，階層関係については，「何個の下位セグメントからなる（長さlenの）上位セグメント中の何番目の要素であるか(nth)」という情報を付与する．この情報は時刻の情報から導出できるため，表現としては冗長である．しかし，話し言葉では，隣接するセグメント間で先行要素の終了位置と後続要素の開始位置が一致するという制約が必ずしも成り立たない（間に休止が介在しうる）ため，SQL言語を用いると，たとえば隣接語対を抽出するのに煩雑な検索を行なわなければならない．上述の情報があれば，この検索は簡単に行なえる（付録参照）．</subsection>
  <subsection title="提案するデータベーススキーマ">との議論を踏まえ，図のスキーマを設計した．本スキーマでは以下の4種類のオブジェクトを用いるType_i)，(2)あいづち表現など，あるセグメントの一部のインスタンスに対して追加的に与えられた属性を表現するオブジェクト(addType_i)，(3)話者情報などのメタ情報を記述するオブジェクト(infoType_i)の3種類のオブジェクトがある．．オブジェクトの種類としては限られているが，型ごとに別々のオブジェクトとして表現されるため，実際のオブジェクトの数はしばしば十数個にもなる．元のセグメントとリンクに基づくスキーマ（図）と比べると，以下の違いがある．非整列セグメントが導入された．階層関係が陽に表現された．（非整列）セグメントやリンクが型ごとに別々のオブジェクトとして表現され，属性を内包するようになった．</subsection>
  <section title="データベース構築ツールの開発">本節では，既存のアノテーションツールで作成された種々の書式を持つアノテーションから，節で提案したスキーマに基づくデータベースを自動的に構築するツールについて述べる．</section>
  <subsection title="ツールの概要">本ツールは現在のところ，CSVベースのツール，Praat，ELAN，Anvilの4種類のアノテーションツールに対応している．これらのアノテーションファイルから提案スキーマに基づくデータベースを生成することが本ツールの目的である．構築するデータベースは可搬性に優れたSQLiteを採用した．SQLiteは，すべてのテーブルやインデックスを単一のファイルで実装するスタンドアローンの関係データベースであり，『茶器』などのコーパス管理環境でも利用されている．4種類のアノテーションの書式は大きく異なるが，ある一定の規約を設けることにより，データベースに直接インポートできる表形式ファイルに容易に変換できる．この規約に従ったアノテーションを「正規形」と呼ぶ．ELANやAnvilは本研究と類似のスキーマを用いており，はじめからこの規約に従っている．一方，CSVやPraatでは前もって正規形に変換する必要がある．したがって，データベースの構築過程は以下のようになる．</subsection>
  <subsection title="利用できるアノテーションツール">本ツールでは以下の4種類のアノテーションツールを利用できる．CSVベースのツール：形態論情報や談話行為など，テキスト情報に基づくアノテーションには，コンマで区切られたCSV形式の入出力を持つツールを用いることが多い．たとえば，MicrosoftExcelは人文系・理工系を問わず，広く用いられているCSVベースのツールであり，形態素解析システムなどの言語処理ツールの出力もCSV形式にできるものが多い．Praat：Praatは高機能な音声アノテーションツールであり，話し言葉の音声学的アノテーションで標準的なツールとなっている．分節音・単語境界や韻律情報のアノテーションで広く利用されている．出力書式は独自のものであるが，基本的にスタンドオフ形式である．ELAN：ELANは高機能な映像アノテーションツールであり，ジェスチャー研究などで広く利用されている．本研究と類似のスキーマを用いており，出力書式はスタンドオフ形式のXMLである．Anvil：Anvilも映像アノテーションツールである．ELANにはないリンクアノテーションの機能があり，発話間の関係づけやあいづち表現の反応先などのアノテーションで利用できる．Anvilの出力書式もスタンドオフ形式のXMLである．</subsection>
  <subsection title="正規形ファイル">以上のアノテーションからデータベースを構築するためには，スキーマを具現化する上で必須の情報がアノテーションファイルから取得できないといけない．これらは，セグメントでは開始・終了位置であり，リンクでは参照元・参照先セグメント（を一意に同定する情報）である．これらの情報の取得を保証するアノテーションを「正規形」と呼ぶ．以下，アノテーションファイルの書式ごとに順に述べる．CSV：CSV形式の正規形ファイルの例として，形態論情報アノテーションの例を図に示す．CSV形式の正規形では，各行に開始・終了時刻が記されているものとする．たとえば，形態論情報アノテーションでは，Praatなどを用いて別途ラベリングした単語境界の情報から単語ごとの開始・終了時刻が転写されているものとする．ただし，で述べた単位の融合などにより時刻を定められない箇所は「不定」（``NA''で示す）としてよい．「不定」でない開始・終了時刻を持つ最小の範囲（図の冒頭の例では「第一」）がセグメントとして認定され，各行はその下位に位置する非整列セグメントとして認定される．1つのCSVファイルで複数の単位をアノテーションする場合がしばしばある．たとえば，図では，短単位(SUW)と長単位(LUW)という複数の粒度で語が認定されている（「第一母音」は長単位では1つの語であり，短単位では「第」「一」「母音」という3つの語である）．このような場合には，IOB2ラベルによって上位単位の区間を示す（図のluwLabel列）-0.5zw．CSV形式でリンクを表すには，ローカルに定義されたid（文内での文節の通し番号など）を用いて参照元と参照先を示す．たとえば，係り受け解析器CaboChaの出力はこのような情報を含んでいる．データベース構築ツールはこれらのidをデータベース内で利用するグローバルなidに自動的に変換する．Praat：Praatの正規形ファイルの例として，韻律情報アノテーションの例を図に示す．Praatは多層アノテーションツールであり，複数階層のセグメントを同時に表すことができる．図では上段の3層，単語(Word)・アクセント句(AP)・イントネーション句(IP)がそれらに対応する．韻律情報のアノテーションスキーマとして広く用いられているX--JToBIでは，アクセント句やイントネーション句など単語より上位のセグメントを直接認定することはなく，これらは単語に対するBreakIndexの情報を用いて派生される．しかし，X--JToBI自体はこれらの上位セグメントの定義を与えておらず，上位セグメントをどのように派生するかはコーパス開発機関ごとに微妙に異なりうる．データベース構築ツールがこれらの上位セグメントを取得するためには，上位セグメントが陽に表現されている必要があり，そのため，Praatの正規形ファイルでは，すべての上位セグメントが陽に表現されていることを規約とした．ELAN/Anvil：ELANやAnvilを用いたアノテーションでは，複数階層のセグメントを陽に表すのが通常である．たとえば，ジェスチャーのアノテーションでは，ジェスチャー句とジェスチャーフェーズという複数の階層が用いられるが，それらは異なる層に明示的に表される．よって，これらのアノテーションははじめから正規形と考えてよい．なお，Anvilのリンクアノテーションはツール内部で生成されたidを用いて表現されているが，データベース構築ツールはこれらのidをデータベース内で利用するグローバルなidに自動的に変換する．</subsection>
  <subsection title="正規形ファイルから表形式ファイルへの変換">のように正規形ファイルを規約化することにより，データベースに直接インポートできる表形式ファイルへの変換を汎用のツールによって実行できる．このツールは，変換時に用いる諸設定を記述した設定ファイルを読み込み，各書式の正規形ファイルから表形式ファイルに変換する．ツールは，シェルスクリプトとPerl，Praatスクリプト，XSLTによって実装した．設定ファイルでは，どの正規形ファイルからどの属性を抽出し，どのオブジェクト（セグメントやリンク）の表形式ファイルに変換するかを記述する．おもな設定項目を表に示す．たとえば，図のような形態論情報のCSV形式正規形ファイルから長単位型セグメントの表形式ファイルを生成するための設定は図（左）のようになる．ここでは，入出力ファイル名がワイルドカードを用いて記述され，文書id(doc-id)がそこからどのように作られるかが指定される''はinput-file変数中のn番目の`%'にマッチする文字列を示す．．オブジェクトに含める属性集合はlabel-namesにコンマ区切りで指定する．長単位のように正規形ファイル中で上位階層に相当するセグメントの場合は，セグメント区間を示すIOB2ラベルが記された列名をunit-tag-columnで指定する．さらに，属性集合の値が正規形ファイル中のセグメント区間の先頭行(first)に記述されているか，最終行(last)に記述されているかをlabel-positionで指定する．図のような韻律情報のPraat形式正規形ファイルからアクセント句型セグメントの表形式ファイルを生成するための設定を図（中央）に示す．CSV形式の場合とほぼ同様であるが，セグメント区間は特定の層に陽に表現されているため，その層の名前をprimary-tierで指定する．また，Praatではセグメント外の要素（休止区間）も含めてラベルが付与されているため，セグメント外要素であることを示すラベル値をskip-labelで指定する．最後に，Anvilファイルからあいづち反応先型リンクの表形式ファイルを生成するための設定を図（右）に示す．Anvilのリンクアノテーションは，あるトラックの要素（たとえばあいづち表現）からあるトラックの要素（たとえば単語）への参照を，参照先要素の内部idを用いて属性値として表現している．そこで，参照元・参照先トラックの名前をそれぞれsource-track,destination-trackに指定し，参照先を記述した属性の名前をlink-attributeで指定するのようにチャネル名が前置（または後置）したものになる．このトラック名の形式はchannel-name-typeとchannel-name-delimiterで指定する．．</subsection>
  <subsection title="表形式ファイルからデータベースへの変換">で得られた表形式ファイルからデータベースを構築するには，まずオブジェクトごとにテーブルスキーマ（CREATETABLE文）を定義しなければならない．これには，各テーブルの名前や，持っている属性の一覧およびそれらの型などが含まれる．この過程には，テーブルスキーマを簡易表現で定義した設定ファイルを利用する．汎用のツールによって，設定ファイルからテーブルスキーマを定義し，表形式ファイルからデータをインポートする．設定ファイル中では，(1)テーブルの名前，(2)インポートする表形式ファイルの名前（ワイルドカードで複数指定可能），(3)主キーの名前と型，(4)属性の名前と型（のリスト）などを指定する．属性の型としては，テキスト型(t)・整数型(i)・実数型(r)が利用できる．テーブルスキーマの定義は一般に以下の形式である．テーブル名=表形式ファイル一覧/主キーの名前:型/属性1の名前:型,属性2の名前:型,...verbatimscreenたとえば，図（中央）の設定を用いて生成したアクセント句型セグメント用の表形式ファイルからデータベースのテーブルを生成するための設定は図のsegAPのようになる．同様に，図（右）の設定を用いて生成したあいづち反応先型リンク用の表形式ファイルからデータベースのテーブルを生成するための設定は図のlinkRTTargetのようになる．セグメント間の階層関係は，階層をなしうるセグメント型の名前を下位のものから順に並べて指定する．たとえば，図の単語・アクセント句・イントネーション句間の階層関係を表現するには，図のgroupProsodicのように指定する．データベース構築ツールは，階層関係にあるセグメント対を自動的に導出し，テーブルを作成する．階層関係は隣接する型の間（relWord2APやrelAP2IP）だけでなく，離れた型の間(relWord2IP)でも導出される．</subsection>
  <section title="適用事例">『日本語話し言葉コーパス』と『千葉大学3人会話コーパス』を対象に，本稿で提案した手法によりデータベースを構築し運用している．本節ではその概要について紹介する．</section>
  <subsection title="『日本語話し言葉コーパス』">『日本語話し言葉コーパス』(CSJ)は，2004年に一般公開された661時間の日本語自発音声からなるデータベースである．このうち「コア」と呼ばれるデータ範囲（44時間）には，おもに表に示す研究用付加情報が付与されており，これらを対象に本手法によりデータベースを構築した（以下CSJ-RDB）．各研究用付加情報はそれぞれ，表の「ツール」欄に示す書式（CSJ構築時（1999〜2003年）とは異なる）で記述されており，ここから各種中間ファイルを経てデータベースに変換した．CSJ-RDBの（非整列）セグメントとリンクを図に示す．談話中の要素を記述したセグメントは，次の3種類の階層関係からなる系列に分類される．形態統語論系列：短単位&lt;長単位&lt;文節&lt;節単位音声系列：分節音&lt;音素&lt;モーラ&lt;短単位&lt;間休止単位韻律系列：短単位&lt;アクセント句&lt;イントネーション句このうち短単位と長単位については，時間的に分節化できる部分をセグメントで表し，時間的に分節化できない部分は非整列セグメントとして表している．韻律情報のうちアクセント核や句末音調などのトーン情報は，どのアクセント句に帰属するかがリンク(linkTone2AP)によって表される．また文節係り受け関係は，係り元と係り先の依存関係がリンク(linkDepBunsetsu)によって表される．</subsection>
  <subsection title="『千葉大学3人会話コーパス』">『千葉大学3人会話コーパス』は，大学キャンパスにおける3人の友達同士の会話を集めた約6時間からなる対話コーパスである．このうち12会話約2時間のデータには，表に示す研究用付加情報が付与されており，これらを対象にデータベースを構築した（以下Chiba-RDB）．各研究用付加情報はそれぞれ表の「ツール」欄に示す書式のアノテーションファイルで記述されており，ここから各種中間ファイルを経てデータベースに変換した．Chiba-RDBの（非整列）セグメントとリンクを図に示す．セグメントは，次の4種類の階層関係からなる系列に分類される．形態統語語用論系列：短単位&lt;文節&lt;節&lt;長い発話単位韻律系列：短単位&lt;アクセント句&lt;イントネーション句視線系列：視線フェーズ&lt;視線句頭部動作系列：頭部動作フェーズ&lt;頭部動作句CSJ-RDBと異なる部分を中心に見る．まず，長い発話単位間の連接関係（話者交替）を表す話者移行関係がリンク(linkLUUTrans)によって表される．また長い発話単位のうち，あいづち表現については，あいづちが打たれるきっかけとなった表現（反応先）との関係がリンク(linkRTTarget)によって表される．頷きについても同様に，そのきっかけとなった表現（反応先）との関係がリンク(linkNodTarget)によって表される．</subsection>
  <section title="議論"/>
  <subsection title="関連研究">本節では関連研究との違いについて述べる．節で述べたように，本研究は，既存のアノテーションツールやコーパス検索ツールを用いてコーパス利用環境を実現することに主眼があり，アノテーションツールやコーパス検索ツールの開発そのものを目的とするものではない．やをはじめとする関連研究とは，この点がまず大きく異なる．さまざまなアノテーションを統合開発環境で行なうアプローチは魅力的ではあるが，マルチモーダルデータを含む話し言葉コーパスではその実現に多くの困難が伴い，本研究のアプローチのほうがより現実的な解を提示している．他のツールで作成されたアノテーションを統合し利用するという点では，やがむしろ本研究に近い．は，形態素解析・係り受け解析済みのテキストを読み込んで，コーパス検索・修正などをGUIで行なうための汎用的なツール『茶器』を開発している．もともと書き言葉を想定していたが，最近，話し言葉も扱えるよう拡張がなされている．しかし，『茶器』にインポートできるデータは決められた書式のものに限られており，節で示したような柔軟性はない．また，扱える単位も単語・文節あたりに限られており，節で見た事例のような多岐にわたる単位を扱うことはできない．は，長年にわたってさまざまな研究機関でなされてきた，Switchboardコーパスに対するさまざまな種類のアノテーションを統合し，多層にわたる検索を可能にした．電話会話のためマルチモーダル情報は含まないが，音素から統語構造・韻律情報，さらには非流暢性・情報構造・共参照に至るまで，15種類以上ものアノテーションを含み，節で見た本研究の事例に十分匹敵する．彼らはさまざまな書式を持つ既存のアノテーションを変換してこの統合をなしているが，本研究のようにそのための汎用的なツールを開発したわけではない．</subsection>
  <subsection title="アノテーション管理について">本研究では，話し言葉コーパスの統合利用に焦点を当てて述べてきたが，アノテーション過程の管理もまたコーパスアノテーションの重要な課題である．は，作業者管理，並行・分散アノテーション，バージョン管理，バージョンの併合といったマクロレベルの要件を考慮した統合開発環境を提案している．これに対して，本研究では，話し言葉で広く使われている既存のアノテーションツールを有効に利用することを最大の要件としてきた．そのため，統合開発環境に基づいて種々のツール群を開発するという方向性とは異なる立場に立ってきた．このことのデメリットについて検討する必要があろう．統合開発環境に基づくアノテーションツールを使わないことの最大のデメリットは，異なるツール間で共有される部分（たとえば『日本語話し言葉コーパス』の短単位）をあるアノテーションで修正したときに，その影響を他のアノテーションに簡単に波及できないという点である．統合開発環境に基づくツール群では，アノテーションデータ自身を共有しているため，このような波及は作業者が意識しなくても暗黙的になされる．しかし，個別のアノテーションツールを用いる本手法では，波及的な修正は自動的には行なえない．本手法においても，構築したデータベースから各種アノテーションを再生成することは可能であり，節で紹介した事例では，実際にそのようなツールを作成し運用している．このようなツールによって，あるアノテーションで生じた修正を別のアノテーションに波及すること自体は可能である．しかし，現状では，この種の波及的修正は，作業者が能動的に実行しない限り，行なえない．今後，アノテーションファイルへのアクセス方法などを工夫する（たとえば常にデータベースから再生成するなど）ことで，より効果的にアノテーション過程を管理する方策を考える必要がある．また，バージョン管理の問題についても，本研究では，汎用のバージョン管理システムSubversionを用いてアノテーションファイルを管理しているが，これで十分というわけではない．アノテーション過程の管理については，既存のアノテーションツールやバージョン管理システムを含むシステム全体の中で，よりよい手段を模索する必要があろう．</subsection>
  <subsection title="実用性について">節で述べたように，提案スキーマでは，語やアクセント句や節といった言語学的な概念とスキーマ内のオブジェクトとが直接対応しており，ユーザの了解度は高いと思われる．しかし，検索速度の面ではどうであろうか．この点を調べるために，コーパス言語学でよく用いられる，以下のような標準的なクエリに対する検索速度を計測した（付録参照）．(1)セグメントとリンクに基づくスキーマのように抽象度の高い単一のセグメントを用いる場合と(2)本手法のように型ごとに個別化されたセグメントを用いる場合とで比較を行なった．なお，これ以外の条件を対等にするため，いずれも階層関係を陽に表現した．実験は，人文系研究者がよく用いている，SQLiteのGUIであるNavicatforSQLite(ver.~11.0.10)を用いてノートPC(SonyVPCZ22AJ,Corei7-2640M2.80~GHz)上で行ない，CSJ-RDBを検索対象とした．結果を表に示す．「個別」は総じて「単一」の倍程度の速さであり，個別化されたセグメントを用いることで検索速度も若干改善されることがわかる．この程度の違いがどれだけの意味を持つかはわからないが，少なくとも提案スキーマが実用性で劣るということはない．</subsection>
  <section title="おわりに">本研究では，(1)マルチチャネル・マルチモーダルの話し言葉コーパスを表現できる，汎用的なデータベーススキーマを設計し，(2)既存のアノテーションツールで作成された，種々の書式を持つアノテーションを入力とし，汎用的なデータベーススキーマから具現化されたデータベースを構築するツールを開発した．また，『日本語話し言葉コーパス』と『千葉大学3人会話コーパス』を対象に，本手法によりデータベースを構築した事例を紹介した．構築したデータベースは，コーパス言語学的な研究に有効に利用されている．今後の課題としてまず，使いやすいユーザインターフェースを備えた，本研究のスキーマに対応したコーパス検索ツールの開発が挙げられる．本研究では，SQL言語やそのGUIのような既存のツールを用いた検索を想定していた．実際，人文系研究者をおもな対象として，CSJ-RDBをSQL言語やGUIで検索する技法に関する講習会を何度か開いている．しかし，本スキーマに特化したより使いやすい検索ツールがあれば，利用者はますます広がると期待できる．さらに，本研究のデータベース構築ツールはLinux環境で実装されており，この点も人文系研究者が利用するうえで障害となるであろう．PraatやELANなどの既存のアノテーションツールを用いたコーパス開発は，むしろ人文系研究者の間で広く行なわれており，それらのアノテーションを統合利用する必要性もまた人文系研究者において高いかもしれない．今後，より身近な環境で使えるようなツールに変更していきたい．-RDBの構築に際し西川賢哉氏（理化学研究所）の協力を得た．記して感謝する．本研究は，科研費補助金基盤研究(B)「発話単位アノテーションに基づく対話の認知・伝達融合モデルの構築」（課題番号：23320081，研究代表者：伝康晴），国立国語研究所独創・発展型共同研究「多様な様式を網羅した会話コーパスの共有化」（リーダー：伝康晴），萌芽・発掘型共同研究「会話の韻律機能に関する実証的研究」（リーダー：小磯花絵）による成果である．</section>
  <section title="隣接語対を抽出するクエリ">同一節(segClause)内で隣接する単語(segWord)の対を抽出するクエリ．階層関係テーブル(relWord2Clause)を用いない場合は，サブクエリを用いた煩雑なクエリとなる．--階層関係を用いない場合SELECTW1.idAScurrent,W2.idASnextFROMsegClauseASCINNERJOINsegWordASW1ONW1.docID=C.docIDANDW1.channel=C.channelANDW1.start&gt;=C.startANDW1.start&lt;C.endINNERJOINsegWordASW2ONW2.docID=W1.docIDANDW2.channel=W1.channelWHEREW2.start=(SELECTMIN(W3.start)FROMsegWordASW3WHEREW3.docID=W1.docIDANDW3.channel=W1.channelANDW3.start&gt;W1.startANDW3.start&lt;C.end);query--階層関係を用いた場合SELECTW1.idAScurrent,W2.idASnextFROMsegWordASW1INNERJOINrelWord2ClauseASR1ONR1.descendant=W1.idINNERJOINrelWord2ClauseASR2ONR2.ancestor=R1.ancestorINNERJOINsegWordASW2ONW2.id=R2.descendantWHERER2.nth=R1.nth+1;query</section>
  <section title="実用性評価で用いたクエリ">クエリ1：イントネーション句の末尾のアクセント句の先頭のモーラの継続長を算出0.8--抽象度の高い単一のセグメントを用いた場合SELECTI.id,MATTR.valueASMoraEntity,M.end-M.startASDurationFROMsegASIINNERJOINrelASAIONAI.ancestor=I.idINNERJOINsegASAONA.id=AI.descendantINNERJOINrelASMAONMA.ancestor=A.idINNERJOINsegASMONM.id=MA.descendantINNERJOINattrASMATTRONMATTR.ref=M.idWHEREAI.nth=AI.lenANDMA.nth=1ANDI.type=&quot;IP&quot;ANDAI.type=&quot;AP2IP&quot;ANDA.type=&quot;AP&quot;ANDMA.type=&quot;Mora2AP&quot;ANDM.type=&quot;Mora&quot;ANDMATTR.name=&quot;MoraEntity&quot;;verbatimscreen0.8--型ごとに個別化されたセグメントを用いた場合SELECTI.id,M.MoraEntity,M.end-M.startASDurationFROMsegIPASIINNERJOINrelAP2IPASAIONAI.ancestor=I.idINNERJOINsegAPASAONA.id=AI.descendantINNERJOINrelMora2APASMAONMA.ancestor=A.idINNERJOINsegMoraASMONM.id=MA.descendantWHEREAI.nth=AI.lenANDMA.nth=1;verbatimscreenクエリ2：イントネーション句の次末のアクセント句の末尾のモーラの継続長を算出0.8--抽象度の高い単一のセグメントを用いた場合SELECTI.id,MATTR.valueASMoraEntity,M.end-M.startASDurationFROMsegASIINNERJOINrelASAIONAI.ancestor=I.idINNERJOINsegASAONA.id=AI.descendantINNERJOINrelASMAONMA.ancestor=A.idINNERJOINsegASMONM.id=MA.descendantINNERJOINattrASMATTRONMATTR.ref=M.idWHEREAI.nth=AI.len-1ANDMA.nth=MA.lenANDI.type=&quot;IP&quot;ANDAI.type=&quot;AP2IP&quot;ANDA.type=&quot;AP&quot;ANDMA.type=&quot;Mora2AP&quot;ANDM.type=&quot;Mora&quot;ANDMATTR.name=&quot;MoraEntity&quot;;verbatimscreen0.8--型ごとに個別化されたセグメントを用いた場合SELECTI.id,M.MoraEntity,M.end-M.startASDurationFROMsegIPASIINNERJOINrelAP2IPASAIONAI.ancestor=I.idINNERJOINsegAPASAONA.id=AI.descendantINNERJOINrelMora2APASMAONMA.ancestor=A.idINNERJOINsegMoraASMONM.id=MA.descendantWHEREAI.nth=AI.len-1ANDMA.nth=MA.len;verbatimscreenクエリ3：文末形式を持つ節単位の先頭の文節の末尾の短単位が係助詞「は」であるものを抽出し，その短単位の継続長を算出0.8--抽象度の高い単一のセグメントを用いた場合SELECTC.id,S.end-S.startASDurationFROMsegASCINNERJOINrelASBCONBC.ancestor=C.idINNERJOINsegASBONB.id=BC.descendantINNERJOINrelASSBONSB.ancestor=B.idINNERJOINsegASSONS.id=SB.descendantINNERJOINrelASSMSONSMS.ancestor=S.idINNERJOINusegASSMONSM.id=SMS.descendantINNERJOINattrASCATTRONCATTR.ref=C.idINNERJOINattrASSMATTR1ONSMATTR1.ref=SM.idINNERJOINattrASSMATTR2ONSMATTR2.ref=SM.idWHEREBC.nth=1ANDSB.nth=SB.lenANDSMS.nth=SMS.lenANDC.type=&quot;Clause&quot;ANDBC.type=&quot;Bunsetsu2Clause&quot;ANDB.type=&quot;Bunsetsu&quot;ANDSB.type=&quot;SUW2Bunsetsu&quot;ANDS.type=&quot;SUW&quot;ANDSMS.type=&quot;SUWMorph2SUW&quot;ANDSM.type=&quot;SUWMorph&quot;ANDCATTR.name=&quot;ClauseBoundaryLabel&quot;ANDCATTR.valueLIKE&quot;[ANDSMATTR1.name=&quot;SUWLemma&quot;ANDSMATTR1.value=&quot;は&quot;ANDSMATTR2.name=&quot;SUWMiscPOSInfo1&quot;ANDSMATTR2.value=&quot;係助詞&quot;;verbatimscreen0.8--型ごとに個別化されたセグメントを用いた場合SELECTC.id,S.end-S.startASDurationFROMsegClauseASCINNERJOINrelBunsetsu2ClauseASBCONBC.ancestor=C.idINNERJOINsegBunsetsuASBONB.id=BC.descendantINNERJOINrelSUW2BunsetsuASSBONSB.ancestor=B.idINNERJOINsegSUWASSONS.id=SB.descendantINNERJOINrelSUWMorph2SUWASSMSONSMS.ancestor=S.idINNERJOINusegSUWMorphASSMONSM.id=SMS.descendantWHEREBC.nth=1ANDSB.nth=SB.lenANDSMS.nth=SMS.lenANDC.ClauseBoundaryLabelLIKE&quot;[ANDSM.SUWLemma=&quot;は&quot;ANDSM.SUWMiscPOSInfo1=&quot;係助詞&quot;;verbatimscreendocument</section>
</root>
