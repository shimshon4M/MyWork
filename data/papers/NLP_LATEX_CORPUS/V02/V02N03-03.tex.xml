<?xml version="1.0" ?>
<root>
  <title>動詞訳語選択のための「格フレーム木」の統計的な学習</title>
  <author>田中英輝</author>
  <jabstract>機械翻訳システムでは動詞の訳語を選択するために格フレームがよく利用される．格フレームは従来主として人手で記述されていたが，一貫性を保って記述するのが難しいこと，格フレームを部分的に変更した場合に起こる影響が把握しにくいことなどの重大な問題があった．そこでこれらの問題を解決するため，本論文では格フレームを決定木の形で表し(これを格フレーム木と呼ぶ)，これを英日の対訳コーパスから統計的な帰納学習プログラムを利用して学習することを提案する．本論文ではまず，この提案によって上記の問題が軽減される根拠を述べた後，本論文で作成した英日対訳コーパスについて述べる．続いて7つの英語動詞について格フレーム木の獲得実験を2つ報告する．最初の実験は，格要素の制約として英語の単語を使う格フレーム木を学習したものである．これにより得られた格フレーム木を観察したところ，人間の直観に近く，かつ直観を越えた非常に精密な訳し分けの情報が得られたことが明らかになった．次に，この格フレームの一般性を高めるために，英語の単語の代わりに意味分類コードを制約として利用する手法を提案し，これに基づいて格フレーム木を学習する実験を行った．得られた格フレーム木で未学習のデータの動詞の訳語を決定する評価を行ったところ，2.4%ないし32.2%の誤訳率が達成された．この誤訳率と，先の英語単語を利用した格フレーム木での誤訳率との差は13.6%ないし55.3%となり，意味分類コードが有効に機能したことが示された．</jabstract>
  <jkeywords>機械翻訳，機械学習，訳語選択，コーパス，決定木，統計</jkeywords>
  <section title="はじめに">著者らは放送分野を対象とした英日機械翻訳システムを開発している．この中で最もコストがかかり手間を要するのが辞書の作成である．著者らの経験によれば，この中で最も困難なのが動詞の表層格フレーム(以下，格フレームと省略する)の記述である．これは英語の動詞の日本語訳語を選択するために利用される情報で，動詞の取りうる文型とその時の訳語を記述したものである．従来，これらは冊子辞書や用例を参照しながら人手で収集・記述していた．しかし，記述する表層格要素(以下，格要素と省略する)や，その制約を一貫して用いることが難しいこと格フレームの一部を変更した場合に，訳語選択に与える影響が把握しにくいこと等の問題があり，この収集・記述作業の効率は非常に悪かった．このため本論文ではこれらの問題の解決を目指し，格フレームの新たな表現手法，および獲得手法を提案する．これは著者らの英日機械翻訳システムのみならず，動詞訳語選択に格フレームを利用するその他の機械翻訳システムの構築にも応用できるものである．本論文では上記の2問題を解決するために次の2点を提案する．動詞の翻訳のための格フレームを決定木の形で表現する．以下，本論文ではこの決定木を格フレーム木と呼ぶ．英日の対訳コーパスから，統計的な帰納学習アルゴリズムを用いて格フレーム木を自動的に学習する．また，この提案に基づいて実際に対訳コーパスから格フレーム木を獲得する実験を2種類行う．本論文で学習の対象としたのは訳語の数の多い英語の7つの動詞(``come'',``get'',``give'',``go'',``make'',``run'',``take'')である．最初の獲得実験では格要素の制約として語形を利用した．この結果，人間の直観に近く，かつ人手で獲得する場合より精密な訳し分けの情報が獲得されたことを示す．また2番目の実験では，格フレーム木の一般性を確保することを目的とし，意味コードを格要素の制約として用いた．この結果，未学習のデータを入力して動詞の訳語を決定する実験で2.4%から32.2%の誤訳率が達成された．これらの結果と，単純に最高頻度の訳語を出力した場合の誤訳率との差は13.6%から55.3%となりかなりの改善が得られた．実験に先だって著者らは英日の対訳コーパスを作成した．著者らの目的とする格フレーム木は，放送ニュース文を対象とすることを想定している．このため，学習には放送分野のコーパスを利用するのが望ましい．しかし，現在このような英日対訳コーパスは入手可能でないため，AP(AssociatedPress)のニュース英文を利用して作成した．本論文ではこの対訳コーパスの設計，作成過程および特徴についても触れる．著者らの研究は，コーパスから自然言語処理システムのルールを獲得する研究である．大規模コーパスが入手可能になるにつれ，この種の研究は盛んになりつつある．また，その獲得の目的とするルールもさまざまである．これらの中で本論文に近い研究としては，および，の研究が挙げられる．では，自然言語処理一般に利用することを目的とした日本語動詞の格フレームの獲得を試みている．ここで提案されている手法は，タグ付けされていない対訳テキストから格フレームが獲得できる点で著者らの手法より優れている．しかし，ここで利用されている学習アルゴリズムは，格フレームの利用の仕方を考慮したものではない．このため，著者らの目的である動詞の訳語選択にどの程度有効であるかは不明である．これに対して，著者らのアルゴリズムはエントロピーを基準にして，動詞の訳語選択の性能を最大にするように格フレーム木の獲得を行う．この結果，訳語選択に適した情報が獲得され，しかもその性能が統計的に把握できる利点を持っている．では著者らと逆に日英機械翻訳システムで利用するための日本語動詞の翻訳ルールを学習する手法を提案している．用いられている学習手法は基本的には本論文と同じものである．ただし，この論文では動詞の翻訳のための規則を決定木で表現することの利点について触れていないが，これには大きな利点があることを著者らは主張する．また，この論文では学習に利用した対訳事例をどのような所に求めたかは明らかにされていない．しかし，これは獲得される格フレーム木に大きな影響を与えるため著者らはこれを詳細に論ずる．さらに，この論文では人手で作成したルールとの一致で評価を行っているが，訳語選択の性能については触れられていない．これに対して著者らは動詞の誤訳率で評価を行う．本論文の構成は以下の通りである．2章では，人手で行っていた従来の格フレームの獲得，記述の問題点を整理する．3章ではこの解決のため，先に述べた提案を行うとともに，格フレーム木を英日対訳コーパスから学習する手法を説明する．4章では，本論文で利用する英日対訳コーパスの作成について述べる．5章では，このコーパスの語形を直接的に利用した格フレーム木の獲得実験を行う．6章では，対訳コーパスを意味コードで一般化したデータを作成して格フレーム木の獲得実験を行う．7章では本論文のまとめを行い，今後の課題について述べる．</section>
  <section title="人手による格フレーム獲得の問題点">著者らの英日機械翻訳システムで現在利用している格フレームの例(説明用)を図~1に示す．これは，英語の動詞が持つ複数の日本語訳語から適切な訳語を選択するために利用される．これらの格フレームは，それぞれの訳語ごとに記述されている．著者らの格フレームに記述してある要素は次の4つである．動詞が必須格として取りうる格要素格要素の制約(語形や意味分類のマーカー)動詞の日本語訳語ウエイト(図~1では省略)ウエイトとは，それぞれの格フレームに与えられた数値であり「使われにくさ」の指標として使われる．この値が大きいほどその格フレームは利用されにくくなる．格フレームは構文解析が終了してから利用される．すなわち入力英文の構文構造と動詞が認定されてから利用される．この動詞の訳語を決定するには，まず動詞の持つ格フレームすべて(辞書中に登録されているもの)と構文構造の比較が行われ，それらの間の類似度が計算される．そして最も類似度の高い格フレームの訳語が出力される．類似度は，構文構造と格フレームの間での格要素と制約の一致度合，および格フレームのウエイトを総合して計算される．従来，格フレームは人手で記述されていたが，困難かつコストのかかる作業となっていた．これは以下のような理由による．利用する情報の一貫性の確保格要素として何を記述すべきか．必須格の定義は何か．格要素の制約は何を使用するか．これらは記述する時に必ず決めなければならないパラメータである．これらは何らかの規範として事前に決められ，作業者はそれに添って記述を行う．このとき，規範で決められた制約と格要素は一貫して利用しなくてはならない．なぜなら，動詞の訳語を選択する時に行われる計算は，すべての格フレームが平等であることを前提としているからである．しかし，人手で一貫した方針を貫くのは困難であり不平等な記述になりがちである．格フレームの不透明性格フレームは一旦記述し終わった後で部分的に変更されることがしばしばある．例えば，ある格フレームの格要素を削除，追加したり，格要素の制約を変更することなどである．しかし，この結果が動詞の訳語選択にどういう影響を与えるかを把握するのは難しい．これには構文構造との比較時に発生する他の格フレームとの競合の状態の変化，すなわち類似度計算への影響を把握しなくてはならないからである．このような格フレームの変更結果の不透明性は，記述，保守管理の重大な障害となっている．ウエイト決定の恣意性ある格フレームのウエイト，すなわち「使われにくさ」を人間の内省で決めるのは非常に難しい．しかもウエイトは格要素と制約の一致度合と共に類似度計算に用いられるため，両者の評価の比重をどう設定するかなど問題は多い．実際には辞書の頻度情報などを参考に記述することが多いが，客観的なウエイトを与えることは難しい．以上の3点の問題の内，問題3は著者らのシステムに固有の問題であるが，問題1，2は格フレームを利用して動詞の訳語を決定する場合の共通する問題であると考える．</section>
  <section title="対訳コーパスからの格フレーム木の学習">著者らは，2章で述べた問題の解決のため以下の2点を提案する．格フレームを決定木の形で表現する(格フレーム木)英日の対訳コーパスから，統計的な帰納学習アルゴリズムを用いて格フレーム木を自動的に学習するまた，本章ではこれらを実現する手法を具体的に述べる．</section>
  <subsection title="格フレーム木">格フレーム木は図~2に示すような構造をしている．各ノードには格要素，アークにはその制約，リーフには動詞の訳語が付与されている．一方，従来の形式の格フレーム(図~1)を便宜的に線形格フレームと呼ぶ．格フレーム木は決定木であるため，動詞の訳語選択を行うには，ルートからリーフに向かって構文構造と比較するだけでよい．このため線形格フレームよりも効率良く動詞の訳語選択を行うことができる．しかし，この構造を採用する最大の利点は，2章で述べた問題2の「格フレームの不透明さ」を軽減できる点にある．これは，決定木にすることによって，変更の影響が変更場所の下の訳語に限られるためである．例えば，図~2の格要素PN(前置詞)を削除した場合には，下位の訳語「連れていく」と「選ぶ」の選択が行われなくなることが容易にわかる．</subsection>
  <subsection title="統計的な帰納学習">2章で述べた問題1「利用する情報の一貫性の確保」は，統計的な帰納学習プログラムを利用することで解決される．このようなプログラムとしてはCART~，ID3~，C4.5~など，いろいろなものが既に提案されている．これらは共通して(属性，属性値，クラス)の形式の表から決定木を学習する．著者らの目的とする格フレーム木を学習するには属性として格要素，属性値として格要素の制約，クラスとして動詞の訳語を与える(表~1)．本稿ではこの表を原始格フレーム表と呼ぶ．またこの表の各行を事例と呼ぶ．著者らの利用するプログラム(C4.5)では，原始格フレーム表の格要素が，動詞の訳語の分類にどれだけ有効かを統計的に計算する．すなわち，ある格要素の制約に従って訳語を分類した場合に，どれだけ「きれいに」訳語が分類されるかをエントロピーを用いて計算し，これによって有効性を判定する．そして，有効性の高い格要素から順番に上位ノードから下位ノードに配置して決定木を生成する(アルゴリズムの概要は付録Aに示す．)．表~1にプログラムを適用すると，図~2で示した格フレーム木が学習される．このアルゴリズムでは，格要素およびその制約は，訳語の分類に対する有効性という観点で一貫して評価されることになり，2章の問題1「利用する情報の一貫性の確保」は解決される．この手法で獲得された格フレーム木には，線形格フレームの個々のウエイトに相当する指標は陽には現われない．しかし，個々の格要素の有効性の高い順に格フレーム木が構成されるのでウエイトによる評価は必要なくなる．そのため2章の問題3「ウエイト決定の恣意性」の問題も解決されると言える．また，この手法を用いると格要素が必須格か自由格かという判定は，訳し分けの観点からプログラムで自動的に決定されることになる．例えば，図~2には主格がなく不自然な印象を受ける．しかし，これは訳し分けのための有効性を主格が持たなかった結果である．従来，自動学習は手間の軽減を目的として利用されることが多かった．しかし，有用な情報を目的に合わせて適切に配列する能力も大きな特徴である．本提案はこの特徴を生かしており，動詞の訳し分けを行うのに必要な情報を単に自動的に獲得するだけでなく，それらを，動詞の訳語を最適に選択できる決定木の形で構成する．またこの決定木の表現は実用上の利便性が高いものである．</subsection>
  <subsection title="格フレーム木の段階的な獲得">統計的な帰納学習アルゴリズムを利用する上で重要なのは入力，すなわち，原始格フレーム表である．この表は，訳し分けの対象とするドメインの事例の頻度分布を反映して作成しなければならない．なぜなら格フレーム木は，原始格フレーム表の事例の頻度を元に作成されるため，対象ドメインと原始格フレーム表で事例の分布が違った場合には，対象ドメインの動詞を有効に訳し分ける条件が学習されないからである．さらに，原始格フレーム表に記述する格要素と制約を決める必要があるが，これには試行錯誤を要する．以上のことより，対象ドメインの英日対訳コーパスを柔軟に変換して原始格フレーム表を作成する手法が有効と考えられる．しかし，著者らの対象ドメインである放送ニュース分野の英日対訳コーパスの入手は難しい．このため，著者らは英日の対訳コーパスを作成し，これを変換して原始格フレーム表を作成する方針を採用した．この結果，格フレーム木獲得の筋道は図~3に示すものとなった．従来，線形格フレームは直接的に人手で記述していた．しかし，提案手法では，対訳コーパスから人手を介しながら段階的に格フレーム木を獲得することになる．この手法で人間が介入する部分は，対訳コーパスの作成，および原始格フレーム表へ変換する部分だけである．対訳コーパス作成の部分では，英文への統語ラベルの付与，日本語への翻訳等を行う．また，原始格フレーム表への変換では，単に利用する格要素や制約を決定するだけである．このような人手の作業は，線形格フレームをいきなり記述するより安定に行うことができる．そのため，格フレーム木に入る人間の恣意性を最小限に押さえることができると期待できる．</subsection>
  <section title="英日対訳コーパス"/>
  <subsection title="コーパスのソース">先に述べたように，本手法では原始格フレーム表の事例の頻度分布が重要となる．このため英和辞典の例文などを利用することには問題がある．なぜなら高頻度で出現する訳語もそうでない訳語も例文の数にあまり差がないからである．そこで著者らの場合は，AP(AssociatedPress)電ニュースをコーパスのソースとして採用することにした．そしてこの英文から以下に示す条件を満たすものを抽出して，日本語訳を付与することで対訳コーパスを作成した．</subsection>
  <subsection title="対象動詞">訳語の数が多く機械翻訳を行う場合に問題となる以下の動詞を対象とした．</subsection>
  <subsection title="データ量">上記の動詞を訳し分けるために必要な対訳コーパスの量を直接見積るのは困難である．そこで，これらの動詞が出現する頻度調査を6ヶ月分のAP電について行った．この結果，各月での動詞の出現頻度はほとんど一定していることが明らかになった．もちろんこれは訳語の頻度が一定であることを保証するものではないが，一月単位が最低必要な量であろうと考えた．そこで1990年1月，1991年1月の2ヶ月を英文抽出の母集団とした．</subsection>
  <subsection title="作成手順">作成は以下の手順で行った．図~4に作成したコーパスの一部を示す．英文の抽出2ヶ月分のAP電から上記の7動詞を含む文を自動的に抽出した．このとき文の長さは15語以下とした．これは，文の長さをあまり長くすると解析が大変になること，類似の文型の個数が減るため有効な原始格フレーム表が作成できないことによる．動詞の支配範囲の認定対象動詞が直接支配している範囲を人手で認定した．図~4のENG行がこれを示す．英語の格要素の認定英語の文章を人手で解析して必要な情報を付与した．精度の高い構文解析器が利用できればこの作業はかなり自動化ができる．しかし，現状ではかなりの人手の介入が必要であるため，著者らは人手による解析を行うことにした．また，人手による精密な構文解析は手間が大きいので，原始格フレーム表を作成するのに最低限必要な解析を行うことにした．この解析で認定，付与した情報は，文のタイプ，主格，目的格などの統語単位，統語単位中の主辞単語と前置詞，副詞小詞などの機能語である．(I)，(II)には，それぞれラベルを設定した．文のタイプは11種類設定した．そして英文中の動詞に文のタイプを示すラベルを付与した．統語単位は24種類設定した．そして英文中の各統語単位に該当する範囲をで認定し，統語単位を示すラベルを付与した．また，各統語単位の主辞は[]で，機能語はで認定した．ここで作成したデータを英語のケースデータと呼ぶ．図~4のCASE行がこれにあたる．ラベルの詳細を付録Bの表~6,~7に記す．日本語翻訳の付与英語のケースデータの主辞と機能語に対して日本語の訳語を人手で付与した．図~4のJAP行がこれにあたる．また，JAP行でも主辞と機能語の指定がしてある．対象の英文一つだけで翻訳できない場合は，前後の文脈を翻訳者に提供した．</subsection>
  <subsection title="コーパスの特徴">対訳コーパスを作成するのに要した労力は6人月であった．表~2に作成したコーパスのデータを示す．この表の2行目に示した数字は，翻訳を行う場合に前後の文脈が必要であった比率を示す．すなわち，人間の翻訳者が一つの文だけを見て翻訳ができなかった割合を示している．このような文章の多くは``it''などの代名詞を含んでおり，翻訳のためにはそれらの指示内容が必要であった．</subsection>
  <section title="語形を利用した実験"/>
  <subsection title="方針">提案手法の基本的な能力を調査するために，以下の方針に従って原始格フレーム表を作成して格フレーム木獲得実験を行った．文の種類に応じて格フレーム木を作成従来，動詞の訳語選択を行う場合，その動詞がどういう文型で使われていても同じ格フレームを利用していた．しかし，同じ動詞でも平叙文，疑問文，関係節，不定詞句の中では共起する格要素は異なることが予想される．そこで文型ごとに格フレーム木の作成を行う．コーパスに出現する格要素すべてを利用これは著者らの使うアルゴリズムによって，どのような格要素が選択されるかを調査するためである．格要素の制約としては，主辞の語形と機能語を利用これらは，それぞれの統語単位を代表する成分であるため，まずこれを利用する．学習に利用したプログラムはC4.5(オプションなし，枝刈りなし)である．</subsection>
  <subsection title="実験結果">各動詞の各文型パターンについて格フレーム木の作成実験を行った．訳し分けの対象にしたのは各動詞とも，頻度が10以上である．これは頻度が小さいと有効なデータとならないからである．表~3に，入力とした原始格フレーム表の諸元と結果の一覧を示す．ここでは，平叙文のデータから作成した格フレーム木の結果のみを示した．また図~5に獲得された``take''の格フレーム木の一部を示す．この図では左がルートノードである．また各行の右端の数字は，学習に利用した事例を格フレーム木で分類した場合に(そのリーフに分類された事例数/事例とリーフの訳語が一致しなかった数[あれば])である．以下に結果の特徴を記す．通常の辞書との類似図~5に示すように，格フレーム木は直感的に理解しやすいものであった．これは，格フレーム木に使われた格要素の多くが，通常の辞書に使われていたことによる．例えば``take''の格フレーム木では，AX(助動詞相当語句)，D(副詞小詞)，ON(直接目的語名詞句)，SIN(主語の不定詞句)，SN(主語名詞句)が使われていた．この中の，SN，ON，Dは通常の冊子辞書でも頻繁に使われている．さらにこの場合，ルートノード，すなわち訳し分けに最も有効な格要素はDとなっていた．冊子辞書でも副詞小詞は重要な要素と見なされており，動詞と組み合わせて別項として記述されていることが多い．同様の特徴はその他の動詞にも見られた．表~3の第2行と第4行を比べると，入力に与えられた格要素の内，実際に格フレーム木で利用された格要素は少ないことがわかる．また，利用された格要素の多くは冊子辞書でもよく利用されるものであった．それぞれの動詞の格フレーム木に利用された格要素を付録~Cの表~8に示す．訳し分けの精度得られた格フレーム木は，直観では気付きにくい情報を学習していた．図~5のAに示した部分では，ONが何もないときの訳語は「かかる」と学習されている．``take''は通常他動詞として用いられるため，目的語がないというのは不自然な印象を受ける．しかし，対訳コーパスを調査してみると``takeawhile'',``takelong''といった時間表現があることがわかった．これらの表現では，目的語ではなく副詞を伴って「かかる」の意味になっており，妥当な学習と言える．また図~5のBで示した部分では，``takepart''で「参加する」と学習されており，``in''は冗長だとされている．これは通常の辞書の記述とは異なっている．しかし，これも対訳コーパス中に実際に``in''を伴わない用法が見つかり，むしろ望ましい学習と言える．このように格フレーム木の細部を見た場合には，コーパスの動詞を訳し分けるのに適した情報が学習されていた．また，表~3の第5行目には誤訳率を記している．これは，学習に利用した事例を格フレーム木で分類した場合に，誤った訳語が出力された割合である．学習データであっても誤訳率がゼロにならない理由は，格フレーム木を作成するアルゴリズムが，過剰学習を避けるため多少の誤訳を許すように設定されていること(付録A，脚注10,11参照)1文の範囲では訳し分けができない場合があることである．以下具体的に説明する．(I)に該当する例は図~5のCの部分に見られる．ここでは``takehour''(11例)は「かかる」と訳すように学習されたが，3例は誤っている．これらは「必要とする」と訳されなくてはならない．原始格フレーム表を調べてみると，``takehour''の11事例の主語はすべて異なっていた．そこで，このノードの下をさらに主語で分岐すると上記の2つの訳語は正しく分類することができる．ただしこの場合，主語の語形によって11の枝が生成され，リーフには1事例しか分類されない．このためこれは予測力の低い過剰学習であると判定され，このような分岐は実行されない．(II)に相当するのは同一の文でありながら動詞の訳が違う場合である．``make''のコーパスには``Iamgoingtomakeit.''という同一の文章で``make''の訳語が「作る」と「成功する」になる2通りの場合が収録されている．これらの訳語はこの文の格要素だけで訳し分けることはできないため，誤りを含んだまま枝の生成は停止せざるを得ない．この誤りは文脈を扱わない本手法の限界を示すものである．補償的な学習図~5のDでは``takeplace''が「獲得する」と「行われる」に訳し分けられている．前者は``takethirdplace''「3位を獲得する」というコーパスの例文から学習されており，後者は成句表現を学習したものである．前者は通常の辞書には記述されていない．ここで興味深いのは学習された訳し分けの条件である．ここでは主語の性質によって訳し分けられている．すなわち，主語が「人間」の時は「獲得する」となり，「動作名詞」の時は「行われる」となっている．これは言語学的に納得できる条件である．しかし，この訳し分けは``place''の前の修飾語の有無で行うことも可能である．前者は``third''という修飾を受けているが，後者は成句表現であるため，修飾は基本的に受けないからである．この実験の原始格フレーム表には修飾語を利用していないため，このような学習は起こりえない．そこで，これに替わる条件を学習しているのである．このような学習を本論文では「補償的な学習」と呼ぶ．この「補償的な学習」は，その他の格フレーム木でも数多く見られた．例えば図~6(``come''の格フレーム木の一部)では，主語が``it''の場合に，その内容を参照することなく，前置詞を条件として動詞の訳し分けが行われている．また，この条件で事例の分類を行った結果，15事例の内12事例で訳語が正しく選択されている．補償的な学習は，与えられた情報の中で最適な訳し分け条件を見つけ出すアルゴリズムの性質を反映したものであり，ここで述べたように人手で見つけにくい有効な格要素を発見する上で有用である．しかし，この性質は格フレーム木のノードとして本来使うべき格要素を選ばずに，たまたま原始格フレーム表の訳語をきれいに分類する格要素を選択することにつながる場合もある．このため，必ずしも言語学的な直観にあわない格要素が格フレーム木に含まれる場合もあり，その正しさは人間が判定する必要がある．文型による格フレーム木の違い平叙文に比べてその他の文型の事例数が少ないため同列の比較はできないが，文型による格フレーム木の違いはかなり顕著であった．例えば比較的事例数の多かった「to不定詞として用いられた``take''と``make''」の格フレーム木に使われた格要素はON(直接目的語名詞句)だけであった．また，これらの格フレーム木には平叙文で重要であったD(副詞小詞)は出現しなかった．これらのことは，格フレーム木は文型に合わせて作成する必要があることを示唆している．</subsection>
  <subsection title="議論1">本章では，語形を利用した格フレーム木の学習を行った結果，大局的には人間の直観に近い，わかりやすい格フレーム木が獲得された．また，細かく見ると人手で獲得するよりも精密な条件が抽出される場合や，人手では気がつきにくい条件が抽出されることがわかった．ここで問題になるのは格フレーム木の一般性である．本手法では，格要素の制約として語形を使ったため，未学習の事例の動詞を訳し分ける性能には疑問がある．なぜなら，未学習の事例を格フレーム木のルートからリーフへ照合する過程で，制約(アークのラベル)が未知の語形になり，格フレーム木をたどれなくなるからである．そこで，次章ではこの問題を解決する手法を提案して実験を行う．</subsection>
  <section title="意味コードを用いた実験"/>
  <subsection title="意味コードの利用">著者らが利用している学習プログラムでは，事例と格フレーム木との照合中に，あるノードで行き詰まった場合には訳語を予測して出力するようになっている．このプログラムでは格フレーム木の作成と同時に各学習事例がどのリーフに分類されるかを計算しており，リーフにはその頻度が付与されるようになっている(図~5の右端の数字)．そして訳語の予測にはこの頻度を利用している．今，図~5の格フレーム木で，``D=0''かつ``ON=place''かつ``SN=war''という事例を分類しようとすると，SNの制約(war)が未知語であるため訳語が決定できない．このように行き詰まった場合には，先に述べた頻度を利用して，そのノードの下で最も頻度の高い訳語を予測値として出力する．今の場合，行き詰まったノードSNの下で最高の頻度であった「行われる」が出力される．このような予測機能のおかげで未知語は表面上は問題にはならない．しかし，この「局所的な多数決原理」のヒューリスティクスがどれだけ有効であるかは不明である．未知語になる可能性が高いのはオープンクラスの語彙，特に名詞である．これを軽減する手法としては，名詞を意味コードで置換することが考えられる．これによって膨大な数の名詞を一定の分類数で押さえることができるからである．そこで本章では，名詞を意味コードで置換した格フレーム木の獲得を行い，これが未学習の事例の動詞の訳し分けにどの程度有効かを評価する．語形の代わりに意味コードを利用した格フレーム木を獲得するには，原始格フレーム表の語形を意味コードで置き換えて学習すればよい．これには英語の語形がどの意味で使われたかを決定する必要があるが，意味的な曖昧性があるため，英語の語形だけを見たのでは自動的には決定できない．そこで対訳コーパスに意味コードを付与して，これを原始格フレーム表に変換することにした．対訳コーパスには日本語の訳語があり，これが英語の語形の意味を表しているため，比較的容易に英語の語形の意味を決定できるからである．</subsection>
  <subsection title="コーパスへの意味コードの付与">本論文で利用した意味コードは類語国語辞典のコードである．これは，基本的には3桁の10進分類であり，補助的に4桁目が利用されている．4桁すべてを利用すると2,794個の分類となる．意味コードを付与したのは名詞を主辞に取る格要素である:SN(主語名詞句),ON(直接目的語名詞句),CN(補語名詞句),QN(間接目的語名詞句),PNc(前置詞句本体)．意味コードの付与は，あらかじめ作成してあるテーブル，(英単語，日本語訳語，意味コード[，意味コード])の形式，を利用して半自動的に行った．具体的には対訳コーパスの英語と日本語の対応する格要素の主辞をこのテーブルで参照してコードを付与した．意味コードが自動的に付与できない場合には，人手で付与できるものは付与し，それでもわからない名詞については不明を意味するコードを付与した．これはほとんど固有名詞で，人名，地名の判別ができない単語であった．図~7のCODE行に意味コードを付与したデータを示す．この図では2桁の意味コードを与えているが，任意の桁の意味コードを付与できる．</subsection>
  <subsection title="実験方法">5章の実験で用いた平叙文のコーパスに対して，表~4に示す5つの実験を行った．原始格フレーム表に記述する格要素は5章と同じく，コーパスに現われたすべての格要素である．これらの実験の違いは，格要素に与えた制約である．実験1では，制約として語形を与えた．この実験は評価方法を除けば5章の実験と基本的に同じである．実験2--5は，意味コードの粗さと動詞の訳し分けの精度の関係を調べることを目的とし，4桁から1桁の意味コードを制約として与えた．実験に用いたデータの諸元を表~5に記す．この表の第3行の基準誤訳率とは，各動詞での最高頻度の訳語を入力に関わらず出力した場合に発生する誤訳率である．``take''は訳語の分布が平坦であるため，高い基準誤訳率になっている．また第4行には基準誤訳率を与える訳語を記した．格フレーム木の評価は，学習に利用した事例を入力した場合と，学習に利用していない事例を入力した場合の誤訳率で行った．誤訳率は，事例と学習プログラム出力の訳語が一致しなかったものの相対頻度である．このとき，誤訳率の精度を確保するために原始格フレーム表の事例を5分割してクロスバリデーション法で評価した．この手法では，評価データでの誤訳率の計算は以下のように行われる．原始格フレーム表を5つに分割して80%の事例で格フレーム木を学習する．残りの20%の事例をこの格フレーム木で分類し，誤訳率を計算する．この操作を5回，データをシフトしながら行い，訳語の平均誤訳率を算出する．学習データ上での誤訳率も同様に算出した．(以下，誤訳率は平均誤訳率のことである)格フレーム木の獲得に用いたプログラムは5章と同じC4.5(オプションなし，枝刈りなし)である．</subsection>
  <subsection title="結果">実験1--5の学習データ，評価データでの誤訳率を図~8に示す．このデータから次の特徴が読み取れる．実験1:殆どの動詞で評価データでの誤訳率は最大である．実験1--5:学習データ，評価データの誤訳率ともほぼ下に凸の曲線を描いた．極小値を与える分類コードの桁数は動詞によって異なった．いずれの実験でも，評価データ上の誤訳率は基準誤訳率より低い．実験で得られた意味コード(2桁)付きの格フレーム木を図~9に示す．</subsection>
  <subsection title="議論2">本章の実験によって，殆どの動詞で意味コードを抽象化すると評価データ上での誤訳率が一旦減少し，また上昇することが確認された．この理由は，意味コードを利用すれば未知語が減るものの，意味コードが粗くなりすぎると格フレーム木の分類能力が低下するためだと思われる．意味コードが有効に働いたのは，図~9のAで示すような，事例が集中して，かつ訳語が正しく決定された部分である(意味分類コード34は「陳述」を表す)．また，最小の誤訳率を与える意味コードの粒度は動詞によって異なっていた．従来，固定的な意味コードを格フレームに与える場合が多かったが，そこには再考の余地があることをこの結果は示唆している．付録Cの表~9に格フレーム木に採用された格要素を記した．5章の実験と同じように，多くの格要素は冊子辞書に利用されているものであり，得られた格フレーム木は言語学的な直観に合うものであった．本実験での各動詞の評価データ上での最小の誤訳率は2.4%から32.2%となった．これと基準誤訳率の差は13.6%から55.3%となり，かなりの改善が得られている．すべての動詞で十分な精度が得られたわけではないが，``take''のように基準誤訳率が82.8%もあるような動詞に対して誤訳率27.5%が得られたことは，本手法の基本的な有効性を示したものと考えられる．</subsection>
  <section title="むすび">従来の人手による格フレーム獲得の問題点を明らかにし，これを解決する手法を提案した．ここで行った提案は，格フレームを決定木で表現すること(格フレーム木)，および，これを統計的な帰納学習アルゴリズムを用いて対訳のコーパスから獲得することである．この提案に添って語形，意味コードを利用した2種類の実験を行った．得られた結果は以下の通りである．人間の直観に近くかつ精密な情報が学習された．意味コードを利用すると未学習データでの誤訳率が低下した．また，動詞によって最適な意味コードの粒度は異なった．今回，意味コードを利用して得られた誤訳率は，動詞によっては必ずしも低くないものがある．この原因としては，意味コードを利用した格要素では，語形が全く利用されていないことが挙げられる．この結果，本来語形で記述すべき成句的な表現も意味コードで抽象化されており，これが高い誤訳率につながったと考えられる．これを解決するには，同一格要素内で意味コードと語形の両者を柔軟に用いる学習アルゴリズムの開発が必要である．もう一つ，意味コード体系そのものの問題が挙げられよう．著者らが利用した意味コードは動詞の訳し分けを目的に開発された体系ではない．そのため，これが誤訳率を高めている可能性はある．もし，著者らの目的に合うような意味コード体系を利用できれば，さらに誤訳率を減らすことができるであろう．</section>
  <section title="決定木作成アルゴリズム">図~10に基本的なアルゴリズムを示す．ステップ2の終了条件は，基本的には訳語が一種類となることである．ステップ3の「訳語を最も良く分類する格要素を選択する」という部分は以下の手順で決定される．現在の*0.1mmノード*0.1mmの下*0.1mmにある*0.1mm訳語の*0.1mm集合を*0.5mmS*0.5mmと*0.1mmし，*0.5mmそ*0.1mmの*0.1mm大*0.1mmき*0.1mmさ*0.5mm(*0.1mm訳*0.1mm語*0.1mm数*0.1mm)*0.5mmを*1mm|S|*0.5mmと*0.1mmす*0.1mmる*0.1mm．*0.5mmSにはk種類*0.1mmの*0.1mm訳*0.1mm語*0.1mmが*0.1mmあ*0.1mmる*0.1mmと*0.1mmし*0.1mm，*1mm各*0.1mm訳*0.1mm語*0.1mmの*0.1mm名*0.1mm前*0.1mmをC_j(1jk)で*0.1mm表*0.1mmす*0.1mm．(C_j,S)はSの中での訳語C_jの個数を表すとする．そうすると(C_j,S)|S|はSの中での訳語C_jの相対頻度を表し-_2((C_j,S)|S|)はその情報量になる．*-0.2mmここですべての訳語について情報量を計算してその平均を求めると(S)=-_j=1^k(C_j,S)|S|_2((C_j,S)|S|)displaymathとなる．*0.2mmこれは現在の訳語分布が持つエントロピー*0.1mm(乱雑さ)*0.1mmを示す．*0.2mmここである格要素Xを選択する．そしてその制約(単語)によってSがn個の部分集合に分割されたとする．S_i(1in)を各部分集合とする．この各部分集合に対して_X(S)=_i=1^n|S_i||S|(S_i)displaymathを計算するとこれはXを選択した後にできた部分集合が持つエントロピーの平均を表す．これらから(X)=(S)-_X(S)displaymathを計算する．これは分割前と後のエントロピーの減少，すなわち格要素Xを選択して分類したことによる訳語の分布の乱雑さの減少を示している．基本的には，これを最大にするような格要素を最適な格要素として選択する．</section>
  <section title="コーパスに付与したラベルの詳細"/>
  <section title="実験で学習された格要素">document</section>
</root>
