<?xml version="1.0" ?>
<root>
  <title/>
  <author/>
  <jkeywords/>
  <section title="Motivation">Fromtheoreticallinguisticstocomputationalmodelsofnaturallanguage,unification-basedprocessinghasbecomeacentralmethodologyinmanyresearchefforts.Intheoreticallinguistics,unification-basedformalismhasbecomeonestandardformofrepresentation;manytheoriessuchasLFG(),HPSG(),andJPSG()usefeaturestructureandunificationasthebaseofconstraintpostulations.Incomputationallinguistics,unificationisusedasthecentralconstraintprocessingmechanismduringparsingbasedupontheunification-basedgrammaranalyses.Inartificialintelligence,unification-basednaturallanguageisoftenusedasanintegralpartofinferenceandlearningmechanisms.Recenteffortsinmassivelyparallelartificialintelligencehavealsodemonstratedthestrengthofgraphunificationasauniformconstraintprocessingmechanismfornaturallanguageinamassivelyparallelenvironment.Despitethepopularityofunification-basedprocessing,graphunificationhasremainedabottleneckoftheunification-basedsystems.Forexample,inunification-basedgrammarparsingusingparsingalgorithmssuchasEarley'salgorithm()andTomita'salgorithm(),unificationoperationsoftenconsume85to95percentofthetotalcputimedevotedtoaparse.Inonelarge-scaleunification-basedspokenlanguageparser,sometimes98percentoftheelapsedtimeiscalculatedtobedevotedtounificationoperationalone().Furthermore,thenumberofunificationoperationstendstogrowasthegrammargetslargerandmorecomplicated.Anunavoidableparadoxisthatwhenthenaturallanguagesystemgetslargerandthecoverageoflinguisticphenomenaisincreasedasanattempttobringperformancetoapracticallevel,thenumberofunificationoperationsincreasesrapidlyandtheperformanceofthesystemsdegradestoanimpracticallevel.Thusanavailabilityofefficientgraphunificationisofparamountimportancebothtotheoreticalnaturallanguageresearchaswellastopracticalnaturallanguagesystems.Overallparsingefficiencyiscrucialwhenbuildingorexperimentingwithbothpracticalandexperimentalnaturallanguagesystems.Forrealtimepracticalsystems,parsingspeedisaprerequisite.Fortheoreticalexperimentation,theefficiencyofhypothesistestingdependsonthespeedofconstraintprocessing.Avarietyofgrammaticalformalismshavebeenproposedhistoricallyincomputationallinguistics,naturallanguageprocessing,andartificialintelligencetocapturethephenomenacalled`language'.KayproposedFunctionalGrammarandFunctionalUnificationGrammar(FUG,)motivatedbythenotionoffunctionaldescriptionoflanguage.BresnanandKaplandevelopedtheLexicalFunctionalGrammar(LFG,)basedontheframeworkoflexically-orientedlinguistics.Inthearitificialintelligencecommunity,DefiniteClauseGrammar(DCG,)wasdevelopedbyPereiraandWarreninthelogicprogrammingframework.GazdardevelopedGeneralizedPhraseStructureGrammar(GPSG,)inthenontransformationalmodeloflinguisticanalysis.PollardandSagdevelopedHead-drivenPhraseStructureGrammar(HPSG,)inthesimilarnontransformationalframeworkcenteredaroundthenotionofthelinguisticheadofaphrase.GunjidevelopedtheJapanesePhraseStructureGrammar(JPSG,),whichisaJapanesecousinofHPSG.Inthemorecomputationalandimplementationalaspects,PATR-II()wasdevelopedattheSRIAICenterasatheory-neutralsimpleandmathematicallywell-foundedtoolfornaturallanguageprocessing.AtCarnegieMellonUniversity,toaddresstheinefficiencyofunificationalgorithms,pseudounificationandPseudoUnificationGrammarweredevelopedasapartofmachinetranslationresearch().Despitethevarietyofanalysiscapturedinthemoderntheoreticalandcomputationalmodelsoflanguage,alltheabovegrammaticalformalisms(atleastthemodernversionsofthem)usefeaturestructures(normallyrepresentedaslabelleddirectedgraphs)asobjectsforcapturinglinguisticobjectsandusegraphunificationasthecentralconstraintprocessingmechanism.AsPollardandSagputit``InsteadoftheNASAPhysicists'Euclideanspacesanddifferentialequations,though,theformalobjectofchoiceininformation-basedlinguisticsarethingsknownasfeaturestructures''andgraphunificationoperationistheformalmethodofunanimouschoiceinthemodernlinguisticmethodologies.Atleastthreemethodsarecommoninusingunificationduringnaturallanguageprocessing.ThefirstmethodisemployedwhenlinguistictheoriessuchasHPSGaredirectlyimplemented.Lexically-orientedtheoriessuchasHPSGassumenoseparatecontext-freeruleforphrasestructures.Phrasestructurerulesareimplicitlycontainedinsubcategorizationlistswhicharelexicallystored.Therefore,combinedwithuniversalprinciplessuchastheHead-FeaturePrinciple(),whicharealsorepresentedthroughfeaturestructures,parsingisperformedpurelythroughgraphunification.Thesecondmethodwhichismostpopular(,,)isemployedwhengrammaticaltheoriessuchasLFGandGPSG,whichassumecontextfreerules,areadopted.Also,somesystems(suchas)usethismethodforspeed,althoughtheyadoptlexically-orientedformalisms(suchasHPSG)byextractinglexically-specifiedsubcategorizationconstraintsascontext-freerules.Inthesesystems,context-freerulesbaseduponmajorgrammaticalcategories(partsofspeech)areaugmentedwithunification-basedconstraintsthatspecifyactualconstraintsforbuildingupphrasestructures.Thethirdmethodisemployedwhengraph-basedconstraintsareusedintheconceptualmemory-basedrecognitionofnaturallanguageinputs.Inthesesystems(whichoftenassumemassively-parallelspreadingactivationarchitectures)graphsarepropagatedinthenetworkofsemanticmemorynodestoprovidesyntacticconstraintapplicationwhileperformingspreadingactivation-basedconceptualmemoryrecognition(,,)</section>
  <section title="Our Observations and Criteria">Indesigninganefficientgraphunificationalgorithm,wehavemadethefollowingobservationwhichinfluencedthebasicdesignofthenewalgorithmdescribedinthispaper:Inatypicalnaturallanguagesystemwitharelativelysmallgrammarsize,60to80percentofunificationsattemptedduringasuccessfulparseresultinfailure.Asthegrammarsizeincreases,thenumberofunificationfailuresforeachsuccessfulparseincreases.Forexample,inonelarge-scalespeech-to-speechtranslationsystemjointlydevelopmentedbyCMUandATRInterpretingTelephonyResearchLaboratories,weestimatedmorethan90%ofunificationstobefailuresduringasuccessfulparse.Ifaunificationfails,anycomputationperformedandmemoryconsumedduringtheunificationiswasted.Anotherobservationaboutthebehaviourofgraphunificationwhichseemswellacceptedintheexistingliteratureisthat:Copyinganodeplacesaheavyburdenontheparsingsystem.Wroblewski[1987]callsita``computationalsink''.Copyingisexpensiveintwoways:1)ittakestime;2)ittakesspace.Wecalculatedthecomputationtimecostofcopyingtobemorethan90percentofthetotalparsingtimeinourlarge-scalespeech-to-speechtranslationsystem.Wehaveexperiencedinsomecases,overhundredthousandnodeswerecopiedunnecessarilyduringaparseofasinglesentenceusingthelargescalegrammarofourspeech-to-speechtranslationsystem.Thistime/spacecopyingburdenpresentsproblemsinanenvironmentwherecomputationalresourcesarelimitedduetothesizeofthegrammarandotherknowledgesources.(Also,thecreationofunnecessarycopieseventuallytriggersgarbagecollectionsmoreofteninaLispenvironment,whichalsodegradestheoverallperformanceoftheparsingsystem.)Ingeneral,parsingsystems(suchaslargeLRtablesofTomita-LRparsers,expandingtablesandchartsofEarley,andactivechartparsers)arealwaysshortofmemoryspace.Ourownphoneme-basedgeneralizedLRparserforspeechinputisalwaysrunningonaswappingspacebecausetheLRtableistoobig,andthemarginaladditionorsubtractionofmemoryspaceconsumedbyotherpartsofthesystemoftenhascriticaleffectsontheperformanceofthesesystems.Becauseofthemassiveamountofnodescreated(copied)duringaparseintheunificationalgorithms(oftenover100,000nodesduringasingleparse),wehaveseenatCMUandatATRthattheamountofmemory(conses)consumedbycopyingoperationsduringaparsedeterminesthenecessaryphysicalmemoryfortheentiresystem.Withtheaforementionedobservations,weproposethefollowingprinciplestobethedesirableconditionsforanefficientgraphunificationalgorithm:Copyingshouldbeperformedonlyforsuccessfulunifications.Unificationfailuresshouldbefoundassoonaspossible.Bywayofdefinition,wewouldliketocategorizeexcessivecopyingofgraphsintoOverCopyingandEarlyCopying.Wroblewski[1987]alsodefinesOverCopyingandEarlyCopying.OurdefinitionofovercopyingisthesameasWroblewski's;however,ourdefinitionofearlycopyingisslightlydifferent.OverCopying:Twographsarecreatedinordertocreateonenewgraph.Thistypicallyhappenswhencopiesoftwoinputgraphsarecreatedpriortoadestructiveunificationoperationtobuildonenewgraph.EarlyCopying:Copiesarecreatedpriortothefailureofunificationsothatcopiescreatedsincethebeginningoftheunificationuptothepointoffailurearewasted.WroblewskidefinesEarlyCopyingasfollows:``Theargumentdagsarecopiedbeforeunificationstarted.Iftheunificationfailsthensomeofthecopyingiswastedeffort.''Herestrictsearlycopyingtocasesthatonlyapplytocopiesthatarecreatedpriortoaunification.Restrictingearlycopyingtorepresentcopiesthatarecreatedpriortoaunificationleavesanumberofwastedcopiesthatarecreatedduringthesameunificationuptothepointofthedetectionoffailure.Therefore,thesewastedcopieswillnotbecoveredbyeitheroftheabovetwodefinitionsforexcessivecopying.WewouldlikeEarlyCopyingtomeanallcopiesthatarewastedduetoaunificationfailure,whetherthesecopiesarecreatedbeforeorduringtheunification.</section>
  <section title="The Quasi-Destructive Graph Unification Algorithm">Wewouldliketointroduceanalgorithmwhichaddressesthecriteriaforfastunificationdiscussedintheprevioussection.Thisalgorithmreplacesthealgorithmdescribedinwithrefineddatastructuresandwithfullcompatibilitywithcyclicfeaturestructures.Itnaturallyhandlescycleswithoutovercopying(withoutanyadditionalschemessuchasthoseintroducedbyKogure[1989]).Asadatastructure,anodeisrepresentedwithsixfields:`type',`arc-list',`comp-arc-list',`forward',`copy',and`generation'.Thedata-structureforanarchastwofields,`label'and`value'.`Label'isanatomicsymbolwhichlabelsthearc,and`value'isapointertoanodestructure(Figure~).ThecentralnotionoftheQ-Dalgorithmisthedependencyoftherepresentationalcontentontheglobaltimingclock(ortheglobalcounterforthecurrentgenerationofunifications).Anymodificationmadetocomp-arc-list,forward,orcopyfieldsduringonetop-levelunificationcanbeinvalidatedbyoneincrementoperationontheglobaltimingcounter.Contentsofthecomp-arc-list,forwardandcopyfieldsarerespectedonlywhenthegenerationmarkoftheparticularnodematchesthecurrentglobalcountervalue.Q-Dgraphunificationhastwokindsofarclists:1)arc-listand2)comp-arc-list.Arc-listcontainsthearcsthatarepermanent(i.e.,ordinarygrapharcs)andcomp-arc-listcontainsarcsthatarevalidonlyduringonetop-levelunificationoperation.Thealgorithmalsousestwokindsofforwardinglinks,i.e.,permanentandtemporary.Apermanentforwardinglinkistheusualforwardinglinkfoundinotheralgorithms(,,etc).Temporaryforwardinglinksarelinksthatarevalidonlyduringonetop-levelunification.Thecurrencyofthetemporarylinksisdeterminedbymatchingthecontentofthegenerationfieldforthelinkswiththeglobalcounter;iftheymatch,thecontentofthisfieldisrespected.AsinPereira[1985],theQ-Dalgorithmhasthreetypesofnodes:1):atomic,2):Top,and3):complex.The:atomictypenodesrepresentatomicsymbolvalues(suchas`Noun'),:Toptypenodesarevariables,and:complextypenodesarenodesthathavearcscomingoutofthem.Arcsarestoredinthearc-listfield.Theatomicvalueisalsostoredinthearc-listifthenodetypeis:atomic.:Topnodessucceedinunifyingwithanynodesandtheresultofunificationtakesthetypeandthevalueofthenodewithwhichthe:Topnodeisunified,:atomicnodessucceedinunifyingwith:Topnodesorwith:atomicnodeswiththesamevalue(storedinthearc-list).Unificationofan:atomicnodewitha:complexnodeimmediatelyfails.:complexnodessucceedinunifyingwith:Topnodesorwith:complexnodeswhosesubgraphsallunify.Whatfollowsarethecentralquasi-destructivegraphunificationalgorithmandthedereferencingfunction.Followingisthealgorithmdescriptionforcopyingnodesandarcs(calledfromunify0)whilerespectingthecontentsofcomp-arc-lists.*4mm[6.5cm]Quasi-DestructiveGraphUnification*-3mmFUNCTIONunify-dg(dg1,dg2);*2mm=result==catchwithtag'unify-fail&gt;&gt;&gt;callingunify0(dg1,dg2);&gt;increment*unify-global-counter*;;;startsfrom10&gt;return(result);END;FUNCTIONunify0(dg1,dg2);&gt;if='*T*=unify1(dg1,dg2);THEN&gt;&gt;copycopy-dg-with-comp-arcs(dg1);&gt;&gt;return(copy);END;FUNCTIONunify1(dg1-underef,dg2-underef);*2mm=dg1dereference-dg(dg1-underef);&gt;dg2dereference-dg(dg2-underef);&gt;IF=(dg1.copyisnon-empty)THEN&gt;&gt;dg1.copynil;;;cutoffuncurrentcopy&gt;IF&gt;(dg2.copyisnon-empty)THEN&gt;&gt;dg2.copynil;&gt;IF&gt;(dg1_dg2)THEN&gt;&gt;return('*T*);&gt;ELSEIF(dg1.type=:Top)THEN&gt;&gt;forward-dg(dg1,dg2,:temporary);&gt;&gt;return('*T*);&gt;ELSEIF(dg2.type=:Top)THEN&gt;&gt;forward-dg(dg2,dg1,:temporary);&gt;&gt;return('*T*);&gt;ELSEIF(=dg1.type=:atomicAND&gt;&gt;dg2.type=:atomic)THEN&gt;*15mm=IF=(dg1.arc-list=dg2.arc-list)THEN&gt;&gt;&gt;forward-dg(dg2,dg1,:temporary);&gt;&gt;&gt;return('*T*);&gt;&gt;ELSEthrowwithkeyword'unify-fail;&gt;ELSEIF(=dg1.type=:atomicOR&gt;&gt;dg2.type=:atomic)THEN&gt;&gt;throwwithkeyword'unify-fail;&gt;ELSE=sharedintersectarcs(dg1,dg2);&gt;*6mm=FOREACHarcINsharedDO&gt;&gt;*10mmunify1(=destinationof&gt;&gt;&gt;*7mm=thesharedarcfordg1,&gt;&gt;&gt;destinationof&gt;&gt;&gt;&gt;thesharedarcfordg2);&gt;&gt;forward-dg(dg2,dg1,:temporary);&gt;&gt;newcomplementarcs(dg2,dg1);&gt;&gt;IF(=dg1.comp-arc-listisnon-empty)THEN&gt;&gt;&gt;IF(=dg1.generation=*unify-global-counter*)THEN&gt;&gt;&gt;&gt;FOREACHarcnewDO&gt;&gt;&gt;&gt;*10mmpusharctodg1.comp-arc-list;&gt;&gt;&gt;ELSEdg1.comp-arc-listnil;&gt;&gt;ELSE=dg1.generation*unify-global-counter*;&gt;&gt;&gt;dg1.comp-arc-listnew;&gt;&gt;return('*T*);END;tabbingfootnotesize[9]OurconventioninourQ-Dimplementationsisthattheglobalcounterisincrementedfrom10.Therefore,forthetemporarylinks(contents)toberespected,thegenerationnumberslargerthan9needtomatchtheglobalcounter.Alsoourconventionsisthatweusethenumber9toindicateapermanentforwardinglink.Therefore,ifthegenerationnumberofthenodeis9thentheforwardinglinkisalwaysrespectedregardlessofthecurrentcontentoftheunify-global-counter.[10]Asdiscussedpreviously,thisrepresents`equal'inthe`eq'sense.Becauseofforwardingandcycles,itispossiblethatdg1anddg2are`eq'.[11]Arc-listcontainsatomicvalueifthenodeisoftype:atomic.[12]Catch/throwconstruct;i.e.,immediatelyreturntounify-dg.[13]Thiswillbeexecutedonlywhenallrecursivecallsintounify1havesucceeded.Otherwise,afailurewouldhavecausedanimmediatereturntounify-dg.[14]Complementarcs(dg2,dg1)wascalledbeforeunify1recursionsin,Currentlyitisrelocatedtoafterallunify1recursionssuccessfullyreturn.ThanksareduetoMarieBoyleoftheUniversityofTuebingenforsuggestingthis.[15]Thischeckwasaddedaftertoavoidover-writingthecomp-arc-listwhenitiswrittenmorethanoncewithinoneunify0call.ThanksareduetoPeterNeuhausofUniversit&quot;atKarlsruheforreportingthisproblem.[6.5cm]GraphNodeDereferencing*-3mmFUNCTIONdereference-dg(dg);*2mm=forward-destdg.forward;&gt;IF=(forward-destisnon-empty)THEN&gt;&gt;IF(=dg.generation=*unify-global-counter*OR&gt;&gt;&gt;dg.generation=9)THEN&gt;&gt;&gt;return(dereference-dg(forward-dest));&gt;&gt;ELSE=dg.forwardnil;&gt;&gt;&gt;return(dg);&gt;ELSEreturn(dg);END;tabbingfootnotesizeThefunctionsComplementarcs(dg1,dg2)andIntersectarcs(dg1,dg2)returntheset-difference(thearcswithlabelsthatexistindg1butnotindg2)andintersection(thearcswithlabelsthatexistbothindg1anddg2).Duringtheset-differenceandset-intersectionoperations,thecontentofcomp-arc-listsarerespectedaspartsofarclistsifthegenerationmarkmatchesthecurrentvalueoftheglobaltimingcounter.Forward-dg(dg1,dg2,:forward-type)puts(thepointerto)dg2intheforwardfieldofdg1.Ifthekeywordinthefunctioncallis:temporary,thecurrentvalueofthe*unify-global-counter*iswritteninthegenerationfieldofdg1.Ifthekeywordis:permanent,9iswritteninthegenerationfieldofdg1.Thetemporaryforwardinglinksarenecessarytohandlereentrancyandcycles.Assoonasunification(atanylevelofrecursionthroughsharedarcs)succeeds,atemporaryforwardinglinkismadefromdg2todg1(dg1todg2ifdg1isoftype:Top).Thus,duringunification,anodealreadyunifiedbyotherrecursivecallstounify1withinthesameunify0callhasatemporaryforwardinglinkfromdg2todg1(ordg1todg2).Asaresult,ifthisnodebecomesaninputargumentnode,dereferencingthenodecausesdg1anddg2tobecomethesamenodeandunificationimmediatelysucceeds.Thus,asubgraphbelowanalreadyunifiednodewillnotbecheckedmorethanonceevenifanargumentgraphhasacycle.*4mm[6.5cm]Quasi-DestructiveCopying*-3mmFUNCTIONcopy-dg-with-comp-arcs(dg-underef);*2mm=dgdereference-dg(dg-underef);&gt;IF(=dg.copyisnon-emptyAND&gt;&gt;dg.copy.generation=*unify-global-counter*)THEN&gt;&gt;return(dg.copy);&gt;ELSEIF(dg.type=:atomic)THEN&gt;&gt;newcopycreate-node();&gt;&gt;newcopy.type:atomic;&gt;&gt;newcopy.arc-listdg.arc-list;&gt;&gt;newcopy.generation*unify-global-counter*;&gt;&gt;dg.copynewcopy;&gt;&gt;return(newcopy);&gt;ELSEIF(dg.type=:Top)THEN&gt;&gt;newcopycreate-node();&gt;&gt;newcopy.type:Top;&gt;&gt;newcopy.generation*unify-global-counter*;&gt;&gt;dg.copynewcopy;&gt;&gt;return(newcopy);&gt;ELSE&gt;&gt;newcopycreate-node();&gt;&gt;newcopy.type:complex;&gt;&gt;newcopy.generation*unify-global-counter*;&gt;&gt;dg.copynewcopy;&gt;&gt;FORALLarcINdg.arc-listDO&gt;&gt;*4mm=newarccopy-arc-and-comp-arc(arc);&gt;&gt;&gt;pushnewarcintonewcopy.arc-list;&gt;&gt;IF(=dg.comp-arc-listisnon-emptyAND&gt;&gt;&gt;dg.generation=*unify-global-counter*)&gt;&gt;*10mm=FORALLcomp-arcINdg.comp-arc-listDO&gt;&gt;&gt;*3mm=newarccopy-arc-and-comp-arc(comp-arc);&gt;&gt;&gt;&gt;pushnewarcintonewcopy.arc-list;&gt;&gt;dg.comp-arc-listnil;&gt;&gt;return(newcopy);END;FUNCTIONcopy-arc-and-comp-arc(input-arc);*2mm=labelinput-arc.label;&gt;valuecopy-dg-with-comp-arcs(input-arc.value);&gt;returnanewarcwithlabelandvalue;END;tabbingfootnotesize[18]I.e.,the`generation'fieldofthenodestoredinthe`copy'fieldofthe`dg'node.Thealgorithmdescribedinused`copy-mark'fieldof`dg'.Currently`generation'fieldreplacesthethreemarkfielddescribedinthearticle.[19]I.e.,theexistingcopyofthenode.[20]Createsanemptynodestructure.Bytheway,sinceatomicvaluesneverchange,itmakesnosensetomakeacopyofatomicnodes.Itissafetosharetheatomicnodeswiththeoriginalgraph.Therefore,thereader'softhispapershouldreplaceELSEIF(dg.type=:atomic)THEN::return(newcopy);byELSEIF(dg.type=:atomic)THENreturn(dg);tosimplyreturntheoriginaldgfortheiractualimplementations.ItisnotdonesointhispaperforafaircomparisonwithWroblewski'salgorithmsincehisalgorithmcopieseachatomicnode.[21]Thisoperationtosetanewlycreatedcopynodeintothe`copy'fieldof`dg'wasdoneafterrecursionintosubgraphsinthealgorithmdescriptioninwhichwasacauseofinfiniterecursionwithaparticulartypeofcyclesinthegraph.Bymovinguptothispositionfromaftertherecursion,suchaproblemcanbeeffectivelyavoided.ThanksareduetoPeterNeuhausforreportingtheproblem.Letuswalkthroughasimpleunificationexamplefirst.WhatfollowsinthefollowingtwopagesusingFigures~andisasimpleunificationoftwographsdg1anddg2whichrepresentfeaturestructures:dg1dg2[[aS][[aX01[]][b[]]][bX01][ct]]verbatimFirst,top-levelunify-dgcallsunify0whichinturncallsunify1.Unify0willperformquasi-destructivecopyingoperationafterthetoplevelcalltounify1successfullyreturns.Nowtop-levelunify1findsthateachoftheinputgraphshasarcswithlabelsaandb().Fornowwerepresentarcswithlabelaasarc-a.Thenunify1isrecursivelycalled(unify1(2,5)).Atsteptwo,therecursionintoarc-alocallysucceeds,andatemporaryforwardinglinkwithtime-stamp(n)ismadefromnode5tonode2.Atthethirdstep(recursionintoarc-b),bythepreviousforwardingtonode2,node5alreadyhasthevalueS(bydereferencing).Thenthisunificationreturnsasuccessandatemporaryforwardinglinkwithtime-stamp(n)iscreatedfromnode3tonode2.Atthefourthstep,sinceallrecursiveunifications(unify1s)intosharedarcssucceeded,top-levelunify1createsatemporaryforwardinglinkwithtime-stamp(n)fromdg2'srootnode4todg1'srootnode1,andsetsarc-c(new)intocomp-arc-listofdg1andreturnssuccess('*T*).Atthefifthstep,acopyofdg1iscreatedrespectingthecontentofcomp-arc-listanddereferencingthevalidforwardlinks.Thiscopyisreturnedasaresultofunification.Atthelaststep(stepsix),theglobaltimingcounterisincremented(nn+1).Afterthisoperation,temporaryforwardinglinksandcomp-arc-listswithuncurrenttime-stamp(n+1)willbeignored.Therefore,theoriginaldg1anddg2arerecoveredinconstanttimewithoutacostlyreversingoperation.(Also,notethatrecursionsintoshared-arcscanbedoneinanyorder,producingthesameresult).Aswejustsaw,thealgorithmitselfissimple.Theessentialdifferencebetweenourunify1andthepreviousonessuchasPereira'sisthatourunify1isnon-destructive.Thatissobecausethecomplementarcs(dg2,dg1)aresettothecomp-arc-listofdg1andnotintothearc-listofdg1.Thus,assoonasweincrementtheglobalcounter,thechangesmadetodg1(i.e.,additionofcomplementarcsintocomp-arc-list)vanish.Aslongasthegenerationvaluematchesthatoftheglobalcounter,thecontentofthecomp-arc-listcanbeconsideredapartofarc-listandtherefore,dg1istheresultofunification.Hencethenamequasi-destructivegraphunification.Inordertocreateacopyforsubsequentuse,weonlyneedtomakeacopyofdg1beforeweincrementtheglobalcounter,whilerespectingthecontentofthecomp-arc-listofdg1.Thisway,insteadofcallingotherunificationfunctions(suchasunify2ofWroblewski)forincrementallycreatingacopynodeduringaunification,weneedonlytocreateacopyafterunification.Thus,ifunificationfails,nocopiesaremadeatall(asinKarttunen'sscheme,).Becauseunificationthatrecursesintosharedarcscarriesnoburdenofincrementalcopying(i.e.,itsimplycheckswhethernodesarecompatible),asthedepthofunificationincreases(i.e.,asthegraphgetslarger)thespeed-upofourmethodshouldbecomeconspicuousifaunificationeventuallyfails.Sinceaparsethatdoesnotfailonasingleunificationisunrealistic,thegainfromourschemeshoulddependonthenumberofunificationfailuresthatoccurduringaunification.Asthegrammarsizeincreases,thenumberoffailuresperparsetendstoincreaseandthegraphsthatfailunificationsgetlarger,andthespeed-upfromouralgorithmshouldbecomemoreapparent.Therefore,thecharacteristicsofouralgorithmseemdesirable.Thequasi-destructivecopyingafterunificationcopiesthedg1sbysimplyfollowingtemporaryforwardingpointers.UnlikeEmele'smethod(),thetemporaryforwardingdoesnotglowsincethereisnochronologicalderefencing.Afterasuccessfulunification,oneincrementintheglobalcounterinvalidatesallchangesmadetothegraph.WeuseanothersimpleexampleasshowninFigure~andFigure~.Notethatunify-dg(dg1,dg2)andunify-dg(dg2,dg1)getthesameresults.TheresultshouldbeasinFigure~.Wecanseethatonlyaminimumnumberofcopiesarecreated.,forabitmorecomplicatedexample(Figure~,Figure~),butonethatworksinasimilarmanner.AndtheresultinFigure~comesadifficultexample.Notonlymightitsworkingsbedifficulttofollow,itwasimpossibleformostpastunificationalgorithms.Butifyoufollowthesimpleruleoftraversingthearcs,andifyoufind[],justforwardittothecounterpart.Addthecomplementarcsintocomp-arc-list,anditturnsoutthattheunificationisratherstraightforwardintheQ-Dframework.Wewillusefourfigures(Figures~,,,and)todepictthisone.Thefirststepistoforwardthedg2/&lt;a&gt;whichis[]todg1/&lt;a&gt;(Figure~11).(Ourconventionisthatdg2/&lt;a&gt;representsthesubgraph(node)thatisthedestinationofthearcaofthegraphdg2.)Thenweunifydg1/&lt;b,d&gt;anddg2/&lt;b,d&gt;.Sincebothare[],dg1/&lt;b,d&gt;getsforwardedtodg2/&lt;b,d&gt;(seethealgorithm).Nowwetraverseintoarc-candunifydg1/&lt;c&gt;anddg2/&lt;c&gt;.Wefindthatdg1/&lt;c&gt;isalreadyforwardedtodg2/&lt;b,d&gt;soactuallyweareunifyingthedg2/&lt;b,d&gt;withdg2/&lt;c&gt;.Sincedg2/&lt;b,d&gt;thenis[],itsucceedsanddg2/&lt;b,d&gt;isforwardedtodg2/&lt;c&gt;.Thisistheendoftherecursionsintothesharedarcs.Now,arc-fisthecomplementarc(dg2,dg1)therefore,itisputintothecomp-arc-listofdg1.Thisistheendoftherecursivecallstounify1(Figure~).Nowunify1returnsandunify0makesacopyofdg1respectingthecurrentforwardingandcomp-arc-list(Figure~).OnefinalnoteisthatwhenQ-Dcopyingrecursesintothearc-eofdg2byfollowingthetemporaryforwardinglinkswhilemakingacopyofdg1,thetopnodeofdg2willnotbecopiedtwice.Thisissobecausewhenthetop-levelunify1returns,thetemporaryforwardingfromthetopnodeofdg2todg1ismade,therefore,whenthecyclicarc-etriestomakeacopyofthetopnodeofdg2,itfindsthatthetopnodeisalreadyforwardedtothetopnodeofdg1.Sincethetopnodeofdg1wasalreadycopiedatthebeginningoftheQ-Dcopyingofdg1,thealready-madecopyissimplyreturned(seethefirstIFintheQ-DCopyingalgorithm).Finally,wewouldliketoprovidetheexampleofanothercyclicgraphunification(Figure~).ItistheunificationofthecyclicgraphswhichPollardandSagonceregardedasnotunifiable.Weclaimedinthatfromourdefinitionofthesubsumptionrelation,theunificationofthesegraphsshouldbeperfectlyreasonable.AlsocurrentversionofHPSGacceptsthiskindofunificationascorrect.Actually,wecanseethatunificationofthesestructuresisrathertrivialthroughQ-Dalgorithm.Firstwedounify1(dg1/&lt;a&gt;,dg2/&lt;a&gt;).Sincedg2/&lt;a&gt;is[]weforwardfromittodg1/&lt;a&gt;asinFigure~.Nextwedounify1(dg1/&lt;b&gt;,dg2/&lt;b&gt;)andthistimedg1/&lt;b&gt;is[]andweforwardittodg2/&lt;b&gt;suchthattheresultisasinFigure~.Finally,wesimplymakeacopyofdg1asusual.WhenweQ-Dcopydg1/&lt;a,a&gt;sinceitisforwardedtodg2/&lt;b&gt;wecopythearcbelowwhichpointstodg2/&lt;b,a&gt;.Sinceitisforwardedtodg1/&lt;a&gt;,wecancopythatnode.Nowwefindthatthisnodewasalreadycopiedwhenwetraversedownthearc-aondg1,sowesimplyreturnthecopythatisalreadystoredinthe`copy'fieldofdg1/&lt;a&gt;(Fig.~).Thisway,wecanseethatunificationofthesefeaturestructuresispossibleandactuallytrivialusingtheQ-Dscheme.</section>
  <section title="Empirical Results"/>
  <subsection title="Comparison using actual grammar">ThissectiondescribestheempiricalresultsobtainedfromoursampleimplementationsoftheQ-Dandotheralgorithms.Table~showsthesummaryoftheresultsofourexperimentsusinganHPSG-basedJapanesegrammarfortheconferenceregistrationtelephonedialoguedomain.Weused16samplesentencesprovidedbyATRforthedomain.ThegrammarusedintheexperimentswasoriginallydevelopedbyATRasalargescalespoken-Japaneselanguagegrammar(containingover10,000grammarnodes)andisscaleddown(about3,000grammarnodes)torunonaSunSparc2with28megabytesofphysicalmemory.WeusedEarley'sparsingalgorithmfortheexperiment.AlthoughitisscaleddownfromtheATR'sAsuragrammar,itcoversmanyoftheimportantlinguisticphenomenainspokenJapanese.Thecoveredphenomenaincludecoordination,caseadjunction,adjuncts,control,slashcategories,zero-pronouns,interrogatives,WHconstructs,andsomepragmatics(speaker,hearerrelations,politeness,etc.)().The16sampletelephoneconversationsentencesusedintheexperimentsvariedfromshortsentences(oneword,i.e.,hai`yes')torelativelylongones(suchas,whichmeans`Inthatcase,we[speaker]willsend[polite]you[hearer](the)registrationform.').Thus,thenumberof(top-level)unificationspersentencevariedwidely(from7toover4,000).`Unifs'inthetablerepresentsthetotalnumberoftop-levelunificationsduringaparse(i.e,thenumberofcallstothetop-level`unify-dg',andnot`unify1').Thus,`Unifs'isnotthetotalnumberofunificationsrecursivelycalledduringaparse.Itisonlythenumberoftop-levelunificationscalledbytheparserduringtheanalysisofasentence.Normally,duringaparse,`unify1'iscalledseveraltimesmoreoftenthan`unify-dg'(`Unifs').Forexample,fortheparseofthesentence12,`unify-dg'(`Unifs')werecalled3,421timesandduringthisparse,unify1wascalled22,674timesfortheQ-Dalgorithm.Forsentence13,itwas4,236and27,605respectively.`USrate'representstheratioofsuccessfulunificationstothetotalnumberofunifications.`NumberofCopies'representsthenumberofnodescreatedduringeachparse.`CPU-Time(non-gcuser)'istheactualparsingtimeforasentenceinmilli-seconds(1/1000thofasecondormsec)notcountingthetimetakenforgarbagecollection.(TheparserandtheunificationalgorithmsareimplementedinCommonLisp).`CPU-Time(totaluser)'includestheadditionaltimerequiredforgarbagecollectionthatproceedsinthebackground.ThealgorithmscomparedwereQuasi-DestructiveGraphUnification(Q-D),Wroblewski'salgorithm(W)(),andKarttunen'salgorithm(K)().WedidnotadoptPereira'salgorithmfortheexperimentssinceKarttunen'salgorithmhasbeenreportedtobemoreefficient.Also,wecouldnotfindanefficientwayofhandlingcyclesusingPereira'salgorithm.WeadoptedWroblewski'salgorithm(enhancedbyKogure'smethodforhandlingcycles)asrepresentativeoftheincrementalcopyingschemessinceasignificantspeed-upoverWroblewski'shasnotbeenreportedinincrementalschemes.Actually,Wroblewski'salgorithmhadbeenconsideredthefastestgraphunificationalgorithmuntilweproposedouroldversionoftheQ-Dalgorithmin1991().Additionally,amongotherincrementalschemes,wecouldnotfindamethodtohandlecyclesusingEmele'salgorithm()efficientlyandtherefore,Emele'salgorithmisnotadoptedforthisexperiment.BecauseoftheeaseofimplementingWroblewski'salgorithm,itshouldbeeasytocomparetheperformanceofanyfutureincrementalschemesagainsttheperformanceofWroblewski'salgorithmandtoindirectlycomparethemwiththeperformanceofQ-DandKarttunen'salgorithmsreportedinthispaper.TheEarleyparserandtheunificationalgorithmsarewritteninCommonLispandarerunonaSUNSparc2with28megabytesofRAM.[htb]Comparisonofthreemethods-NumberofCopiesandCPUusertimeSent#UnifsUSrateNumofCopiesCPU-Time(non-gcuser)CPU-Time(totaluser)Q-D&amp;KWQ-DWKQ-DWK170.42799618425025018425025023700.386333811819172534988319173900124833190.2111117226726725026726725042190.5146546036156719334334156719335850524330.3850220662041623324033352817410505146743756762450.3736704569145016673850145016673850770.42799620030025020030025083140.48600974262584280070662584280010166919960.323802453354107841751622368330700393833205831028110.42597628644828883428495962665443395733784700112230.43391054541316168341831316168341831234210.34761611034272721751750653233514341364349245501342360.381113071355044116711268395706693433225933137185014950.441218150461771775061771775015870.481513168573388398373388398316870.4815131685733884950783884950total1657036456348177813585226274928158142826685642343879215(4.8verbatimsmalltable*UsingthedatashownintheTable~,Figure~andFigure~areplottingsofthetotalparsingtime(includingthetimerequiredforgarbagecollectionwhichisperformedinthebackground).Figure~representsthecomparisonoftheallthreeandFigure~excludesKarttunen'salgorithm.NotealsothatascanbeseenfromtheTable~,parsingtimenotincludingtheGCtime,ifplotted,wouldhavetheidenticalslopes.QDSintheplottingsrepresenttheQ-Dalgorithmwithstructure-sharingasproposedin.Althoughthediscussionsofthestructure-sharingschemeisnotthescopeofthispaper,sincemostoftheup-to-dateimplementationsoftheQ-Dalgorithmincludestructure-sharing,theplottingsforQDSareincludedforthereferencepurposes.</subsection>
  <subsection title="Comparison using a simulated grammar">WehaveseenintheprevioussectionthattheQ-Dalgorithmrunsatover10timesthespeedofKarttunen'salgorithmand2timesthespeedofWroblewski'salgorithm.Thespeedwasobtainedbaseduponthesamplegrammarwhichprovidestheunificationsuccessrate(USRate)ofabout40to48percentwiththe16samplesentences.Aswediscussedearlier,thestrengthoftheQ-DalgorithmsdependslargelyonthelevelsofUSRate.WiththelowerUSRate,thestrengthoftheQ-Dalgorithmsshouldbemoreconspicuouscomparedtotheincrementalalgorithmssincesignificantlyfewercopiesgetwastedduetounificationfailures.Inthissection,wewouldliketoexaminethebehaviouroftheQ-DschemeunderdifferentUSRates.SinceexistinggrammarsnormallyproduceconsistentUSRatesfordifferentsentences,weneedtosimulatedifferentUSRatesusinganartificialgrammar.InordertosimulatedifferentUSRateswefirstdefinethreesimplerules(baseduponHPSG/JPSGframework)asseenbelows.Rule1istheHead-FeaturePrinciple,Rule2istheSubcatPrincipleandRule3istheAdjunctPrinciple.rule1:X01[[DTRSX02[[DTR1X03[[SYNX04[[HEADX05[]]]]][SYNX06[[HEADX05]]rule2:X01[[DTRSX02[[DTR1X03[[SYNX04[[HEADX05[[COHX06[]]]]][DTR2X07[[SYNX08[[SUBCATX09[[FIRSTX06][RESTX10[]]]]]][SYNX11[[SUBCATX10]]rule3:X01[[DTRSX02[[DTR1X03[[SYNX04[[HEADX05[[COHX06[]]]]][DTR2X06]]verbatimfootnotesizeWecombinethesethreerules,i.e.,(unify-dg(unify-dgrule1rule2)rule3)),andproduceonerulegraphdg1whichis:dg1:X01[[DTRSX02[[DTR1X03[[SYNX04[[HEADX05[[COHX06[[SYNX07[[SUBCATX08[[FIRSTX06][RESTX09[]]]]]]]][DTR2X06]][SYNX10[[HEADX05][SUBCATX09]]verbatimfootnotesizeNotethatdg1representsthethreebasicprinciplesofJPSG/HPSGandthereforecharacterizestypicalunification-basedgrammarruleswhichareusedmanytimesduringaparse.Notealsothatdg1iscyclic.Giventhatthecycleistheresultofcombiningtheprinciples,theapplicationofthecyclicrulesareacommonoccuranceusingtheJPSG/HPSGgrammarformalismslikethisone.Now,weprovidetwolexicalentrieswhicharemutuallyexclusive.(Unificationbetweenthemwouldfail.)lex1:X01[[SYNX02[[HEADX03[[AGRX04[[GENX05FEM][NUMX06SING][PERSX07THIRD]][CASEX08-MINIATIVE][MAJX09N][NFORMX10NORMAL][PREDX11MINUS]]]lex2:X01[[SYNX02[[HEADX03[[AGRX04[[GENX05FEM][NUMX06SING][PERSX07THIRD]][CASEX08OBJECTIVE][MAJX09N][NFORMX10NORMAL][PREDX11MINUS]]]verbatimfootnotesizeWeunifydg1withlex1andgetdg2:dg2:X01[[DTRSX02[[DTR2X03[[SYNX04[[SUBCATX05[[RESTX06[]][FIRSTX03]]]][DTR1X07[[SYNX08[[HEADX09[[COHX03][PREDX10MINUS][NFORMX11NORMAL][MAJX12N][CASEX13-MINIATIVE][AGRX14[[PERSX15THIRD][NUMX16SING][GENX17FEM]]]]]][SYNX18[[SUBCATX06][HEADX09]]verbatimfootnotesizeWealsounifylex2withdg1andgetdg3:dg3:X01[[DTRSX02[[DTR2X03[[SYNX04[[SUBCATX05[[RESTX06[]][FIRSTX03]]]][DTR1X07[[SYNX08[[HEADX09[[COHX03][PREDX10MINUS][NFORMX11NORMAL][MAJX12N][CASEX13OBJECTIVE][AGRX14[[PERSX15THIRD][NUMX16SING][GENX17FEM]]]]]][SYNX18[[SUBCATX06][HEADX09]]verbatimfootnotesizeTheexperimentisasfollows:Wesuccessfullyunifydg1withdg2.Weunsuccessfullyunifydg2withdg3.WeplottherelationbetweentheCPUtime(non-gc)andthenumberoftop-levelunificationsfordifferentnumbersoftop-levelunifications.(Namely,10,100,200,400,800,1600,3200,6400,12800,25600,51200,and102400times.)WecollectdataforUSRate0.0,0.25,0.5,0.75,and1.0.Whenallunificationsarebetweendg2anddg3thentheUSRateis0.0.Ifoneoutoffourisbetweendg2anddg3andtherestarebetweendg1anddg2thentheUSRateis0.25.Thedescribedexperimentwasperformedfor5differentkindsofUSRates.WecomparedtheQ-DalgorithmandWroblewski'salgorithm.Figures~toshowtheresultsoftheexperimentsundertheUSRates0.0,0.5and1.0.Wedidnotplotfor0.25and0.75tosavespace;however,theslopesforthosewereexactlyinbetweentheplottedslopes.OnethingtobenotedisthattheQ-DalgorithmrunsfasterthanWroblewski'sevenwiththe100percentunificationsuccessrate.ItisprobablybecauseWroblewski'salgorithmneedstwoset-differenceoperations(complementarcs)inordertocreatecopiesincrementally.Also,handlingcyclesinWroblewski'salgorithmisaddingasmallamountofoverheadtohisalgorithm.</subsection>
  <section title="Discussion: Comparison to Other Approaches"/>
  <subsection title="Concerning Incremental Copying">Wrobleskiintroducedaschemeforefficientunificationbaseduponthenotionofincrementalcopyingin.Hisalgorithmandtheincrementalcopyingideaisgenerallyknownas``Wroblewski'snon-destructivegraphunification''method.Thismethodisconsideredveryeffectiveandisadoptedbyalgorithmssuchas,,and.Wroblewski'sandthesealgorithmsarecollectivelyknownas`Lazyunification'methodssincebyusingincrementalcopying,thecopyingofnodesaredelayed(orcopyingisperformedLazily,acomputationaljargonrepresentingadelayedactivity--asinlazyevaluation).Thebasicideabehindhismethodistocreatecopiesincrementallyaswegoduringunificationonlywhensuchaneedarises.Itisacombinationofadestructivealgorithm(hecallsitunify1)similartoPereira'salgorithmandanondestructivealgorithmunify2inwhichcopiesarecreatedincrementally.Unify1iscalledonlywheneither(orboth)ofthehighest(root)nodesoftheinputgraphsarecurrentcopiesofothernodes(sothattheycanbemodifiedwithoutlosingtheoriginalgrammarandconstituentgraphs).Otherwiseunify2createscopiesoftheinputnodesastheunificationprogresses.ThisIncrementalcopyinghadbeenacceptedasaneffectivemethodofminimizingovercopyingandeliminatingearlycopying,asdefinedbyWroblewski().However,whilebeingeffectiveinminimizingovercopying(itovercopiesonlyinsomespecialcasesofconvergentarcs),incrementalcopyingisineffectiveineliminatingearlycopyingaswedefineditpreviously.Weclaimincrementalcopyingisineffectiveineliminatingearlycopyingfortworeasons.First,whenincrementalcopyingunificationisperformed,anycopiescreateduptothepointoffailureinthesamesubgraphofasharedarcwillbewasted,asseeninFigure~.Secondandmoresignificantlythatsincetherecursivecallsintothesharedarcsarenon-deterministic(independentofeachother),thereisnowayforoneparticularrecursionintoasharedarctoknowtheresultoffuturerecursionsintoothersharedarcs.Therefore,evenifaparticularrecursionintoonearcsucceeds(withminimumovercopyingandnoearlycopyinginWroblewski'ssense),otherarcsmayeventuallyfail;thusthecopiesthatarecreatedinthesuccessfularcsareallwasted.Figure~showssuchanexample.IfincrementalunificationproceedsunifyingthesubgraphsE,X,Y,andthenZ.AtsomedeeppositionofZ,ifunificationfailureisfound,notonlyarenodesinZwasted(aswesawinFigure~)butallofthecopyingcreatedinE,X,Ywillalsobewasted.Bystructure-sharingofunmodifiedgraphs,Kogure'sandEmele'sschemescanavoidwastingthesubgraphE(i.e.,acomplementgraph),buttheirschemecannotavoidwastingXandY.Notethatthisisinherentandunavoidableinincrementalschemes,sincebydefinition,theseschemesmustproducecopiesastheyproceed.Sinceeachrecursivecallstosharedarcsarenon-deterministic,futureeventinotherrecursivecallsarenotpredictable.Inordertoavoidthisproblem,incrementalschemeswillhavetodelayallcopyinguntilafterentiretop-levelunification.Thiswillmeanthattheseunificationswillnolongerbeincremental.Thus,fullydelayingcopyinginincrementalschemestoavoidearlycopyingwouldmaketheircontrolstructuresessentiallynodifferentfromQ-Dandreversible(Karttunen's)schemes.Inotherwords,wecanalsoviewtheQ-Dschemeasafullylazyschemewithoutoverheadfordelaying.</subsection>
  <subsection title="Specific to Each Algorithm">Oneearlyandimportantresearcheffortinthefeature-structureunification-basedmethodwasbyPereira.Actually,thecontrolstructureofourunify1issimilartothatofPereira[1985].However,inPereira'smethod,aresultgraphisrepresentedasacombinationoftheoriginalgraph(`skeleton')andtheupdates(newarcstobeaddedtocreatetheresultstoredin`environment').Thustheresultgraphisdynamicallycreatedwheneveritisneeded.Thiscausesthelog(d)overhead(wheredisthenumberofnodesinagraph)toassemblethewholegrapheverytimethenodeisaccessed.Intheproposedscheme,insteadofstoringchangestotheargumentgraphsintheenvironment,westorethechangesinthegraphstructurethemselves(non-destructively);therefore,therewillbenooverheadassociatedwithnodeaccesses.WesharetheprincipleofstoringchangesinarestorablewaywithKarttunen'sreversibleunificationandwecopygraphsonlyafterasuccessfulunification.InKarttunen'smethod,wheneveradestructivechangeisabouttobemade,theattributevaluepairsstoredinthebodyofthenodearesavedintoanarray.Thesevaluesarerestoredafterthetoplevelunificationiscompleted.(Acopyismadepriortotherestorationoperationiftheunificationwasasuccessfulone.)Thus,inKarttunen'smethod,eachnodeintheentireargumentgraphthathasbeendestructivelymodifiedmustberestoredseparatelybyretrievingtheattributevaluessavedinanarrayandbyresettingthevaluesintothedagstructureskeletonssavedinanotherarray.IntheQ-Dmethod,oneincrementtotheglobalcountercaninvalidateallofthechangesmadetothenodes.Thereisalsoacostforreversingtheunificationoperationeverytimeunificationiscompleted;thiscostisalsoproportionatetothesizeoftheinputgraph.Thus,iftheinputgraphgrows(whichislikelywithalarge-scalesystem)thenthecostforsavingandreversingchangescanbehigh.ThereisalsoahiddencostofKarttunen'smethodassociatedwiththeuseofglobalarraystostorechanges.Itisthecostassociatedwithresizingthearrayswhichareusedtostoretheoriginalinformation.Theseglobalarraysforsavingrequireoriginalallocationofmemory.Iftheallocatedmemoryistoobig,thenwewillbewastingtheunusedmemorycells;ifitistoosmallthentherewillbedynamicarrayresizingoperationsduringunificationwhichcanbecostly.Sincethenumberofdestructiveoperationsduringunificationvariessignificantlyfromsentencetosentenceandfromgrammartogrammar,determiningthedesirableinitialarraysizeforKarttunen'sschemeisnon-trivial.Inthedelayedschemes,consideredtheuseoflazyevaluationtodelaydestructivechangesduringunification.presentedonemethodtodelaycopyinguntiladestructivechangeisabouttotakeplace.Goddenusesdelayedclosurestodirectlyimplementlazyevaluationduringunification.Whileitmaybeconceptuallystraightforwardtotakeadvantageofdelayedevaluationfunctionalitiesinprogramminglanguages,actualefficiencygainfromsuchaschememaynotbesignificant.Thisissobecausesuchaschemesimplyshiftsthetimeandspaceconsumedforcopyingtocreatingandevaluatingclosuresandnosignificantsavingcanbeexpectedoverall.Additionally,alsoidentifiesasourceofotherprobleminGodden'smethodintheoperationswhichareneededtosearchforalreadyexistinginstancesofactivedatastructuresinthecopyenvironmentandmergingofenvironmentsforsuccessiveunificationcausinganadditionaloverhead.KogureandEmelealsousethelazyevaluationideatodelaydestructivechanges.BothKogureandEmeleavoiddirectusageofdelayedevaluationbyusingpointeroperations.Kogure'smethodalsorequiresspecialdependencyinformationtobemaintained;thisaddsanoverheadalongwiththecostoftraversingthedependencyarcs.Also,asecondtraversalofthesetofdependentnodesisrequiredforactuallyperformingthecopying.Emeleproposesamethodofdereferencingbyaddingenvironmentinformationthatcarriesasequenceofgenerationcounterssothataspecificgenerationnodecanbefoundbytraversingtheforwardinglinksuntilanodewiththatgenerationisfound.Whilethisallowsundoingdestructivechangescheaplybybacktrackingtheenvironment,everytimeaspecificgraphistobeaccessedthewholegraphneedstobereconstructedbyfollowingtheforwardingpointerssequentially,asspecifiedintheenvironmentlist(exceptfortherootnode),inordertofindthenodethatsharesthesamegenerationnumberastherootnode.Thereforetheoverheadfordereferencingtheenvironmentalchaincouldbesteepifagrammarisverylargeandifthesamegraphsareunifiedmanytimestocreatealargeconstituent.LikeWroblewski'smethod,allthreelazymethods(i.e,Godden's,Kogure'sandEmele's)sufferfromtheproblemofEarlyCopyingasdiscussedpreviously.Thisissobecausethecopiesthatareincrementallycreateduptothepointoffailureduringthesametop-levelunificationareallwasted.Sincethefutureunificationresultofothernon-deterministicrecursionintosharedarcsisunknownatthepointofaparticularsuccessfulrecursionintoonesharedarc,ifunificationsucceedswiththearc,thencopiesarecreated.Ifafailureisdetectedlaterinsomeotherrecursiveunificationintothesharedarcs,thenthecopiescreateduntilthatpointwillallgetwasted.Wehaveexplainedthatifwearetoavoidsuchearlycopyingofincrementalcopyingschemes,thenallcopyingmustbedelayeduntilaftertheentiretop-levelunification.ThatinessenceiswhattheQ-Dalgorithmdoes.Thus,theQ-Dalgorithmmaybeseenasoneextremeformoflazycopyingschemeaswell.Thestrengthofithowever,isthatthereisvirtuallynooverheadforthisfulldelayingofcopying.Thetemporaryforwardingpointersandcomp-arc-listareutilizedalongwiththeglobaltiming(generation)countersothatallcopyingcanbeeffectivelydelayeduntilaftertheentiretop-levelunification.Allchangesrecordedastemporaryforwardinglinksandasupdatestocomp-arc-listcanbeinvalidatedverycheaply(constanttime)byjustoneincrementoftheglobaltimingcounter.Otherpossibilitiesforspeedingupunificationincludessortingoffeaturestructuresbasedoncriteriasuchasfrequencyoffailureandnatureofsubgraphs(e.g.,atomicvscomplexalwaysfails).Onesuchnotionisbrieflyproposedin().However,ourinformalexperimentshaveshownthatanyspecificmodificationoforderingofarcsduringtheunificationgenerallyslowsdownunification(andsometimesslowsdownverysignificantly)because1)sortingisnotacheapoperation;and2)suchsortingwillbeperformedverymanytimesanditbecomestooexpensive.Notethatunificationsarecalledrecursivelyforsometimesover100,000timesduringaparse,andperformingasortoperationforeachofthembecomestooexpensive.AdecentgrammarsuchastheonedevelopedbyATRnormallycomeswiththearcspre-sortedsothatthearcswithhigherfrequencyoffailurearenormallyputbeforetheonesthatfailless.Suchmodificationisdonetothegrammarpriortoparsingandwhilethegainduetosuchapreprocessingisvalueditisnotveryrelevanttotheissueofefficiencyoftheunificationalgorithmitselfandtothispaper.Otherpossibilitiesinefficiencyinunificationincludesstructure-sharingofgraphs.Wehavereportedinandthatintroductionofstructure-sharinginQ-Dframeworkprovidesanothertwofoldincreaseinspeed.Also,proposesthemethodinpreprocessingthefeature-structuresduringtheunificationwhichclaimsanothertwofoldincreaseinspeed.Giventheseimprovementsareindatastructuresandpreprocessing,discussionsofthesemethodologiesarenotthescopeofthispaper.</subsection>
  <section title="Conclusion">Unification-basedconstraintprocessinghasbecomeadefactostandardofnaturallanguageprocessing.Unification-basedpostulationhasbeenacceptedasthecentraltoolforrepresentingconstraintsinmoderntheoreticalandcomputationallinguistics.Inmassivelyparallelnaturallanguageprocessing,graphunificationcanbeadoptedtoremedytheweaknessofso-calledmarker-passingmethodsinprocessingsyntacticconstraints.Infact,Q-Dalgorithmwasdevelopedduringthecourseofsuchamassively-parallelnaturallanguageresearch,inwhichweneededaneffectivelyparallelizableunification(,).Giventhatrecursionsintosharedarcswereparallel-processedintheparallel-processingenvironment,theproblemofearlycopyinginherentinincrementalschemesweredevastatingintheparallelunificationenvironment.Althoughthetopicofparallelunificationisnotthescopeofthispaper,describessomeresultsinparallizingtheQ-Dalgorithm.SincetheQ-Dalgorithmperformsconstraintcheckingwithouttheburdenofcopying,wefoundthatunificationfailurecanbefoundextremelyquicklybyparallelyspawningtherecursiveunify1sdeepintothefeaturestructures.Thewell-knownweaknessofunification-basednaturallanguageprocessinghasbeenslownessofspeedduetothetimerequiredbyunificationalgorithms.Giventhatmorethan90percentandoftenasmuchas98percentofparsingtimeisconsumedbygraphunificationalone,thespeed-upeffectofimprovinggraphunificationalgorithmsshouldnaturallyhaveagreaterimpactthantheeffectofimprovingthespeedofparsingmethodologiesalone.Yet,althoughtherehasbeensomesuccessfulandimportantresearchinspeedingupparsingalgorithms(suchas),effortstoimproveunificationalgorithmswererelativelyrarecomparedtoparsingresearchefforts.Perhapsthereasonforthiscouldbethatmostnaturallanguagesystemstodatedidnotcontainaverylargegrammarand,therefore,theperformancebottleneckbyunificationalgorithmsremainedlargelyunnoticed.Thus,itisnotsurprisingthatsomeoftheimportantunification-basedresearchcamefromplacessuchasSRI,MCC,ATRandCMU,wherelarge-scalenaturallanguageprocessingprojectswerebeingconducted.ThealgorithmpresentedinthispaperhasbeentestedusingthegrammardevelopedatCMUandatATRandhasbeendemonstratedtoconsistentlyrunfastwithlargescalegrammars.AtCMU,thealgorithmhasbeenintegratedintothenewJANUSmulti-languagespeech-to-speechtranslationproject.Especiallysignificant,ATRadoptedthealgorithmforthelatestAsuraproject,inwhichafullyseparateimplementationofthealgorithmintegratingKogure'smethodfornegativefeaturestructures()andKasper'smethodfordisjunctivefeaturestructures()wasdone.Theinformaldatathatarecurrentlyavailablefromthemhaveconfirmedtheperformanceofthealgorithmwithaverylargegrammar.Moreexperienceswiththealgorithmshouldbeavailablefromotherresearchinstitutesfromaroundtheworld.AmongthemaretheUniversityofTuebingen,theUniversityofKarlsruhe,KeioUniversity,TokyoInstituteofTechnology,andTokushimaUniversitywhohavealreadystartedusingthealgorithmintheirprojects.Withthecapacitytohandlevariables,convergence,andcycles,andwiththeeaseofimplementingit,thealgorithmshouldbeeasilyintegratedintoexistingandfuturenaturallanguageprocessingmechanismsasacentralconstraintprocessingalgorithmofthesystems.</section>
</root>
