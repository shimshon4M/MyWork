<?xml version="1.0" ?>
<root>
  <jtitle>機能的なリテラルを含む公理体系における仮説推論の効率化</jtitle>
  <jauthor>山本風人井之上直也乾健太郎</jauthor>
  <jabstract>仮説推論は，与えられた観測に対する最良の説明を見つける推論の枠組みである．仮説推論は80年代頃から主に人工知能の分野で長らく研究されてきたが，近年，知識獲得技術の成熟に伴い，大規模知識を用いた仮説推論を実世界の問題へ適用するための土壌が徐々に整いつつある．しかしその一方で，大規模な背景知識を用いる際に生じる仮説推論の計算負荷の増大は，重大な問題である．特に言語の意味表示上の依存関係を表すリテラル（本論文では機能リテラルと呼ぶ）が含まれる場合に生じる探索空間の爆発的増大は，実問題への仮説推論の適用において大きな障害となっている．これに対し本論文では，機能リテラルの性質を利用して探索空間の枝刈りを行うことで，効率的に仮説推論の最適解を導く手法を提案する．具体的には，意味的な整合性を欠いた仮説を解空間から除外することで，推論全体の計算効率を向上させる．また，このような枝刈りが，ある条件が満たされる限り本来の最適解を損なわないことを示す．評価実験では，実在の言語処理の問題に対して，大規模背景知識を用いた仮説推論を適用し，その際の既存手法との計算効率の比較を行った．その結果として，提案手法が既存のシステムと比べ，数十〜数百倍ほど効率的に最適解が得られていることが確かめられた．</jabstract>
  <jkeywords>仮説推論，談話理解，共参照解析</jkeywords>
  <section title="はじめに">仮説推論(Abduction)は，与えられた観測に対する最良の説明を見つける，論理推論の枠組みのひとつである．仮説推論は，自然言語処理や故障診断システムなどを含む，人工知能分野の様々なタスクにおいて古くから用いられてきた(NgandMooney1992;Blythe,Hobbs,Domingos,Kate,andMooney2011;Ovchinnikova,Hobbs,Montazeri,McCord,Alexandrov,andMulkar-Mehta2011;井之上，乾，Ovchinnikova，Hobbs2012;杉浦，井之上，乾2012)．Ng92,Blythe11,Ovch11,Inoue12,Sugiura12自然言語処理への応用のうち，代表的な先行研究の一つにHobbsらのInterpretationasAbduction(IA)がある．Hobbsらは，語義曖昧性解消，比喩の意味理解，照応解析や談話関係認識などの，様々な自然言語処理のタスクを，一階述語論理に基づく仮説推論により統合的にモデル化できることを示した．詳しくは節で述べるが，IAの基本的なアイデアは，談話解析（文章に対する自然言語処理）の問題を「観測された文章（入力文）に対し，世界知識（言語の知識や常識的知識など）を用いて，最良の説明を生成する問題」として定式化することである．最良の説明の中には，観測された情報の背後で起きていた非明示的な事象，共参照関係や単語の語義などの情報が含まれる．例文``Johnwenttothebank.Hegotaloan.''に対して，IAによる談話解析を行う様子を図に示す．まず，入力文の論理式表現が観測として，世界知識の論理式表現が背景知識として与えられ，背景知識に基づいて説明が生成される．例えば，go(x_1,x_2)（Johnがbankに行った）という観測に対して，issue(x,l,y)(y,x)（xがyに対してlを発行するには，yはxの所に行かなければならない）という因果関係（行為の前提条件）の知識を用いて，issue(x_2,u_1,x_1)（bankがJohnに対して何か(u_1)を発行した）という説明を生成している．これは，非明示的な情報の推定に相当する．また，この非明示的な情報を根拠の一つとして生成された説明x_1=y_1（JohnとHeは同一人物）は，共参照関係の推定に相当する．以上のようにIAでは，談話解析の様々なタスクが，説明生成という統一的な問題に帰着される．仮説推論は，以下の様な点で談話解析の枠組みとして適していると考えられる：入力から出力が導かれるまでの過程が，解釈可能な形で得られる．すなわち，どのような仮説を立てて，どのような知識を用いて観測を説明しているかが，図のような証明木という形で陽に得られる．様々な種類の世界知識を統一的，かつ宣言的に記述し利用することができる．すなわち，どのような種類の知識であっても，その知識を解析にどう利用するかの手続きを定義する必要がなく，論理式として宣言的に記述するだけで談話解析に利用できる．語義曖昧性解消や照応解析，プラン認識など，談話理解の様々なサブタスクを一つのモデルに集約して解くことにより，サブタスク間の相互依存性を自然な形で考慮できる．図においても，照応解析と語義曖昧性の解消が同時に起こっていることが確認できる．IAを始めとした仮説推論に基づく談話解析の研究は，1990年代が全盛期であったが，近年になって再び注目を浴びつつある．これには，大きく2つの背景があると考えられる．ひとつめに，仮説推論を実用規模の問題に適用できる程度の，大規模な世界知識を取り揃える技術が昔に比べて大幅に成熟してきたことが挙げられる．例えば文献では，WordNetとFrameNetを用いて約数十万の推論規則からなる背景知識を構築し，含意関係認識のタスクにIAを適用している．ふたつめの背景には，計算機性能の向上や効率的な仮説推論エンジンが提案されたことにより，大規模知識を用いた論理推論が計算量の面で実現可能になってきたことが挙げられる．例えばでは，約数十万の推論規則からなる背景知識を用いて含意関係認識のデータセットに対して推論を行い，先行研究より大幅に高速な推論を行えたことが報告されている．しかしながら，仮説推論における計算コストの問題は未だ完全に解決されたとはいえないのが実情である．詳しくは~節で詳述するが，とりわけ，主格関係や目的格関係などの単語間の統語的依存関係を表すためのリテラル（便宜的に「機能リテラル」と呼ぶ．形式的な定義は節で与える）が知識表現に含まれる場合（例えば，john(j)get(e)dobj(e,l)loan(l)におけるgetとloanの目的格関係を表すdobj(e,l)），推論時間が増大するという問題がある．最新の仮説推論エンジンであるでは，A*アルゴリズムに基づいて説明の構成要素（潜在仮説集合）を列挙し，仮説推論の問題を「説明の構成要素の組み合わせ最適化問題」へ変換したのち，整数線形計画ソルバにより最良の説明を求める．しかし，機能リテラルが知識表現に含まれる場合，(1)機能リテラルをもとにした推論により，潜在仮説集合の中に，最良の説明になりえない構成要素が多く入り込んでしまい（例えば，foolish(e_1)smart(e_2)nsubj(e_1,x)nsubj(e_2,y)から，e_1=e_2を導く），組み合わせ最適化問題のサイズが無用に肥大化し，推論時間が増大する，(2)潜在仮説集合の生成をガイドするヒューリスティック関数の精度低下が起きてしまい，潜在仮説集合の生成における計算効率が低下する，という問題が起こる．このように，実タスクへの適用は未だ困難な状況であり，前述のような利点が本当にあるかどうか，検証する環境が完全に整っていない状況である．以上のような背景を踏まえ，本論文では，知識表現に機能リテラルを含む仮説推論において，機能リテラルの性質を利用して潜在仮説集合の生成手続きを改良し，効率的に最適解を求め，かつヒューリスティック関数の精度低下を抑制する手法を提案する．より具体的には，一つ目の問題に対しては，潜在仮説集合の生成を行う際に，最良の説明になりえない説明を事前チェックするように潜在仮説集合の手続きを拡張する．例えば，矛盾する二つの事象を等価とみなす説明の構成要素を生成する推論（前述のe_1=e_2など）を禁止することで，潜在仮説集合の肥大化を防ぐ．また，二つ目の問題に対しては，ヒューリスティック関数の中で，より良い説明の構成要素を優先的に探索するために用いられる述語グラフの生成手法を工夫することにより対処する．問題の原因は，背景知識に頻出する機能リテラルがハブとなり，あらゆる説明の構成要素の候補が最良の説明の生成に寄与すると誤って判断されてしまうことにある．これに対し，述語グラフにおいて機能リテラルに繋がる一部の枝を適切に排除することにより，解の最適性を保持しながらヒューリスティック関数の精度を上げる手法を提案する．本論文における具体的な貢献は次の3点である．一つ目に，仮説推論の最新の実装であるA*-basedAbductionの手法に前述の枝刈りを導入する方法を示し，機能リテラルを知識表現に含む場合でも推論の規模耐性を維持する方法を示す．二つ目に，機能リテラルの性質に基づく探索空間の枝刈りが，ある条件のもとでは本来の解を損なわないことを示す．三つ目に，大規模な知識ベースと実在の言語処理の問題を用いて，A*-basedAbductionのシステムとの推論時間の比較を行い，提案手法を評価する．本論文での実験においては，提案手法がのシステムと比べ数十〜数百倍ほど効率的に解仮説が得られていることが確かめられた．仮説推論に基づく談話解析の枠組みを実タスクへ適用する上で，効率的な推論アルゴリズムの確立は必須の要件である．本研究の成果により，仮説推論に基づく談話解析の研究を進めるための環境整備が大きく前進すると考えられる．以降の節では，まず仮説推論とその実装に関する先行研究について述べたあと（2節），本論文で取り組む問題について述べ（3節），提案手法について説明する（4節，5節）．次に，提案手法と既存手法の比較実験の結果について報告し（6節），最後に今後の展望を述べる．</section>
  <section title="背景">本節では，本論文の提案手法の基になっている種々の既存研究，すなわち仮説推論およびその実装に関して説明する．</section>
  <subsection title="仮説推論">仮説推論とは，与えられた観測に対して最良の説明を求める推論である．本論文では，仮説推論の意味表現として一階述語論理を用い，仮説推論の形式的な定義を次のように与える．なお，本論文では関数記号のない(function-free)一階述語論理を用いるものとし，全てのリテラルは論理変数，定数，スコーレム定数を引数に取る．なお，本論文では背景知識，観測，仮説における限量子の記述は基本的に省略する．一般には，与えられたBとOに対して，複数の仮説H_1,H_2,が存在する．本論文では，それぞれの仮説H_iを候補仮説と呼び，候補仮説H_iに含まれる各リテラルhH_iをH_iの要素仮説と呼ぶ．また，可能な全ての候補仮説をHH_1,H_2,で表す．例えば図では，点線で囲まれたリテラルの集合(john(x_1)go(x_1,x_2))が観測O，実線で囲まれた論理式（例えば，issue(x_2,u_1,x_1)go(x_1,x_2)）が背景知識Bの一部である．候補仮説として，例えばH_1=john(x_1)loan(y_2),H_2=john(x_1)issue(u_2,y_2,y_1)financial_inst(x_2)loan(y_2)などが考えられる．仮説推論の目的は，何らかの評価指標のもとでの最良の候補仮説Hを見つけることである．このHを解仮説と呼び，形式的には次のように表す：ここで，Evalは候補仮説Hの蓋然性を表す何らかの評価値を返す関数を表し，このような関数を仮説の評価関数と呼ぶ．先行研究では，さまざまな評価関数が提案されている．例えば，代表的な評価関数の一つである重み付き仮説推論は，「単純な（小さい）仮説ほど良い」という基本的な仮定に基いており，候補仮説の最小性を候補仮説の評価値として定義している．より具体的には，候補仮説の評価値Eval(H)は，Hの要素仮説のコストの負の総和-_hHcost(h)で定義される．要素仮説のコストcost(h)の詳細な計算方法はに委ねるが，基本的には，(1)要素仮説hが観測Oを説明するのに要する背景知識の信頼度，(2)要素仮説hが他の要素仮説に説明されているか，の二つの要因を基にコストが決定される．本研究では，~節で示す仮説の整合性条件を保証する任意の評価関数を想定する．</subsection>
  <subsection title="潜在仮説集合に基づく候補仮説の表現">HBO,HBを満たす全ての候補仮説を陽に列挙して最良の仮説を求めることは，時間・空間的計算量の観点で非現実的である．そのため，仮説推論エンジンの先行研究では，(1)観測からの後ろ向き推論によって各候補仮説を構成するリテラルの集合Pを列挙するに留め，(2)Pの要素の組み合わせ（部分集合）で暗に候補仮説を表現し，組み合わせ最適化問題を解くことで効率化を実現している．このPは，潜在仮説集合と呼ばれる．例えば，図の例では，観測O=animal(x)bark(e_1,x)と背景知識より，潜在仮説集合P=cat(x),poodle(x),dog(x),dog(y),x=yを得る．この集合の要素の組み合わせ（例えばcat(x),dog(x)）が，一つの候補仮説に対応する．本研究では，この潜在仮説集合の生成方法を効率化する手法を提案するため，潜在仮説集合の生成手続きについて，より詳しく説明する．まず，観測に含まれるリテラルの集合を初期状態として(P=O)，次のように定義される後ろ向き推論操作および単一化仮説生成操作を有限回だけ逐次適用することで，潜在仮説集合Pを生成する．図では，P=animal(x),bark(e_1,y)が初期状態となる．操作の適用回数の決め方には様々な基準が考えられるが，先行研究では，リテラルの深さという概念を用いて，適用回数を制限している．リテラルlの深さとは，lを潜在仮説集合に追加するまでに実行した後ろ向き推論の回数である．例えば，図では，観測に含まれる全てのリテラルは深さ0であり，poodle(x)の深さは2である．先行研究では，後ろ向き推論を適用する対象をある深さd_maxまでのリテラルに制限することにより，操作の適用回数の上限を決めている．このように操作の適用範囲を定めることは，再帰的な推論規則（例えばp(x)q(y)とq(y)p(x)）が背景知識に含まれる場合において，特に重要である．操作の適用回数が有限回であるならば，潜在仮説集合に含まれる各リテラルもまた有限回の後ろ向き推論によって仮説されたリテラルであるので，全ての候補仮説HHについてHBOの決定可能性が保証される．また，アルゴリズムの停止性，および潜在仮説集合が有限集合であることについても同様に保証される．以上の議論に基づき，本研究においても以上の手続きによって生成された潜在仮説集合の部分集合を候補仮説として扱う．</subsection>
  <subsection title="仮説推論の実装に関する先行研究">まず，仮説推論の分野における代表的な実装としてはMulkarらのMini-TACITUSが挙げられるが，これは計算量の面では非常に非効率であった．そのため，大規模知識を用いた仮説推論を行うにあたっては，より効率的な推論アルゴリズムが必要とされた．これを受けてBlytheらは，仮説推論の枠組みをMarkovLogicNetwork(MLN)の上で定式化する手法(MLN-basedAbduction)を提案した．彼らは，仮説推論をMLN上で実装することによって，MLNの分野における成熟した最適化手法を仮説推論にも利用することを可能にした．これによりMini-TACITUSと比べ遥かに高速な推論が実現可能になった．そしてこれよりも更に高い効果をあげたのが，井之上らが提案した整数線形計画法(IntegerLinearProgramming,ILP)に基づく仮説推論(-basedAbduction)であった．井之上らは，仮説推論の問題を整数線形計画問題により定式化する手法を提案した．これにより，仮説推論において解仮説を導出する処理はそのままILP問題の最適解を導く処理と対応付けられ，外部の高速なILPソルバを利用することで解仮説を効率的に導出することが可能になった．文献では，ILP-basedAbductionの枠組みがMLN-basedAbductionと比べても遥かに高速であることが実験によって定量的に示されている．Yamamotoらは，ILP-basedAbductionにおける計算コストが潜在仮説集合の規模に強く依存することに着目し，背景知識における述語間の関連度を事前に推定しておくことで，ILP-basedAbductionの潜在仮説集合生成の手続きにおいて解仮説に含まれる見込みの無い要素仮説を潜在仮説集合から除外し，ILP問題の最適化にかかる時間を大幅に短縮する手法(A*-basedAbduction)を提案した．しかしながら，節で示すように，A*-basedAbductionには，機能リテラルを含む知識表現において推論時間が増大するという問題がある．本研究は，我々が知る限り最も効率的な枠組みであるA*-basedAbductionを拡張する手法を提案するものである．A*-basedAbductionの詳細については節で述べる．</subsection>
  <section title="関係を表すリテラルに起因する計算非効率性">本節では，~節で示される意味表現と評価関数に基づくIAを先行研究の仮説推論エンジンで実現する場合に生じる，潜在仮説集合の計算の非効率性について論じる．本節では，まず本研究が前提とする意味表現・評価関数について述べたあと（節），既存研究の問題点について述べる（節）．</section>
  <subsection title="本研究が前提とする意味表現と評価関数">仮説の評価関数は，~節で述べたとおり仮説の良さを評価する関数であるが，「良さ」の因子には少なくとも，(1)仮説が表す情報の良さ，(2)仮説に含まれる意味表現の文法的正しさ(well-formedness)，の二種類が考えられる．本研究は，これらに対してある前提が成立する状況での推論の非効率性を改善するものであるから，本節では，前提とする意味表現と，仮説の評価関数の概形について述べる．(1)意味表現言語表現によって表される情報を，どのような論理式として表すかは重要な問題の一つである．特に，述語と項の関係の表現形式については，これまでに様々な議論が交わされてきた~．述語項関係の表現形式の基本形としては，大きくDavidsonian形式~とNeo-Davidsonian形式~があり，本論文ではNeo-Davidsonian形式の意味表現の利用を想定する．Davidsonian形式では，イベントの必須格をリテラルの項の順番に対応させる．例えば，例文``BrutusstabbedCaesarwithaknife.''をstab(e,Brutus,Caesar)with(e,knife)のように表現する．ここではstab(e,Brutus,Caesar)の1番目の引数がstabイベントそのものを参照する変数，2番目の引数がイベントの主格，3番目の引数がイベントの目的格に対応している．一方，Neo-Davidsonian形式では，全ての格関係を個別のリテラルとして記述する．例えば，前述の例文をstab(e)nsubj(e,Brutus)dobj(e,Caesar)with(e,knife)のように表現する．ここで，stab(e)はeがstabイベントであることを，nsubj(e,x)はイベントeの主格が個体xであることを，dobj(e,x)はイベントeの目的格が個体xであることを表すリテラルである．本論文では，nsubj(e,x)やdobj(e,x)のような単語間の統語的な依存関係を表すリテラルを機能リテラルと呼び，その述語を機能述語と呼ぶ．一方，stab(e)などの，機能リテラル以外のリテラルを内容語リテラルと呼ぶ．また，ある機能リテラルの第一引数を他の内容語リテラルが引数に持つとき，その内容語リテラルを機能リテラルの親と呼び，逆にそのような内容語リテラルが存在しない場合には，その機能リテラルは親を持たないと表現する．例えば上の例において，stab(e)はnsubj(e,x)の親である．Neo-Davidsonian形式は，イベントに対する部分的な説明を表現できる（例えばpolice(x)arrest(e)nsubj(e,x)のようにイベントの主格だけを取り上げた推論が記述できる）ことや，個々のイベントの必須格と任意格の境界を決める必要が無いなどの利点を持つ．自然言語の動詞は，動詞ごとに必須格・任意格が異なるため，実世界の様々な文を扱う上では，Neo-Davidson形式はDavidsonian形式よりIAに適した表現形式であると考えられる．以上の理由により，本論文ではNeo-Davidsonian形式の意味表現を想定する．ところで，上で述べたように，機能リテラルは言語表現における単語間の統語的依存関係を表すので，親を持たない機能リテラルは文法的に不正である．このことから本論文では，全ての観測が以下の条件を充足することを仮定する：全ての観測は親を持たない機能リテラルを含まない．すなわち，この条件を充足しない観測は，元となった文が文法的に不正であると考えられるので，本研究ではそのような観測は入力として考えないものとする．(2)評価関数次に，本論文で想定する評価関数の概形について述べる．まず第一に，仮説に含まれる等価仮説の正しさを評価することを前提とし，次のような条件として定義する：評価関数は，不正な等価仮説を含む候補仮説を解仮説として選択しない．ここでの不正な等価仮説とは，同一事象を表し得ない変数間の等価仮説を指し，本論文ではこのような等価仮説をe_1=^*e_2と書く．節で述べたとおり，候補仮説の生成時には，同じ述語を持つリテラル対に単一化仮説生成を適用することにより等価仮説が生成される．このとき，例えばsmart(e_1)foolish(e_2)e_1=e_2のように，同一でない二つの事象を表す論理変数が等価であるという候補仮説が生成されてしまう場合がある．条件2が満たされる限り，このような候補仮説は解仮説として選択されない．等価仮説が不正であるか否か，すなわちある2つの論理変数が同一事象を表し得るかどうかの判断については，変数の等価性について閉世界仮説を仮定することで対応する．すなわち，ある論理変数対a,bが潜在仮説集合Pにおいて同じ型を持つ可能性が存在しないならば（すなわち同じ述語を持ち，単一化仮説生成によって等価仮説a=bを導くような内容語リテラル対が潜在仮説集合Pに存在しないならば）等価仮説a=bは不正である(a=^*b)とする．第二に，仮説に含まれる論理式の文法的正しさを評価することを前提とし，以下のような条件で表す：評価関数は親を持たない機能リテラルを含む候補仮説を解仮説	として選択しない．前述のとおり，親を持たない機能リテラルは文法的に不正であるので，本論文ではこの文法的正しさに関して，評価関数が条件3を満たしていることを前提とする．以降では，これらの条件1,2,3をまとめて仮説の整合性条件と呼ぶ．</subsection>
  <subsection title="機能リテラルに係る推論による計算の非効率化">~節で述べた意味表現と評価関数のもとで，先行研究の仮説推論エンジンを用いてIAを実現する場合，機能リテラルを根拠とした単一化仮説生成操作および後ろ向き推論操作により，解仮説に含まれることのない要素仮説が潜在仮説集合に追加され，推論時間を増大させてしまうという問題がある．例えば図では，観測に含まれるnsubj(e_3,j)とnsubj(e_4,t)に対して単一化仮説生成操作を適用することで，等価仮説e_3=e_4（smartイベントとfoolishイベントは同一事象），およびj=t（JohnとTomは同一人物）が潜在仮説集合に追加されている．また図では，観測に含まれるsmart(e_1)とfoolishの主格を表すリテラルnsubj(e_2,t)を根拠として，e_1=e_2という仮定のもと知識適用を行い，study(e_3),nsubj(e_3,t)を潜在仮説集合に追加している．しかしながら，これらの推論は論理的には可能であるものの，~節で述べた仮説の評価関数に関する前提より，これらの仮説が最良の説明として選択されることは無い．このような推論は同じ述語を持つリテラルに対して組み合わせ的に発生し（例えば，「smartを述語に持つリテラルの数nsubjを述語に持つリテラルの数」の分だけ発生する），かつ候補仮説の数は潜在仮説集合の規模に対して指数関数的に増大するため，計算負荷の観点において重大な問題であると考えられる．この問題の本質的な原因は，先行研究の潜在仮説集合生成手続き（~節）における各操作において，論理変数間の等価性の意味的な整合性を考慮できていないことにある．例えば図において，nsubj(e_3,j)とnsubj(e_4,t)に対する単一化仮説生成操作によって等価仮説e_3=e_4が潜在仮説集合に追加されるが，このとき，この等価仮説が不正かどうか（つまり，解釈「studyであり，かつmistakeであるようなイベントe_3(=e_4)が存在する」が実現可能なものか）は考慮されていない．その結果，図のように，不正な等価仮説であっても，潜在仮説集合に追加されてしまう．本節で述べた問題は，意味表現としてNeo-Davidsonian形式を採用した場合に—すなわち述語と項の関係をnsubj(x,y)のように個別のリテラルとして表現した場合に起こる問題である．しかし，これに限らず，Hobbsらの研究のように，名詞間の意味的関係（部分全体関係など）や統語的関係（複合名詞を構成する名詞間の関係など）をpart_of(x,y)やnn(x,y)のようなリテラルで表現する場合にも，上述のような問題が生じる．このようなリテラルは一階述語論理式で自然言語の情報を表す上で必要不可欠であり，本節で述べた問題はIAの研究において決して些末な問題ではない．このような問題に対し本論文では，~節で述べた潜在仮説集合生成に係る操作において等価仮説の生成を伴う場合，等価仮説が不正でない場合にのみ操作の適用を許すことで，解として選ばれない等価仮説を潜在仮説集合から除外する手法を提案する．例えば図におけるnsubj(e_3,j)とnsubj(e_4,t)に対する単一化仮説生成操作の適用時には，まず~節で述べた基準によりe_3=e_4の正しさをチェックする（つまり，studyかつmistakeであるような事象が存在しうるか）．ここで仮に「studyとmistakeが同一事象に成り得ない」ことがわかったとすると，e_3=e_4は不正な等価仮説であり，e_3=e_4が解仮説に含まれる可能性がないため，操作の適用を行わない．4節では，これらのアイデアに基づき，2.1節で説明した潜在仮説集合生成の手続きを拡張し，より効率的に潜在仮説集合を生成する方法を提案する．また5節では，これらのアイデアに基づき，A*-basedAbductionの計算効率を改善する手法を提案する．なお，以降の記述では便宜的に，機能リテラルは全て次のような形式をとるものとする：アリティは2．リテラルの第一引数が依存関係のgovernor，第二引数がdependentを表す．自然言語における単語間の依存関係の多くは2項間関係として表されること，多項関係は一般に2項間関係の組み合わせとして一般化できることなどから，このように定義を限定した場合においても一般性は失われない．</subsection>
  <section title="等価仮説への制約による効率化">本節では，~節で定義した後ろ向き推論操作，および単一化仮説生成操作に対して適用条件を付加することにより，不正な等価仮説を探索空間から除外する方法を提案する．</section>
  <subsection title="機能的述語の単一化に対する制約">2節で述べた通り，先行研究における単一化仮説生成の適用は，述語の同一性にのみ依拠している．しかしながら，~節で述べた設定の下では，機能リテラル対に対する単一化仮説生成操作によって，不正な等価仮説が潜在仮説集合に追加されてしまう可能性がある．仮説の整合性条件が充足されているとすると，不正な等価仮説を含む仮説は解仮説として選択されないため，そのような仮説が候補仮説に含まれてしまうことは，推論効率の面で無駄が生じる．我々はこの問題に対処するために，機能リテラル対に対する単一化仮説生成を行う際に「それぞれのgovernor（第一引数）の論理変数の間の等価性を導く，不正でない等価仮説が既に仮説されていること」という条件を追加する．例えば図の観測における機能リテラル対nsubj(e_3,j),nsubj(e_4,t)に対する単一化仮説生成の適用は，等価仮説e_3=e_4が潜在仮説集合に既に含まれている場合に限定する．これにより，親が互いに同一事象に成り得ない機能リテラル対は単一化仮説生成の対象とならず，不正な等価仮説が潜在仮説集合に追加されなくなるので，推論効率の向上が期待できる．より一般的には，潜在仮説集合Pにおいて，機能述語dを持つ機能リテラル対d(x_1,y_1),d(x_2,y_2)に対して単一化可能性を認め，そこから導かれる等価仮説x_1=x_2,y_1=y_2を潜在仮説集合に追加するのは，x_1,x_2が同一の変数である場合か，等価仮説x_1=x_2がPに含まれている場合に限る．このような制約により，機能リテラル間の単一化仮説生成が適用されるのは，それぞれの機能リテラルが表す依存関係のgovernorが互いに同一である可能性がある場合に限定され，常に不正な等価仮説を導くような単一化仮説生成操作の実行を防止できる．この制約をどのようなアルゴリズムとして実装するかについては節で述べる．</subsection>
  <subsection title="後ろ向き推論への拡張">後ろ向き推論操作についても，単一化仮説生成操作と同様の議論を行うことができる．本節ではそれを踏まえ，前節と同等の制約を後ろ向き推論操作にも課すことを考える．例えば図において，論理式study(e_3)nsubj(e_3,t)smart(e_1)nsubj(e_1,t)による後ろ向き推論を連言smart(e_1)nsubj(e_2,t)に対して適用する場合について，この後ろ向き推論操作の適用条件として「潜在仮説集合に不正でない等価仮説e_1=e_2が含まれていること」を課す．これにより，不正な等価仮説を導く後ろ向き推論を潜在仮説集合の生成手続きから除外することができる．このとき，全ての後ろ向き推論に制約を課してしまうと，本来除外するべきでない推論が除外されてしまう場合があることに注意する必要がある．例えば図における後ろ向き推論に上の制約を課した場合，等価仮説x_1=x_3が潜在仮説集合に含まれていることが後ろ向き推論適用の条件となるが，等価仮説x_1=x_3を導くためにはその後ろ向き推論を実行する必要がある．そのため，上の制約を課した場合にはこの推論は探索空間から除外されてしまう．しかしながら，図の仮説は最終的には不正な等価仮説を含まないため，本来は除外するべきでない．以上の議論より本論文では，このような場合を引き起こしうる論理式を用いた後ろ向き推論については制約を課さないことによって，除外すべきでない候補仮説—すなわち不正な等価仮説を含まない候補仮説が探索空間から除外される事態を防ぐ．上のような場合を引き起こしうる論理式とは，具体的には，論理式の後件中の機能リテラルの親になっているリテラルが前件に含まれるような論理式である．そのような論理式を用いた後ろ向き推論については，制約の対象から除外する．例えば図の例では，後件の機能リテラルin(x_1,x_2)の第一引数x_1が前件のリテラルstudent(x_1)の引数に含まれており，student(x_1)はin(x_1,x_2)の親であると言えるので，この論理式を用いた後ろ向き推論については制約の対象としない．以上のアイデアをより一般的に表そう．潜在仮説集合Pにおいて，含意型論理式_i=1^np_i(x_i)_j=1^mq_j(y_j)を用いた後ろ向き推論を，Pに含まれる連言_j=1^mq_j(z_j)に適用する場合を考える．ここで，述語q_fが機能述語であるようなインデックスfの集合をFとすると，この逆向き推論を適用するのは，Fの各要素fが以下の条件のうち少なくとも一つを満たしている場合に限る：q_f(y_f)の第一引数y_f^1を引数に持つリテ	ラルが論理式の前件に存在する．すなわちy_f^1	_i=1^nx_iが成り立つ．論理式の後件のc番目にある内容語リテラル（q_c(y_c)と	おく）の任意の（i番目の）引数y_c^iが	y_f^1と同一であるとき，変数対z_c^i,z_f^1が同一であるか，もしくは潜在仮説集合に等価仮説	z_c^i=z_f^1が含まれる．この条件を満たさない逆向き推論は，常に不正な等価仮説を導くので，探索空間から除外できる．この制約をどのようなアルゴリズムとして実装するかについては節で述べる．</subsection>
  <subsection title="潜在仮説集合の生成手続きの拡張">節および節では，単一化仮説生成操作および後ろ向き推論操作の適用条件として，不正な等価仮説を生成しないことを条件とすることにより，不正な等価仮説が潜在仮説集合に追加されることを回避する手法を示した．本節では，これらの手法を実際にアルゴリズムとして実装する方法を議論する．まず，各操作の適用条件の充足性と，潜在仮説集合の状態は互いに依存しているため（つまり，適用条件の充足性は潜在仮説集合の状態で決まり，かつ潜在仮説集合の状態は各操作の適用条件の充足性により変化する），各操作に対する条件の充足性判定は，各操作の適用時に一度ずつ行うだけでは不十分である．なぜなら，潜在仮説集合を生成する過程において，ある時点では適用条件を充足せず適用不可能な操作であっても，その後の別の時点では，別の操作の適用により条件が充足され，適用可能となる場合があるからである．そのため，最終的に適用されなかった全ての操作が制約を充足しないことを保証できるよう，各操作に対する適用条件の充足性を漏れが無いように判定する必要がある．以上のような考えに基づき，~節で述べた潜在仮説集合の生成手続きを次のように変更する：観測Oを潜在仮説集合Pに追加する．これが初期状態となる．潜在仮説集合Pに対して適用可能な後ろ向き推論および単一化仮説	生成操作を，A*-basedAbductionの手法に基いて網羅的に適用する．	ただし，~節および~節で	提案した適用条件を満たさない単一化仮説生成・後ろ向き推論は実行しない．	制約条件を満たさずに実行されなかった単一化仮説生成・後ろ向き推論につい	ては，別の記憶領域Sに保持しておく．この時点でSが空の場合は，潜在仮説集合の生成を終了する．Sに含まれる単一化仮説生成操作および後ろ向き推論操作のそれぞれについて，再び制約	を満たすかどうかの判定を行う．満たすのなら操作を適用し，Sから	除外する．手続き(4)において一つの操作も実行されなかった場合は潜在仮説集合	の生成を終了し，そうでなければ手続き(2)に戻る．このような実装を採ることにより，最終的に適用されなかった操作については全て適用条件を満たさないことが保証される．節および節での議論より，適用条件を満たさない操作は不正な等価仮説を導くので，仮説の整合性条件より，これらの操作によって導かれる要素仮説が本来の解仮説に含まれることは無い．すなわち，等価仮説への制約を課す前後で解仮説が変化しないことが保証される．</subsection>
  <section title="A*-based Abduction の効率化">機能リテラルを含む背景知識を用いた仮説推論をA*-basedAbductionに適用する際，探索空間の枝刈りの精度が著しく低下するという問題がある．本節ではそのような問題の解決策として，探索のガイドとして用いるヒューリスティック関数の計算方法を改良することにより，枝刈りの精度の低下を抑える手法を提案する．本節では，まずA*-basedAbductionについて説明し（~節），機能リテラルが引き起こす枝刈り精度低下の問題（~節）と解決策（~節）について述べる．</section>
  <subsection title="A*アルゴリズムに基づく仮説推論">まず，A*-basedAbductionのベースとなるILP-basedAbductionについて説明する．ILP-basedAbductionでは，まず観測と背景知識を入力として受け取り，それらに対して~節の潜在仮説集合生成手続きを適用し，潜在仮説集合を生成する．次に，潜在仮説集合と評価関数から，ILP問題を生成する．ここでは，仮説中での各リテラルの有無がILP変数の0-1値に，仮説に対する評価関数の値がILP問題の目的関数値に対応し，各リテラル間の論理的な依存関係はILP制約として表現される．最後に，ILPソルバを用いてILP問題を解くことにより，解仮説が得られる．A*-basedAbductionは，ILP-basedAbductionの潜在仮説集合の生成手続きをA*アルゴリズムに基づいて改良するものであり，解仮説に含まれる見込みが高い仮説を生成する操作を優先的に適用していくアルゴリズムである．より具体的には，まず事前準備として，背景知識における述語間の意味的な距離を評価しておく．ここでの述語間の意味的な距離とは，一方の述語から他方の述語に至る推論によって生じる評価関数値の増減量のヒューリスティックな見積もりである．同じ論理式に含まれる述語を互いに隣接関係にあると見なすと，図のように節点を述語，枝を隣接関係とする無向グラフ（以後，述語グラフと呼ぶ）が得られる．述語間の意味的な距離は，このグラフにおける距離—即ち述語間を繋ぐ枝の長さの総和として与えられる．各枝の長さは，枝に対応する知識ごとに自由に定義できるが，本論文では議論の簡単のために全ての枝の長さを1と定める．このとき述語グラフにおける述語間の距離は，一方の述語から他方の述語に至る推論の段数と一致する．例えば図によれば，図の背景知識において，述語bank,issueを持つリテラル同士を推論で繋ぐには最低でも3つの論理式を経由しなければならず，また述語he,moneyを持つリテラル間を結びつけるような推論は存在しない事が分かる．述語グラフの構造は背景知識にのみ依存するので，あらゆる述語対に対する距離を事前に計算しておき，行列として保持しておくことが可能である．次に，述語グラフに基づいて後ろ向き推論操作の良さを見積もりながら，潜在仮説集合の生成を行う．A*-basedAbductionの潜在仮説集合の生成手続きでは，「単一化仮説生成に寄与しないリテラルは解仮説に含まれない」という前提に基づき，解仮説に含まれる見込みがあるリテラル，すなわち単一化仮説生成に寄与しうるリテラルを仮説する後ろ向き推論操作のみを，評価関数の増減量の見込みがより高いものから優先的に実行していく．より具体的には，述語グラフにおける述語間の距離をA*アルゴリズムにおけるヒューリスティック関数として用いて，観測中の個々のリテラルから他のリテラルに至る推論を探索することによって，単一化仮説生成に寄与しない後ろ向き推論（すなわち他のどのリテラルとも距離が無限大になるようなリテラルを根拠とした後ろ向き推論）は適用対象から除外しつつ，評価関数値の増減量の見込みが高い後ろ向き推論（すなわち他のリテラルとの述語間距離が近いリテラルを根拠にした後ろ向き推論）から優先的に適用していく．これにより，解仮説に含まれ得ないリテラルを仮説するような後ろ向き推論操作は探索空間から除外され，結果として推論全体の計算効率が改善される．例えば図の潜在仮説集合におけるcat(x)やpoodle(x)は，それ自身が単一化仮説生成操作の対象になることも，そこから仮説されたリテラルが単一化仮説生成操作の対象になることも無いので，これらのリテラルを仮説するような後ろ向き推論操作は実行されない．また，評価関数値の増減量の見込みが高い推論が優先して実行されることにより，潜在仮説集合の生成にかけられる時間が制限された状況においても，より良い解が探索空間に含まれるように，与えられた時間内で可能な限り最善の探索を行う．これは実用においては極めて大きな利点である．さて，以降の議論のために用語を一つ定義する．単一化仮説生成の対象となったリテラル対l_1,l_2と，それらの根拠である観測リテラル対o_1,o_2について，o_1,o_2からl_1,l_2をそれぞれ仮説するために必要な後ろ向き推論と，l_1,l_2間の単一化仮説生成操作から構成される操作の系列を，o_1,o_2の間の論パスと呼ぶことにする．例えば図において，リテラル対go(x_1,x_2),get(y_1,y_2)の間の推論パスは，(1)go(x_1,x_2)からissue(x_2,u_1,x_1)への後ろ向き推論，(2)go(y_1,y_2)からissue(u_2,y_2,y_1)への後ろ向き推論，(3)issue(x_2,u_1,x_1)とissue(u_2,y_2,y_1)の間の単一化仮説生成によって構成される．定義より，全ての推論パスは，1回の単一化仮説生成操作と0回以上の後ろ向き推論操作によって構成されることに注意されたい．また，ある推論パスについて，そこに含まれる操作の系列に関与している観測リテラルの集合，すなわち推論パスで作られる推論が説明している観測リテラル集合を，推論パスの根拠と呼ぶ．さて，現在の仮説推論の実装としてはA*-basedAbductionが最も高速であるが，彼らの枠組みを適用する際，その評価関数は次の要件を満たしていなければならない．一つ目に，彼らの枠組みはILP-basedAbductionに基づいた枠組みであるため，評価関数は整数線形計画問題で表現可能であるものでなければならない．二つ目に，冗長な仮説に対しては評価が低下すること，すなわち単一化仮説生成に寄与しないリテラルが解仮説に含まれ得ないことが保証されていなければならない．なお，この条件については，Hobbsらの重み付き仮説推論をはじめとして，Thagardの提唱する「仮説の良さは簡潔さと顕現性によって決定される」とする主張に基づいて定義された評価関数であれば一般に充足される．ここで，二つ目の条件をNeo-Davidsonian形式に合わせて拡張することを考えよう．例えば，図(a)のNeo-Davidsonian形式で表現された推論は，表す意味そのものは図(b)のDavidsonian形式で表現された推論と同等であることから，図(b)と同様に解仮説には含まれ得ないと考えてよい．すなわち図(a)のように，単一の内容語リテラルとそれを親とする機能リテラルだけを根拠とする推論パスは，Thagardの主張に従うならば，解仮説には含まれないものと考えてよい．以上の議論から，以降で扱う評価関数は，整数線形計画問題で等価に表現可能であるとともに，以下に示す条件を充足すると仮定する：評価関数は，単一化仮説生成に寄与しないリテラルを含む候補仮説を解仮説とし	て選択しない．評価関数は，単一の内容語リテラルとそれを親とする機能リテラルの	みを根拠とした推論パスを含む候補仮説を解仮説として選択しない．以降ではこれらの条件をまとめて仮説の簡潔性条件と呼ぶ．</subsection>
  <subsection title="述語間距離の推定精度の低下">節で述べたようにA*-basedAbductionでは，図のような述語グラフを用いて，背景知識における述語間の意味的な距離を事前に評価しておき，仮説の探索空間の枝刈りを行う．述語グラフの上では，論理式の前件に含まれる各述語と後件に含まれる各述語のあらゆる組み合わせが接続されるため，機能リテラルのような，他のリテラルと高頻度で共起するリテラルを背景知識に含む場合には，述語グラフの中にハブとなるノードが形成される．その結果，解仮説を含まれ得るような推論が実際には存在しないリテラル対に対しても，誤って距離を近く見積もってしまう，という問題がある．例えば図で用いられている背景知識Bを考える：mistake(e_1)nsubj(e_1,x)&amp;foolish(e_2)(e_2,x)(e_1)nsubj(e_1,x)&amp;smart(e_2)(e_2,x)align*この背景知識に対して節で述べた手続きによって述語グラフを生成すると，図(a)のような述語グラフが作られる．前述のように，背景知識に含まれる機能述語nsubj/2がハブノードとなり，あらゆる内容語述語のペアが互いに到達可能と判定されることがわかる．しかし，これらの推論パスにより生成される仮説の中には，解仮説として選択されないことが保証されるものも含まれる．例えば，図(a)より，foolishとsmartを述語に持つリテラル対を結ぶような推論パスは存在すると推定されるが，3節で見てきたように，この推論パスから生成される仮説は不正な等価仮説を導くため，解仮説には成り得ない．このように，従来の述語グラフでは，述語間を繋ぐ推論が不正な等価仮説を導くかどうか考慮できていないために，機能リテラルを含む背景知識の上での述語間距離の推定精度が低下し，A*-basedAbductionの利点が失われてしまっている．</subsection>
  <subsection title="述語グラフの枝刈りによる高速化">本研究では，節で述べた問題を解消するために，述語グラフから特定の枝を除外することを提案する．つまり，図におけるfoolish(e)とsmart(e)のように，あるリテラル対を繋ぐ推論パスが常に不正な等価仮説を導く時に，それらの間の距離が無限大となるように，述語グラフの枝を除外する．これにより不正な等価仮説を導く推論は探索空間から除外され，探索を効率化できる．具体的な手法を述べる．本手法では，A*-basedAbductionについて，以下の2点の拡張を加える：述語グラフの構築において，機能リテラルとその親の両方が前件ある	いは後件に存在する含意型論理式に対しては，親に対する枝だけを述	語グラフに追加するものとする．例えばstudy(e_1)	nsubj(e_1,x)smart(e_2)nsubj(e_2,x)という論	理式に対しては，studyとsmartの間の枝だけを追加し，nsubjへ	の枝は追加しない．潜在仮説集合の生成において，機能リテラルと他のリテラルの間の述	語間距離には，機能リテラルの親の述語間距離を代わりに用いるもの	とする．例えば図の観測において，nsubj(e_1,j)	の親はsmart(e_1)であるので，nsubj(e_1,j)とfoolish(e_2)の	述語間距離には，smart(e_1)とfoolish(e_2)の述語間距離を用い	る．なお，親が複数存在する場合には，それらの中での最低値を採用	するものとする．このように拡張することで，不正な等価仮説を導く推論は探索空間から除外される．例えば，図の背景知識では，図(a),(b)に示されるように，機能述語nsubj/2への枝が述語グラフから取り除かれる．その結果，述語smartとfoolishの間の距離が無限大となり，不正な等価仮説を導くsmart,foolishを繋ぐ推論は，探索空間から除外される．なお，本手法を適用したときに得られる解は，仮説の整合性条件および簡潔性条件が充足されている限り，手法を適用しない場合の解と同様の解が得られること，すなわち元々の解が提案手法によって探索空間から枝刈りされないことが保証される．詳細な説明は付録Aに委ねるものとする．</subsection>
  <section title="実験"/>
  <subsection title="基本設定">本節では，本論文にて行った実験における基本的な設定について述べる．本実験における観測としては，Rahmanら~によって構築されたWinogradSchemaChallenge~の訓練データの問題1,305問をそれぞれ論理表現に変換したものを用いた．具体的には，各問題文に対してStanfordCoreNLPを用いて構文解析を行い，文中の単語および単語間の依存関係をそれぞれリテラルに変換した．各観測は平均して28個のリテラルから構成される．観測の例を表1のOに示す．なお，全ての観測について整合性条件を充足することを確認している．以降はこの観測集合をO_wscと表す．WinogradSchemaChallengeは，例えば``TonyhelpedJeffbecausehewantedtohelp.''のような文を入力として，指定された照応表現（ここでは``he''）の照応先として相応しいものを2つの選択肢（ここでは``''と``Jeff''）から選ぶタスクである．仮説推論の上では，照応先の選択は等価仮説の有無に対応する．例えば，表1のOに対して得られた解仮説にE_1=e_5が含まれるなら，``he''の照応先として``Tony''を選ぶことと等しい．なお，本実験では，各問題の照応先に対応する論理変数には定数（この例ではE_1,E_3）を割り当てることで，二つの照応先候補を同時に選択することを防いでいる．また背景知識には，我々がClueWeb12から自動獲得した因果関係知識を用いた．具体的には，まず，ClueWeb12に含まれる各文に対してStanfordCoreNLPを適用し，	共参照関係にある項を持つ動詞・形容詞とその周辺文脈のペア	5億個を獲得した．	例えば，	``TomhelpedMaryyesterday,	soMarythankedtoTom.''	より，Maryを介してペアとなっているTomhelpMaryyesterday,MarythanktoTom	を獲得した．	獲得したペアは，そのまま因果関係知識として用いるには特殊すぎる可能性があるため，	これらを統計的な基準によって一般化し，	論理表現に変換した．	より具体的には，獲得したペアをさまざまな抽象度に一般化した上で（例えば，TomhelpMaryyesterday,MarythanktoTomをTomhelpX,XthanktoTom,helpX,Xthankなどに変換した）頻度カウントを行い，一定以上の頻度のペアだけを残す，	というフィルタリング処理を施した（以降，これらのペアをイベントペアと呼ぶ）．結果として，278,802個の含意型論理式の集合B_epを得た．	知識の例を表1のB_epに示す．また，WordNetのSynsetによって定義される同義語・上位語の知識を論理表現に変換し，結果として235,706個の含意型論理式の集合B_wnを得た．WordNetから生成した論理式の例を表1のB_wnに示す．提案手法を適用するにあたっては，背景知識に出現する格関係および前置詞による修飾関係を表す全ての述語を機能述語として扱うこととした．評価関数には重み付き仮説推論を基に，整合性条件および簡潔性条件を充足するような評価関数を用いた．具体的には，重み付き仮説推論の評価関数に対して「全ての候補仮説は仮説の整合性条件および簡潔性条件を満たさなければならない」という制約を加えている．比較対象としてはA*-basedAbductionを用いた．以降の記述における従来手法とはA*-basedAbductionを指す．実験はの実装であるPhillipの上で行い，本論文の提案手法もPhillipを拡張することによって実装した．</subsection>
  <subsection title="推論効率の比較">本節では，推論効率の比較実験について報告する．この実験では，提案手法が従来手法と比べてどの程度効率的に最適解を導くことができるかを確かめるために，従来手法でも最適解が導出できる程度に小規模な設定での比較を行った．また，従来手法のほかに，4節の制約のみを用いた設定，5節の述語グラフの枝刈りのみを用いた設定との比較も行うことで，個々の手法による効率化の度合いを検証した．具体的な設定を以下に述べる，観測にはO_wscに含まれる全ての問題（1,305問）を用いた．背景知識には，B_epから187,732個の論理式を抽出の論理式のうち，ClueWeb中での共起頻度がある閾値を超えるイベントペアから生成された論理式のみを抽出した．背景知識を適当な規模に縮小する以外の意図は無いので，詳細は省略する．して用いた．また，リテラルの深さの最大値はd_max=1とした．これにより後ろ向き推論の入力は観測リテラルのみに限定される．また，推論時間が5分を超えるものについてはタイムアウトとした．この実験設定を，以降はSMALLと呼ぶ．実験設定SMALLにおける実験結果を図，図，図に示す．図中の各点は開発セット1,305問のうち，少なくとも一方の実験設定がタイムアウトせずに最適解を求められた問題1,095問について，それぞれの問題における推論時間を表す．各点の座標は，横軸が提案手法による推論時間に対応し，縦軸が比較対象での推論時間に対応する．図ではA*-basedAbductionによる推論時間，図では提案手法において5節で述べた述語グラフの枝刈りのみを適用した場合の推論時間，図では提案手法において4節で述べた等価仮説への制約のみを適用した場合の推論時間が，縦軸に対応する．なお，5分以内に解を導くことが出来ずタイムアウトした問題については300秒としてプロットしている．また直線はy=xを表す．よって，この直線よりも上にある点については提案手法によって推論時間が改善されていると見做すことができる．図からは，従来手法と比べたときの，提案手法による効率化の程度を確認できる．この結果より，どのような規模の問題においても提案手法は従来手法と比べて遥かに短い時間で，平均して数十倍から数百倍の速度で解を導けていることが確かめられた．図からは，4節で提案した等価仮説の制約による効率化の程度を確認することができる．この結果から，探索空間が極めて小さい一部の問題に対しては効率の低下が見受けられるものの，それ以外の問題についてはいずれもより効率的な推論が実現できていることが確かめられた．推論効率が低下している一部の問題については，この制約によって除外されるような単一化仮説生成操作が探索空間に存在しない，あるいはその数が極めて少ないために，制約の判定にかかる計算量が制約を課すことで削減される計算量を上回ってしまっていると考えられる．図からは，5節で提案した述語グラフの枝刈りによる効率化の程度を確認することができる．図での結果とほぼ同様の結果であるものの，述語グラフの枝刈りによって探索空間から除外される推論は，等価仮説の制約によって探索空間から除外される推論の大半を包含していることから，これは極めて自然な結果であるといえる．また，タイムアウトせずに最適解が得られた問題については，問題設定に関わらず最適解の評価関数値が同じ値であったことが確かめられた．このことから，提案手法が解の健全性を損なわないことが実験的にも示された．</subsection>
  <subsection title="現実的な設定での比較">前節の実験では，提案手法が従来手法と比べて遥かに効率的に解仮説を導出できていることが確かめられた．しかしながら前節の実験設定(SMALL)では，従来手法でも最適解が導けるようにするために，背景知識や解の探索範囲の縮小や，タイムアウトの時間を長めにとるなど，実際のタスク適用とはかなり乖離した設定になってしまっている．それを踏まえ本節では，参考実験として，より実際のタスク適用に即した設定において比較実験を行った．この実験では，（本論文の本来のスコープではないものの，）タスクの解析精度をみることで，我々のシステムが行っている推論が，意味的な解釈として一定の妥当性を持つ推論を実現できていることを確かめる．具体的な設定を述べる．前述したように，今回用いたデータセットには，因果関係知識のみでは解くことの出来ない種類の問題—例えば否定や逆接を含む問題，特定の固有名詞に関する知識が必要な問題，数量表現を扱う問題など—が多数含まれている．そこで本実験では，O_wscに含まれる観測のうち無作為に選んだ100問について，個々の問題を解くのに必要な知識の種類を人手で分類した．そして，その100問のうち因果関係知識の適用のみで解けると思われる問題32問を観測として用いた．背景知識としては，B_epとB_wnに含まれる全ての論理式（514,508個）を用いた．またリテラルの深さの最大値はd_max=2とした．これは，3個以上の因果関係を繋げて導かれる仮説は意味的に不自然な説明であることが多いという経験則に基いている．また，潜在仮説集合の生成は10秒で中断し，その時点での潜在仮説集合に対する解を解仮説として扱った．推論全体では，推論時間が1分を超えるものをタイムアウトとした．この実験設定を，以降はLARGEと呼ぶ．実験設定LARGEにおける実験結果を表2に示す．この結果より，従来手法では殆どの問題で解が得られていない一方で，提案手法ではそれがある程度改善されていることが分かる．これは，述語グラフの枝刈りを導入したことによって，A*-basedAbductionにおける述語間の距離推定の精度が改善され，後ろ向き推論の候補をより短い時間で列挙できるようになったことが大きいと考えられる．また，タスクの解析精度については，表2の適合率を見る限り，ある程度意味のある推論が実現できていることが伺える．その一方で再現率は低く，今後，解析精度を向上させていくためには，背景知識の拡充・高精度化や，評価関数のモデルパラメータの調整など，様々な改善が必要である．しかしながら，少なくとも今回の提案手法の導入により，実世界の問題に即した規模の背景知識および論理表現の上での仮説推論が，初めて実現可能になった．このことは，当該分野において非常に重要な貢献である．</subsection>
  <section title="まとめ">仮説推論は，文章に明示されていない情報の顕在化を行うための有望な枠組みと考えられてきた一方，背景知識や観測の規模に対して指数関数的に増大する計算時間が，実問題への応用を阻んできた．このような問題に対し本論文では，格関係や前置詞による修飾関係などの依存関係を表すリテラルに関して起こる計算量の問題に着目し，そのようなリテラルに対して起こる冗長な推論を探索空間から除外することによって，仮説推論を効率化する手法を提案した．また，既存手法との比較実験から，構築したシステムが従来のシステムよりも遥かに高速であることを示した．今後の展望としては，潜在仮説集合の生成において，言語そのものに対する知識を用いて探索空間の枝刈りをすることが考えられる．その一つの例としては，それぞれの依存関係が持つ性質を利用することが挙げられる．例えば，物体の位置的な上下関係のように推移律が成り立つ場合や，述語項関係のように一つのgovernorに対して一つしかdependentが存在できない場合，物体同士の隣接関係のように対称律が成り立つ場合など，それぞれの関係は固有の性質を持つ．これらの性質を潜在仮説集合の生成の時に考慮することができれば，その性質に反するような推論を探索空間から除外できることが期待される．例えば，主格関係が一つのgovernorに対して一つしか定義できないことが分かっているなら，go(e_1)go(e_2)nsubj(e_1,x_1)nsubj(e_2,x_2)のような観測が与えられたとき，e_1=e_2かつx_1x_2であるような仮説は適切な説明ではないことが分かる．よって，このような仮説を候補仮説として列挙するような手続きを探索空間から除外することが出来れば，計算負荷の軽減に繋げられる可能性がある．また，潜在仮説集合の生成の手続きと，ILP問題を最適化する手続きを，相互にやりとりしながら進めることによって，推論速度を向上させることも考えられる．現状ではこれらの手続きは完全に逐次的に行われるが，潜在仮説集合を生成する段階ではどこまで探索すれば十分なのかが全くの不明であるために，必要最低限の範囲だけを探索することが難しいという問題がある．これに対して，潜在仮説集合の生成の途中の結果に対する解仮説を随時導出しながら，その結果に応じて潜在仮説集合の生成を適切に打ち切ることができれば，全体の計算量を削減できると考えられる．他には，仮説推論を実問題へ適用していくことも進めていく．本研究によって仮説推論の計算負荷は大幅に効率化され，大規模知識を用いた仮説推論は現実的な時間で実現可能となった．これにより，大規模知識を用いた仮説推論の枠組みにおいて，実タスク上での精度評価や，他の先行研究との定量的な比較が可能になったといえる．よって今後は，仮説推論に用いるための高精度かつ大規模な背景知識の構築や，より談話理解のタスクに適した評価関数モデルの構築を進めていきたいと考えている．</section>
  <section title="提案手法が解の最適性を保持することの証明">本節では，仮説の整合性条件および簡潔性条件が充足されるならば，5節で提案した手法に基づく述語グラフの枝刈りを用いて得られる解が最適性を保つこと，即ち手法適用後に探索空間から除外されるような要素仮説について，それらが常に解仮説とならないことを示す．任意の述語p,qに対する，述語グラフの枝刈り適用前の述語間距離をh_1(p,q)，適用後の述語間距離をh_2(p,q)と表す．まず，述語グラフの枝刈りを適用することによって除外される推論パスの集合Rに着目する．形式的には，Rは，h_1(o_1,o_2)&lt;かつh_2(o_1,o_2)=を満たすような観測リテラル対o_1,o_2を端点とするような推論パスの集合，と定義される．本証明のゴールは，「Rに含まれるすべての推論パスRRから生成される候補仮説H_Rが，整合性条件および簡潔性条件が充足される状況下では，常に解仮説とならないことを示す」ことである．証明の戦略は次のとおりである．まず，Rの部分集合について，整合性条件と簡潔性条件より，そこに含まれる推論パスから生成される候補仮説が解仮説とならないことを示す．次に，それ以外の推論パスの集合R'について，すべてのR'R'が常に機能リテラルの単一化仮説生成を含むことを証明し，かつその単一化仮説生成操作が常に不正な等価仮説を導くことを示す．まず，Rに含まれる推論パスのうち，以下に示すような推論パスRRから生成される候補仮説については，整合性条件および簡潔性条件により解仮説とならないことが自明である：Rは機能リテラルの単一化仮説生成を含み，かつ単一化仮説生成の	対象である機能リテラル対の少なくとも一方が親を持たない．Rは不正な等価仮説を導くような後ろ向き推論を含む．Rの端点o_1,o_2は同じ親を持つ機能リテラルであり，親以外の内容語リ	テラルが推論パスの根拠に含まれない．Rの端点o_1,o_2のうち一方は機能リテラルであり，他方がその親であ	り，親以外の内容語リテラルが推論パスの根拠に含まれない．(1)および(2)が示す場合については整合性条件2,3より，(3)および(4)が示す場合については簡潔性条件より，明らかに解仮説とならない．したがって，以降ではこれらの場合に当てはまらない推論パスの集合R'Rについてのみ検討する．R'の定義より，すべてのR'R'について，不正な等価仮説を導く後ろ向き推論がR'に含まれないことは自明であるから，以降は，すべてのR'R'について，不正な等価仮説を導く単一化仮説生成操作がR'に含まれることを示す．まず，すべてのR'R'が常に機能リテラルの単一化仮説生成を含むことを証明する．背理法を用いて証明する．すなわち，「推論パスR'が常に機能リテラル間の単一化仮説生成操作を含まない」ことを仮定すると，矛盾が生じることを以下に示す．まず，背理法の仮定は，~節の定義より，「推論パスR'が内容語リテラル間の単一化仮説生成操作を含む場合がある」と言い換えることができる．形式的には，h_1(o_1,o_2)&lt;かつh_2(o_1,o_2)=を満たすような観測リテラル対o_1,o_2がそれぞれ内容語リテラルc_1,c_2を仮説しており，c_1,c_2が互いに単一化している場合が存在する，ということである．このとき，c_1,c_2は同じ述語を持つことから，明らかにh_1(c_1,c_2)=h_2(c_1,c_2)=0&lt;である．R'の定義より，R'には不正な等価仮説を導くような後ろ向き推論は含まれないので，c_1の直接的な根拠となっている任意のリテラルをd_1とおくとh_2(c_1,d_1)&lt;が成り立つ．同様にc_2の直接的な根拠となっている任意のリテラルをd_2とおくとh_2(c_2,d_2)&lt;が成り立つ．よって，h_2(c_1,c_2)&lt;であるのでh_2(d_1,d_2)&lt;も成り立つ．このような議論はd_1およびd_2の根拠についても成り立つことから，帰納的にh_2(o_1,o_2)&lt;も成り立つ．しかし，これは前提であるh_2(o_1,o_2)=と矛盾する．以上から，R'は，常に機能リテラル間の単一化を導く．proof次に，R'における機能リテラルf_1,f_2の単一化仮説生成操作が，常に不正な等価仮説を導くことを示す．f_1,f_2の親をそれぞれp_1,p_2とおき，p_1,p_2が同一事象を表し得ない，すなわちh_2(p_1,p_2)=であることを，背理法により示す．背理法の仮定は，h_2(p_1,p_2)&lt;である．この仮定のもとでは，機能リテラルにおける述語間距離の計算手続きより，h_2(f_1,f_2)&lt;となるので，f_1,f_2を経由するo_1,o_2についても同様にh_2(o_1,o_2)&lt;となる．しかし，これは前提であるh_2(o_1,o_2)=と矛盾する．この事から，h_2(p_1,p_2)=であり，R'によって単一化仮説生成の対象である機能リテラルの親は，それぞれ同一事象には成り得ないこと，すなわち不正な等価仮説を導くことが示された．proof以上から，提案手法を適用することによって除外される推論パスの集合Rは，最初に挙げた4つの場合のほかには，機能リテラルに対する単一化仮説生成操作を含み，かつそれらの親が同一事象に成り得ず，不正な等価仮説を導く場合に限定される．ゆえに，すべてのRRについて，Rから生成される候補仮説は解仮説とならないことが証明される．以上より，本手法によって得られる解は最適性を保つ．document</section>
</root>
